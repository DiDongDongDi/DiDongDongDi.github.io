{"meta":{"title":"DIDA LAB","subtitle":"DiDong's Blog","description":"As a young man, prepare and rule.","author":"DiDong","url":"https://didongdongdi.github.io","root":"/"},"pages":[{"title":"about","date":"2019-04-22T05:28:15.000Z","updated":"2019-05-25T09:26:07.724Z","comments":true,"path":"about/index.html","permalink":"https://didongdongdi.github.io/about/index.html","excerpt":"","text":"Any one has first time."},{"title":"categories","date":"2018-06-08T12:28:50.000Z","updated":"2019-05-25T09:27:18.325Z","comments":true,"path":"categories/index.html","permalink":"https://didongdongdi.github.io/categories/index.html","excerpt":"","text":""},{"title":"gallery","date":"2019-05-25T09:23:43.000Z","updated":"2019-05-25T09:24:44.483Z","comments":true,"path":"gallery/index.html","permalink":"https://didongdongdi.github.io/gallery/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-06-08T12:27:45.000Z","updated":"2019-05-25T09:26:43.942Z","comments":true,"path":"tags/index.html","permalink":"https://didongdongdi.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"u盘分区和win7的usb3.0","slug":"U盘分区和WIN7的USB3.0","date":"2020-04-05T06:35:34.000Z","updated":"2020-04-05T06:50:51.823Z","comments":true,"path":"2020/04/05/U盘分区和WIN7的USB3.0/","link":"","permalink":"https://didongdongdi.github.io/2020/04/05/U%E7%9B%98%E5%88%86%E5%8C%BA%E5%92%8CWIN7%E7%9A%84USB3.0/","excerpt":"U盘分区win10 1703 之前的版本都不支持识别u盘的多个分区, 即只能识别第一个分区. 原因参考知乎问答-为什么Windows不支持U盘多分区","text":"U盘分区win10 1703 之前的版本都不支持识别u盘的多个分区, 即只能识别第一个分区. 原因参考知乎问答-为什么Windows不支持U盘多分区 所以对于一个u盘来说, 只能把存储分区放在第一个, boot分区放在后面. archlinux的live系统的启动分区(u盘多分区)的制作方法可以在官方文档中找到, 参考https://wiki.archlinux.org/index.php/USB_flash_installation_media_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#GNU/Linux_2. 需要注意的一点是卷标或UUID的修改, 可以在放入启动文件之前就修改号卷标, 也可以后面修改启动文件中的卷标或使用UUID, 否则会导致启动失败. WIN7的USB3.0由于WIN7并不集成USB3.0的驱动, 所以需要手动安装插件. 建议直接安装驱动精灵的自动安装驱动的软件, 装完驱动马上卸载.","categories":[{"name":"教程","slug":"教程","permalink":"https://didongdongdi.github.io/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"usb","slug":"usb","permalink":"https://didongdongdi.github.io/tags/usb/"}],"author":"didong"},{"title":"Numpy手撸神经网络和Keras","slug":"Numpy手撸神经网络和Keras","date":"2020-04-02T12:49:00.000Z","updated":"2020-04-03T03:22:26.727Z","comments":true,"path":"2020/04/02/Numpy手撸神经网络和Keras/","link":"","permalink":"https://didongdongdi.github.io/2020/04/02/Numpy%E6%89%8B%E6%92%B8%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8CKeras/","excerpt":"Keras简单的神经网络首先使用Keras来搭建一个简单的神经网络","text":"Keras简单的神经网络首先使用Keras来搭建一个简单的神经网络 123456789101112131415# Package imports# Matplotlib is a matlab like plotting libraryimport matplotlibimport matplotlib.pyplot as plt# Numpy handles matrix operationsimport numpy as np# SciKitLearn is a useful machine learning utilities libraryimport sklearn# The sklearn dataset module helps generating datasetsimport sklearn.datasetsimport sklearn.linear_model# Display plots inline and change default figure size%matplotlib inlinematplotlib.rcParams['figure.figsize'] = (16.0, 9.0) 12345# Generate a dataset and plot itnp.random.seed(0)# 这是两个卫星的数据集, 但是现在有一些噪音, 需要将它们分开X, y = sklearn.datasets.make_moons(200, noise=0.15)y = y.reshape(200,1) 1from keras.layers import Dense, Activation 1from keras.models import Sequential 1model = Sequential() WARNING:tensorflow:From /home/didong/anaconda/anaconda3/lib/python3.7/site-packages/keras/backend/tensorflow_backend.py:74: The name tf.get_default_graph is deprecated. Please use tf.compat.v1.get_default_graph instead.1model.add(Dense(3,input_dim=2)) WARNING:tensorflow:From /home/didong/anaconda/anaconda3/lib/python3.7/site-packages/keras/backend/tensorflow_backend.py:517: The name tf.placeholder is deprecated. Please use tf.compat.v1.placeholder instead. WARNING:tensorflow:From /home/didong/anaconda/anaconda3/lib/python3.7/site-packages/keras/backend/tensorflow_backend.py:4138: The name tf.random_uniform is deprecated. Please use tf.random.uniform instead.1model.add(Activation('tanh')) 12model.add(Dense(1))model.add(Activation('sigmoid')) 1model.summary() _________________________________________________________________ Layer (type) Output Shape Param # ================================================================= dense_1 (Dense) (None, 3) 9 _________________________________________________________________ activation_1 (Activation) (None, 3) 0 _________________________________________________________________ dense_2 (Dense) (None, 1) 4 _________________________________________________________________ activation_2 (Activation) (None, 1) 0 ================================================================= Total params: 13 Trainable params: 13 Non-trainable params: 0 _________________________________________________________________1model.compile(optimizer='sgd',loss='binary_crossentropy',metrics=['acc']) WARNING:tensorflow:From /home/didong/anaconda/anaconda3/lib/python3.7/site-packages/keras/optimizers.py:790: The name tf.train.Optimizer is deprecated. Please use tf.compat.v1.train.Optimizer instead. WARNING:tensorflow:From /home/didong/anaconda/anaconda3/lib/python3.7/site-packages/keras/backend/tensorflow_backend.py:3376: The name tf.log is deprecated. Please use tf.math.log instead. WARNING:tensorflow:From /home/didong/anaconda/anaconda3/lib/python3.7/site-packages/tensorflow/python/ops/nn_impl.py:180: add_dispatch_support.&lt;locals&gt;.wrapper (from tensorflow.python.ops.array_ops) is deprecated and will be removed in a future version. Instructions for updating: Use tf.where in 2.0, which has the same broadcast rule as np.where1history = model.fit(X,y,epochs=50) WARNING:tensorflow:From /home/didong/anaconda/anaconda3/lib/python3.7/site-packages/keras/backend/tensorflow_backend.py:986: The name tf.assign_add is deprecated. Please use tf.compat.v1.assign_add instead. Epoch 1/50 200/200 [==============================] - 1s 3ms/step - loss: 0.7140 - acc: 0.3950 Epoch 2/50 200/200 [==============================] - 0s 44us/step - loss: 0.7082 - acc: 0.4100 Epoch 3/50 200/200 [==============================] - 0s 43us/step - loss: 0.7028 - acc: 0.4350 Epoch 4/50 200/200 [==============================] - 0s 43us/step - loss: 0.6974 - acc: 0.4700 Epoch 5/50 200/200 [==============================] - 0s 42us/step - loss: 0.6921 - acc: 0.4950 Epoch 6/50 200/200 [==============================] - 0s 44us/step - loss: 0.6871 - acc: 0.5300 Epoch 7/50 200/200 [==============================] - 0s 42us/step - loss: 0.6820 - acc: 0.5650 Epoch 8/50 200/200 [==============================] - 0s 43us/step - loss: 0.6777 - acc: 0.5900 Epoch 9/50 200/200 [==============================] - 0s 44us/step - loss: 0.6729 - acc: 0.6400 Epoch 10/50 200/200 [==============================] - 0s 42us/step - loss: 0.6685 - acc: 0.6650 Epoch 11/50 200/200 [==============================] - 0s 42us/step - loss: 0.6640 - acc: 0.7050 Epoch 12/50 200/200 [==============================] - 0s 42us/step - loss: 0.6596 - acc: 0.7350 Epoch 13/50 200/200 [==============================] - 0s 42us/step - loss: 0.6554 - acc: 0.7550 Epoch 14/50 200/200 [==============================] - 0s 43us/step - loss: 0.6514 - acc: 0.7750 Epoch 15/50 200/200 [==============================] - 0s 42us/step - loss: 0.6473 - acc: 0.8500 Epoch 16/50 200/200 [==============================] - 0s 42us/step - loss: 0.6434 - acc: 0.8600 Epoch 17/50 200/200 [==============================] - 0s 43us/step - loss: 0.6397 - acc: 0.8450 Epoch 18/50 200/200 [==============================] - 0s 42us/step - loss: 0.6362 - acc: 0.8400 Epoch 19/50 200/200 [==============================] - 0s 41us/step - loss: 0.6323 - acc: 0.8250 Epoch 20/50 200/200 [==============================] - 0s 48us/step - loss: 0.6290 - acc: 0.8150 Epoch 21/50 200/200 [==============================] - 0s 42us/step - loss: 0.6254 - acc: 0.8150 Epoch 22/50 200/200 [==============================] - 0s 42us/step - loss: 0.6222 - acc: 0.8100 Epoch 23/50 200/200 [==============================] - 0s 42us/step - loss: 0.6187 - acc: 0.8100 Epoch 24/50 200/200 [==============================] - 0s 44us/step - loss: 0.6158 - acc: 0.8100 Epoch 25/50 200/200 [==============================] - 0s 43us/step - loss: 0.6126 - acc: 0.8100 Epoch 26/50 200/200 [==============================] - 0s 43us/step - loss: 0.6094 - acc: 0.8050 Epoch 27/50 200/200 [==============================] - 0s 43us/step - loss: 0.6064 - acc: 0.8050 Epoch 28/50 200/200 [==============================] - 0s 43us/step - loss: 0.6031 - acc: 0.8050 Epoch 29/50 200/200 [==============================] - 0s 43us/step - loss: 0.5997 - acc: 0.8050 Epoch 30/50 200/200 [==============================] - 0s 42us/step - loss: 0.5968 - acc: 0.8050 Epoch 31/50 200/200 [==============================] - 0s 43us/step - loss: 0.5939 - acc: 0.8000 Epoch 32/50 200/200 [==============================] - 0s 43us/step - loss: 0.5906 - acc: 0.7900 Epoch 33/50 200/200 [==============================] - 0s 42us/step - loss: 0.5876 - acc: 0.7850 Epoch 34/50 200/200 [==============================] - 0s 43us/step - loss: 0.5846 - acc: 0.7850 Epoch 35/50 200/200 [==============================] - 0s 43us/step - loss: 0.5818 - acc: 0.7850 Epoch 36/50 200/200 [==============================] - 0s 43us/step - loss: 0.5789 - acc: 0.7850 Epoch 37/50 200/200 [==============================] - 0s 43us/step - loss: 0.5760 - acc: 0.7850 Epoch 38/50 200/200 [==============================] - 0s 42us/step - loss: 0.5731 - acc: 0.7800 Epoch 39/50 200/200 [==============================] - 0s 43us/step - loss: 0.5706 - acc: 0.7800 Epoch 40/50 200/200 [==============================] - 0s 42us/step - loss: 0.5680 - acc: 0.7850 Epoch 41/50 200/200 [==============================] - 0s 42us/step - loss: 0.5653 - acc: 0.7850 Epoch 42/50 200/200 [==============================] - 0s 43us/step - loss: 0.5625 - acc: 0.7850 Epoch 43/50 200/200 [==============================] - 0s 43us/step - loss: 0.5597 - acc: 0.7850 Epoch 44/50 200/200 [==============================] - 0s 42us/step - loss: 0.5573 - acc: 0.7850 Epoch 45/50 200/200 [==============================] - 0s 43us/step - loss: 0.5548 - acc: 0.7850 Epoch 46/50 200/200 [==============================] - 0s 43us/step - loss: 0.5523 - acc: 0.7800 Epoch 47/50 200/200 [==============================] - 0s 42us/step - loss: 0.5497 - acc: 0.7750 Epoch 48/50 200/200 [==============================] - 0s 42us/step - loss: 0.5475 - acc: 0.7850 Epoch 49/50 200/200 [==============================] - 0s 42us/step - loss: 0.5450 - acc: 0.7850 Epoch 50/50 200/200 [==============================] - 0s 42us/step - loss: 0.5424 - acc: 0.7900使用Numpy手撸的简单的神经网络然后使用numpy对上面的神经网络做一个简单的重复 1234567891011121314151617# Package imports# Matplotlib is a matlab like plotting libraryimport matplotlibimport matplotlib.pyplot as plt# Numpy handles matrix operationsimport numpy as np# SciKitLearn is a useful machine learning utilities libraryimport sklearn# The sklearn dataset module helps generating datasetsimport sklearn.datasetsimport sklearn.linear_model# Display plots inline and change default figure size%matplotlib inlinematplotlib.rcParams['figure.figsize'] = (10.0, 8.0) 123456789101112131415161718192021222324252627282930313233343536def sigmoid(x): return 1/(1+np.exp(-x))def bce_loss(y, y_hat): # minval的目的是为了防止计算出来的值太接近零, 导致计算机将其作为0来计算 minval = 0.000000000001 N = y.shape[0] l = -1/N * np.sum(y * np.log(y_hat.clip(min=minval)) + (1-y) * np.log((1-y_hat).clip(min=minval))) return ldef bce_loss_derivative(y,y_hat): # 至于为什么是这个值, 可以参考https://stats.stackexchange.com/questions/219241/gradient-for-logistic-loss-function # 注意, 这里的y_hat是经过sigmoid函数得到的结果, 事实上就是链接当中的p, 而链接中的y_hat指的是线性计算后的结果 # 这里的求导是对sigmoid函数的输入求导, 即对线性的结果进行求导 return (y_hat-y)# 前向传播函数def forward_prop(model,a0): # Load parameters from model W1, b1, W2, b2 = model['W1'], model['b1'], model['W2'], model['b2'] # Linear step z1 = a0.dot(W1) + b1 # First activation function a1 = np.tanh(z1) # Second linear step z2 = a1.dot(W2) + b2 # Second activation function a2 = sigmoid(z2) # 前向传播得到的中间值 cache = &#123;'a0':a0,'z1':z1,'a1':a1,'z1':z1,'a2':a2&#125; return cache 123def tanh_derivative(x): # 原因参考https://socratic.org/questions/what-is-the-derivative-of-tanh-x return (1 - np.power(x, 2)) 123456789101112131415161718192021222324252627282930313233343536# 反向传播函数def backward_prop(model,cache,y): # Load parameters from model W1, b1, W2, b2 = model['W1'], model['b1'], model['W2'], model['b2'] # Load forward propagation results a0,a1, a2 = cache['a0'],cache['a1'],cache['a2'] # Backpropagation # Calculate loss derivative with respect to output # 这里本来就是对dz2进行求导 dz2 = bce_loss_derivative(y=y,y_hat=a2) # Calculate loss derivative with respect to second layer weights dW2 = (a1.T).dot(dz2) # Calculate loss derivative with respect to second layer bias # 考虑到db2并不是一列值, 而是一个单独的值, 所以求和叠加 db2 = np.sum(dz2, axis=0, keepdims=True) # Calculate loss derivative with respect to first layer dz1 = dz2.dot(W2.T) * tanh_derivative(a1) # Calculate loss derivative with respect to first layer weights dW1 = np.dot(a0.T, dz1) # Calculate loss derivative with respect to first layer bias db1 = np.sum(dz1, axis=0) # Store gradients grads = &#123;'dW2':dW2,'db2':db2,'dW1':dW1,'db1':db1&#125; return grads# 以上计算都可以通过算式反推得出# a0 --W1--b1--&gt; z1 --tanh--&gt; a1 --W2--b2--&gt; z2 --sigmoid--&gt; a2# 上面是正向传播的过程, 反推就可以得出反向传播的过程 123456789101112131415# Helper function to plot a decision boundary.# If you don't fully understand this function don't worry, it just generates the contour plot below.def plot_decision_boundary(pred_func): # Set min and max values and give it some padding x_min, x_max = X[:, 0].min() - .5, X[:, 0].max() + .5 y_min, y_max = X[:, 1].min() - .5, X[:, 1].max() + .5 h = 0.01 # Generate a grid of points with distance h between them xx, yy = np.meshgrid(np.arange(x_min, x_max, h), np.arange(y_min, y_max, h)) # Predict the function value for the whole gid Z = pred_func(np.c_[xx.ravel(), yy.ravel()]) Z = Z.reshape(xx.shape) # Plot the contour and training examples plt.contourf(xx, yy, Z, cmap=plt.cm.Spectral) plt.scatter(X[:, 0], X[:, 1], c=y.flatten(), cmap=plt.cm.Spectral) 12345# Generate a dataset and plot itnp.random.seed(0)X, y = sklearn.datasets.make_moons(200, noise=0.15)y = y.reshape(200,1)plt.scatter(X[:,0], X[:,1], s=40, c=y.flatten(), cmap=plt.cm.Spectral) &lt;matplotlib.collections.PathCollection at 0x7fb08a5e0240&gt; 12345678910def predict(model, x): # Do forward pass c = forward_prop(model,x) #get y_hat y_hat = c['a2'] # Turn values to either 1 or 0 y_hat[y_hat &gt; 0.5] = 1 y_hat[y_hat &lt; 0.5] = 0 return y_hat 1234567891011def calc_accuracy(model,x,y): # Get total number of examples m = y.shape[0] # Do a prediction with the model pred = predict(model,x) # Ensure prediction and truth vector y have the same shape pred = pred.reshape(y.shape) # Calculate the number of wrong examples error = np.sum(np.abs(pred-y)) # Calculate accuracy return (m - error)/m * 100 12345678910111213141516def initialize_parameters(nn_input_dim,nn_hdim,nn_output_dim): # First layer weights W1 = 2 *np.random.randn(nn_input_dim, nn_hdim) - 1 # First layer bias b1 = np.zeros((1, nn_hdim)) # Second layer weights W2 = 2 * np.random.randn(nn_hdim, nn_output_dim) - 1 # Second layer bias b2 = np.zeros((1, nn_output_dim)) # Package and return model model = &#123; 'W1': W1, 'b1': b1, 'W2': W2, 'b2': b2&#125; return model 12345678910111213def update_parameters(model,grads,learning_rate): # Load parameters W1, b1, W2, b2 = model['W1'], model['b1'], model['W2'], model['b2'] # Update parameters W1 -= learning_rate * grads['dW1'] b1 -= learning_rate * grads['db1'] W2 -= learning_rate * grads['dW2'] b2 -= learning_rate * grads['db2'] # Store and return parameters model = &#123; 'W1': W1, 'b1': b1, 'W2': W2, 'b2': b2&#125; return model 1234567891011121314151617181920def train(model,X_,y_,learning_rate, num_passes=20000, print_loss=False): # Gradient descent. For each batch... for i in range(0, num_passes): # Forward propagation cache = forward_prop(model,X_) # Backpropagation grads = backward_prop(model,cache,y) # Gradient descent parameter update # Assign new parameters to the model model = update_parameters(model=model,grads=grads,learning_rate=learning_rate) # Pring loss &amp; accuracy every 100 iterations if print_loss and i % 100 == 0: y_hat = cache['a2'] print('Loss after iteration',i,':',bce_loss(y,y_hat)) print('Accuracy after iteration',i,':',calc_accuracy(model,X_,y_),'%') return model 1234# Hyper parametershiden_layer_size = 3# I picked this value because it showed good results in my experimentslearning_rate = 0.01 12345# Initialize the parameters to random values. We need to learn these.np.random.seed(0)# This is what we return at the endmodel = initialize_parameters(nn_input_dim=2, nn_hdim= hiden_layer_size, nn_output_dim= 1)model = train(model,X,y,learning_rate=learning_rate,num_passes=1000,print_loss=True) Loss after iteration 0 : 0.7590872634269914 Accuracy after iteration 0 : 86.5 % Loss after iteration 100 : 0.2574839032266012 Accuracy after iteration 100 : 87.5 % Loss after iteration 200 : 0.23296065120486092 Accuracy after iteration 200 : 91.0 % Loss after iteration 300 : 0.06607469435615165 Accuracy after iteration 300 : 98.5 % Loss after iteration 400 : 0.039048891767398106 Accuracy after iteration 400 : 99.0 % Loss after iteration 500 : 0.03162355657934422 Accuracy after iteration 500 : 99.5 % Loss after iteration 600 : 0.02808346934457852 Accuracy after iteration 600 : 99.5 % Loss after iteration 700 : 0.02596724219386473 Accuracy after iteration 700 : 99.5 % Loss after iteration 800 : 0.02453302540660454 Accuracy after iteration 800 : 99.5 % Loss after iteration 900 : 0.023480001190425943 Accuracy after iteration 900 : 99.5 %123# Plot the decision boundaryplot_decision_boundary(lambda x: predict(model,x))plt.title(\"Decision Boundary for hidden layer size 3\") Text(0.5, 1.0, &apos;Decision Boundary for hidden layer size 3&apos;) 12","categories":[{"name":"Notes","slug":"Notes","permalink":"https://didongdongdi.github.io/categories/Notes/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://didongdongdi.github.io/tags/Python/"},{"name":"神经网络","slug":"神经网络","permalink":"https://didongdongdi.github.io/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"}],"author":"DiDong"},{"title":"hexo模版渲染错误","slug":"hexo模版渲染错误","date":"2020-03-22T06:33:41.000Z","updated":"2020-03-22T06:45:22.150Z","comments":true,"path":"2020/03/22/hexo模版渲染错误/","link":"","permalink":"https://didongdongdi.github.io/2020/03/22/hexo%E6%A8%A1%E7%89%88%E6%B8%B2%E6%9F%93%E9%94%99%E8%AF%AF/","excerpt":"","text":"在写完一篇关于shell语法的笔记后, hexo g生成网页时报错, 错误如下: 12FATAL Something&#39;s wrong. Maybe you can find the solution here: http:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;troubleshooting.htmlTemplate render error: (unknown path) 进入给出的链接, 可能是_config.yml文件或新的post/page有语法错误, 但不确定是哪篇文章 参考https://github.com/hexojs/hexo/issues/1837, 可以通过hexo g --debug定位出错的文章 最后通过不断二分定位了文章中出错的地方, 是一句bash命令: 1echo $&#123;!#&#125; 总之, 以后比较特殊的字符和命令还是用 ``` 进行包裹比较好","categories":[{"name":"Notes","slug":"Notes","permalink":"https://didongdongdi.github.io/categories/Notes/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://didongdongdi.github.io/tags/Hexo/"}],"author":"DiDong"},{"title":"Flipped (Week 5)","slug":"Flipped (Week 5)","date":"2020-03-22T05:52:25.000Z","updated":"2020-03-22T06:54:42.374Z","comments":true,"path":"2020/03/22/Flipped (Week 5)/","link":"","permalink":"https://didongdongdi.github.io/2020/03/22/Flipped%20(Week%205)/","excerpt":"2018-08-08-p18 notion [‘nəʊʃ(ə)n] n. 概念; 见解; 打算 humble [‘hʌmbl] adj. 谦逊的; 简陋的; (级别或地位)低下的; 不大的 vt. 使谦恭; 轻松打败(尤指强大的对手); 低声下气","text":"2018-08-08-p18 notion [‘nəʊʃ(ə)n] n. 概念; 见解; 打算 humble [‘hʌmbl] adj. 谦逊的; 简陋的; (级别或地位)低下的; 不大的 vt. 使谦恭; 轻松打败(尤指强大的对手); 低声下气 majestic [mə’dʒestɪk] adj. 庄严的; 宏伟的 pull up 拔起; 停下来; 阻止 flutter [‘flʌtə]vi. 飘动; 鼓翼; 烦扰 vt. 拍; 使焦急; 使飘动 n. 摆动; 鼓翼; 烦扰 converge [kən’vɜːdʒ] vt. 使汇聚 vi. 聚集; 靠拢; 收敛 curb [kɜːb] n. 抑制; 路边; 勒马绳 vt. 控制; 勒住 somewhat [‘sʌmwɒt] n. 几分; 某物 adv. 有点; 多少; 几分; 稍微 porch [pɔːtʃ] n. 门廊; 走廊 hue [hjuː] n. 色彩; 色度; 色调; 叫声 confession [kən’feʃ(ə)n] n. 忏悔, 告解; 供认; 表白 2018-08-09-p19blast up streak [striːk] n. 条纹, 线条; 倾向 vi. 飞跑, 疾驶; 加上条纹 vt. 飞跑, 疾驰; 加条纹于 tow [təʊ] n. 拖; 麻的粗纤维; 拖曳所用之绳 vt. 拖; 牵引; 曳 vi. 被拖带; 拖行 n. (Tow)人名; (东南亚国家华语)道 trailer [‘treɪlə] n. 拖车; [电视]预告片; 追踪者 vi. 乘拖车式活动房屋旅行 vt. 用拖车载运 cherry [‘tʃerɪ] n. 樱桃; 樱桃树; 如樱桃的鲜红色; 处女膜, 处女 n. (Cherry)人名; (法, 阿拉伯)谢里; (英)彻丽(女子教名Charity的昵称) thermoses [‘θɜːmɒs] n. 热水瓶 glove [glʌv] n. 手套 vt. 给…戴手套 rope [rəʊp] n. 绳, 绳索 vt. 捆, 绑 vi. 拧成绳状 n. (Rope)人名; (英)罗普; (芬)罗佩 earmuff n. 御寒耳罩 saw [sɔː] vt. 看见; 明白, 了解; 锯; 锯成; 锯开 vi. 锯; 用锯; 将某物锯成小块 n. 锯子; 谚语 v. see的过去式 choke out 闭死 scowl [skaʊl] n. 愁容; 怒容; 阴沉沉的样子 vi. 皱眉; 怒视 vt. 皱眉表示; 对…沉下脸 turn from time to time 不时的 trespass [‘trespəs] vi. 侵入; 犯罪; 打扰; 冒犯 n. 罪过; 非法侵入; 过失; 擅自进入 obstruct [əb’strʌkt] vt. 妨碍; 阻塞; 遮断 vi. 阻塞; 设障碍 contracted [kən’træktɪd] adj. 契约的; 收缩了的; 狭小的 v. 使收缩; 订契约(contract的过去式和过去分词) legitimate [lɪ’dʒɪtɪmət] adj. 合法的; 正当的; 合理的; 正统的 vt. 使合法; 认为正当(等于legitimize) curb [kɜːb] n. 抑制; 路边; 勒马绳 vt. 控制; 勒住 fold [fəʊld] vt. 折叠; 合拢; 抱住; 笼罩 n. 折痕; 信徒; 羊栏 vi. 折叠起来; 彻底失败 blur [blɜː] vt. 涂污; 使…模糊不清; 使暗淡; 玷污 vi. 沾上污迹; 变模糊 n. 污迹; 模糊不清的事物 megaphone [‘megəfəʊn] n. 扩音器, 喇叭筒 vt. 用扩音器对…讲话 vi. 用扩音器传达 brigade [brɪ’geɪd] n. 旅; 大部队; 队列 vt. 把…编成旅; 把…编成队 2017-08-10-p20the sound of chain saws in the distance 远处的链锯声 put up a block wall 砌块墙 darn [dɑːn] v. 织补, 缝补 n. 织补 track down 追捕 plead [pliːd] vt. 借口; 为…辩护; 托称 vi. 恳求; 辩护 race up 向上跑.急剧上升 pickup [‘pɪkʌp] n. 收集, 整理; 小卡车; 拾起; 搭车者; 偶然结识者 n. (Pickup)人名; (英)皮卡普 function [‘fʌŋ(k)ʃ(ə)n] n. 功能;[数] 函数; 职责; 盛大的集会 vi. 运行; 活动; 行使职责 go up to 前往; 上到……上 sawdust [‘sɔːdʌst] n.[木] 锯屑 adj. 撒木屑的; 无实质的 vt. 在…上撒木屑; 用木屑填塞 bear [beə] vt. 结果实, 开花(正式) vt. 忍受; 承受; 具有; 支撑 n. 熊 n. (Bear)人名; (英)贝尔 way up adv. 远远在上 adj. 高级的, 优秀的 look off into the distance 向远处看 choke out 闭死 get held back 留级","categories":[{"name":"Notes","slug":"Notes","permalink":"https://didongdongdi.github.io/categories/Notes/"}],"tags":[{"name":"English","slug":"English","permalink":"https://didongdongdi.github.io/tags/English/"}],"author":"DiDong"},{"title":"shell笔记-1","slug":"shell笔记-1","date":"2020-03-19T10:23:05.000Z","updated":"2020-03-23T02:24:01.808Z","comments":true,"path":"2020/03/19/shell笔记-1/","link":"","permalink":"https://didongdongdi.github.io/2020/03/19/shell%E7%AC%94%E8%AE%B0-1/","excerpt":"参考自Linux命令行与shell脚本编程大全第三版 输出特殊字符 比如需要输出换行符时使用echo $&#39;\\n&#39;双引号是没用的, 只会输出普通字符串 UNIX哲学 参考https://yuguo.us/weblog/linux-philosophy/ shell哲学 参考https://www.cnblogs.com/youxia/p/linux010.html","text":"参考自Linux命令行与shell脚本编程大全第三版 输出特殊字符 比如需要输出换行符时使用echo $&#39;\\n&#39;双引号是没用的, 只会输出普通字符串 UNIX哲学 参考https://yuguo.us/weblog/linux-philosophy/ shell哲学 参考https://www.cnblogs.com/youxia/p/linux010.html continue 来自man复位到外层for, while, until, 或select循环的下一次开始. 如果指定了n, 复位到向外第n层循环的开始. n必须&gt;=1. 如果n比外部循环的层数要多, 将复位到最外层的循环(top-level loop, 顶层循环). 返回值是0, 除非执行continue时, shell不是在循环之中. 命令和语法总结 man -k terminal查找与关键字相关的命令 man 1 hostname显示该命令的手册的第几部分 文件扩展匹配使用(元字符)通配符进行过滤, 如* ? [] ! file my_file查看文件类型 tail -f my_log可用于实时监测系统日志 (pwd ; ls ; cd /etc ; pwd ; cd ; pwd ; ls)进程列表, 会生成子shell { pwd ; ls ; cd /etc ; pwd ; cd ; pwd ; ls } 或 pwd ; ls ; cd /etc ; pwd ; cd ; pwd ; ls不会生成子shell, 注意{ }前后有空格 coproc sleep 10 或 coproc my_job { sleep 10; }协程, 在后台生成一个子shell, 并在这个子shell中执行命令 type -a echo显示每个命令的两种实现(内建命令和外部命令) which pwd只显示外部命令文件外部命令, 也被称为文件系统命令, 是存在于bash shell之外的程序, 并不是shell程序的一部分通常位于/bin, /usr/bin, /sbin或/usr/sbin中执行外部命令时, 会创建出一个子进程(forking) !!执行刚刚执行过的命令 !20执行指定编号的命令 env 或 printenv查看全局变量 printenv HOME 或 echo $HOME查看指定的全局变量 set查看为某个特定进程设置的所有环境变量局部变量, 全局变量, 用户定义变量 my_var=hello 或 my_var=’hello world’ 或 my_var=”hello world”定义用户变量, 变量名用小写字母 export my_var导出局部变量 unset my_var删除环境变量注意, 在子shell中对全局变量的任何操作都无法影响父shell中的全局变量 my_arr=(one two three four five)数组 echo ${my_arr[2]}输出单个元素 echo ${my_arr[*]}输出整个数组 my_arr[2]=seven改变某个位置的值 unset my_arr[2]删除数组中的某个值, 但那个地方只会变成空, 其他地方的值不会变 unset my_arr删除整个数组 chpasswd &lt; users.txt为系统中的大量用户修改密码, 格式 userid:passwd chsh -s /bin/csh test修改默认的用户登录shell chfn test在/etc/passwd文件的备注字段中存储信息 chage test管理用户账户的有效期 groupadd shared创建新组 usermod -G shared test添加用户到组 groupmod -n sharing shared修改组名, -g 选项可以修改GID fdisk /dev/sdb管理磁盘分区 mkfs.ext4 /dev/sdb1创建文件系统, 不同的文件系统的创建有不同的命令 mount -t ext4 /dev/sdb1 /mnt/my_partition挂载文件系统, -t 选项指定了文件系统 fsck -a /dev/sdb1 或 fsck -y /dev/sdb1自动修复文件系统, 文件系统可以通过设备名, 在虚拟目录中的挂载点以及分配给文件系统的唯一UUID来引用 fdisk通过t命令定义分区类型8e分区类型8e代表这个分区将会被用作Linux LVM系统的一部分 pvcreate /dev/sdb1简单地将分区标记成Linux LVM系统中的分区, 即创建实际的物理卷 pvdisplay /dev/sdb1显示已创建的物理卷列表, 可查看创建进度 vgcreate voll /dev/sdb1创建卷组, 同时指定卷组名 vgdisplay voll查看新创建的卷组的细节 lvcreate -l 100%FREE -n lvtest voll创建逻辑卷 lvdisplay voll查看创建的逻辑卷的详细情况 mkfs.ext4 /dev/voll/lvtest创建文件系统 mount /dev/voll/lvtest /mnt/my_partition挂载文件系统 vgchange激活和禁用卷组 vgremove删除卷组 vgextend将物理卷加入到卷组中 vgreduce从卷组中删除物理卷 lvextend增加逻辑卷的大小 lvreduce减小逻辑卷的大小 ./configure检查Linux系统, 确保有适合的编译器能够编译源代码, 另外还要具备正确的库依赖关系 make构建各种二进制文件 make install将软件安装到Linux系统上常用的位置上 readlink -f /usr/bin/vi找出链接文件的最后一环 testing=$(date) 或 testing=`date`命令替换, 会创建一个子shell来运行对应的命令, 由该子shell所执行的命令无法使用脚本中所创建的变量 12345wc &lt;&lt; EOFtest string 1test string 2test string 3EOF 内联输入重定向符 expr 5 \\* 2expr执行数学运算, 有些特殊的符号需要转义 var=$[5*2]方括号执行数学运算, bash shell只支持整数运算 var=$(echo “scale=4; 3.44 / 5” | bc) 或 1234567var=$(bc &lt;&lt; EOFscale = 4a1 = $var1 * $var2b1 = $var3 * $var4a1 + b1EOF) 实现对浮点数的计算 echo $?输出上一个已执行命令的退出状态码 exit 5退出的同时返回退出状态码 123456789if command1then command set 1elif command2then command set 2else command set 3fi if-then, elif-then, else, fielif-then和else都是可选的if或elif后面的command退出状态码是0(成功运行), then后面的command set才会执行 test condition 或 [ condition ]测试条件表达式, 用在判断关键字后面, 注意[ ]前后有空格数值比较使用-eq -ge -gt -le -lt -ne字符串比较使用= != &lt; &gt; -n -z, &lt;和&gt;必须转义test命令中使用标准的ASCII顺序, 根据每个字符的ASCII数值来决定排序结果; sort命令使用系统本地化语言设置中定义的排序顺序, 对于英语, 本地化设置指定了在排序顺序中小写字母出现在大写字母前文件比较使用-d -e -f -r -s -w -x -O -G -nt -ot复合条件测试使用&amp;&amp;和|| ((expression)) 或 ((val2=$val1**2))允许在比较过程中使用高级数学表达式, test命令只能在比较中使用简单的算术操作, 双括号命令提供了更多的数学符号其他运算符: val++ val-- ++val --val ! ~ ** &lt;&lt; &gt;&gt; &amp; | &amp;&amp; ||可以在脚本中的普通命令里使用来赋值 [[ $USER == r* ]]双方括号和test命令差不多, 但提供了模式匹配的特性不是所有的shell都支持双方括号, bash shell支持 1234567891011case $USER inrich | barbara) echo \"Welcome, $USER\" echo \"Please enjoy your visit\";;testing) echo \"Special testing account\";;jessica) echo \"Do not forget to log off when you're done\";;*) echo \"Sorry, you are not allowed here\";;esac case命令 12345678910for file in /home/rich/test/*do if [ -d \"$file\" ] then echo \"$file is a directory\" elif [ -f \"$file\" ] then echo \"$file is a file\" fidone for-in结构可以用通配符读取目录, 强制shell使用文件扩展匹配防止目录名和文件名中包含空格, 将$file变量用双引号圈起来 IFS=$’\\n’:;”内部字段分隔符, 最好先将原来的IFS的值记录 1234for ((a=1,b=10;a&lt;=10;a++,b--))do echo \"$a - $b\"done C语言风格的for结构 12345678var1=10while echo $var1 [ $var1 -ge 0 ]do echo \"This is inside the loop\" var1=$[ $var1 - 1 ]done while结构, 可以使用多个测试命令, 但只有最后一个测试命令的退出状态码会被用来决定什么时候结束循环 12345678var1=100until echo $var1 [ $var1 -eq 0 ]do echo Inside the loop: $var1 var1=$[ $var1 - 25 ]done until结构, 直到最后一个命令成立时停止 break 2跳出循环, 可以指定跳出的层数, 默认为1 continue 2复位到下一次循环, 可以指定回到第几层, 默认为1 12echo $2echo $&#123;10&#125; 命令行参数 1name=$(basename $0) 获取不包含路径的脚本名 echo $#命令行参数个数 1echo $&#123;!#&#125; 最后一个命令行参数变量 1234for param in \"$*\"do commandsdone $*会将所有参数当成单个参数 1234for param in \"$@\"do commandsdone $@会单独处理每个参数 shift 2向左移动命令行参数, 可以指定移动的位置数, 默认为1, 移动过程中$0不会变","categories":[{"name":"Notes","slug":"Notes","permalink":"https://didongdongdi.github.io/categories/Notes/"}],"tags":[{"name":"Shell","slug":"Shell","permalink":"https://didongdongdi.github.io/tags/Shell/"}],"author":"DiDong"},{"title":"华硕路由器AC66U配置","slug":"华硕路由器AC66U配置","date":"2020-03-08T17:21:34.000Z","updated":"2020-03-09T04:38:25.381Z","comments":true,"path":"2020/03/09/华硕路由器AC66U配置/","link":"","permalink":"https://didongdongdi.github.io/2020/03/09/%E5%8D%8E%E7%A1%95%E8%B7%AF%E7%94%B1%E5%99%A8AC66U%E9%85%8D%E7%BD%AE/","excerpt":"从咸鱼买了AC66U用来替换家里原来的TP(只有2.4G的WIFI, 而且性能也不太行了, 还不能刷固件), 然后原来的TP用来做无线扩展(WDS).","text":"从咸鱼买了AC66U用来替换家里原来的TP(只有2.4G的WIFI, 而且性能也不太行了, 还不能刷固件), 然后原来的TP用来做无线扩展(WDS). 卖家已经给刷了梅林, 配置和大多数的路由器相同, 但要注意的一点是, 由于运营商(我的是湖南有线)那边已经绑定了路由器的MAC地址, 所以拨号之前必须把路由器的地址设成和原来的路由器一样, 不然就会一直拨号账号密码错误, 也因为绑定了, 所以双拨也是不可能的了. 然后, 在通过ssh登录到路由器后(需要先开启ssh(LAN only)), 参考https://www.zcq100.com/install-entware-on-arm-device/可以安装entware(包管理器), 这样就能方便安装其他软件了. 注意原文章的最后的命令少了一个t.","categories":[{"name":"教程","slug":"教程","permalink":"https://didongdongdi.github.io/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://didongdongdi.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"路由器","slug":"路由器","permalink":"https://didongdongdi.github.io/tags/%E8%B7%AF%E7%94%B1%E5%99%A8/"}],"author":"DiDong"},{"title":"在线ps使用记录","slug":"在线ps使用记录","date":"2020-03-04T04:53:29.000Z","updated":"2020-03-04T04:53:56.329Z","comments":true,"path":"2020/03/04/在线ps使用记录/","link":"","permalink":"https://didongdongdi.github.io/2020/03/04/%E5%9C%A8%E7%BA%BFps%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/","excerpt":"","text":"抠图: 磁性索套 查找边缘 ok 删除图层 保存成png","categories":[{"name":"教程","slug":"教程","permalink":"https://didongdongdi.github.io/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"PS","slug":"PS","permalink":"https://didongdongdi.github.io/tags/PS/"}],"author":"DiDong"},{"title":"牛客网刷题笔记(C/C++)篇","slug":"牛客网刷题笔记-C-C-篇","date":"2020-02-07T11:30:00.000Z","updated":"2020-03-22T06:55:22.389Z","comments":true,"path":"2020/02/07/牛客网刷题笔记-C-C-篇/","link":"","permalink":"https://didongdongdi.github.io/2020/02/07/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-C-C-%E7%AF%87/","excerpt":"以下是在牛客网上刷C/C++专项练习时的知识点记录: ASCII码对照表 ‘0’十进制是48 ‘A’十进制是65 ‘a’十进制是97 一个派生类继承了所有的基类方法, 但下列情况除外:(参考自https://www.runoob.com/cplusplus/cpp-inheritance.html) 基类的构造函数, 析构函数和拷贝构造函数 基类的重载运算符 基类的友元函数","text":"以下是在牛客网上刷C/C++专项练习时的知识点记录: ASCII码对照表 ‘0’十进制是48 ‘A’十进制是65 ‘a’十进制是97 一个派生类继承了所有的基类方法, 但下列情况除外:(参考自https://www.runoob.com/cplusplus/cpp-inheritance.html) 基类的构造函数, 析构函数和拷贝构造函数 基类的重载运算符 基类的友元函数 虚拟继承: 1234class D&#123;......&#125;;class B: public D&#123;......&#125;;class A: public D&#123;......&#125;;class C: public B, public A&#123;.....&#125;; 这个继承会使D创建两个对象, 要解决上面的问题就要使用虚拟继承 1234class D&#123;......&#125;;class B: virtual public D&#123;......&#125;;class A: virtual public D&#123;......&#125;;class C: public B, public A&#123;.....&#125;; 虚继承:(在创建对象的时候会创建一个虚表)在创建父类对象的时候 拷贝构造函数:(参考自https://blog.csdn.net/lwbeyond/article/details/6202256)拷贝构造函数是一种特殊的构造函数, 与普通构造函数的区别为, 它必须的一个参数是本类型的一个引用变量 调用拷贝构造函数的时机: 对象以值传递的方式传入函数参数 对象以值传递的方式从函数返回(函数执行到最后析构局部变量, 执行完析构返回的临时变量) 对象需要通过另外一个对象进行初始化 浅拷贝和深拷贝 默认拷贝构造函数默认拷贝构造函数没有处理静态数据成员 浅拷贝默认拷贝构造函数就是浅拷贝, 浅拷贝对于动态分配的内容没有进行正确的操作, 即拷贝时只确保两个指针的值相等, 但是空间并没有复制 深拷贝深拷贝对于对象中的动态成员重新动态分配空间 防止默认拷贝发生的方法:声明一个私有拷贝构造函数, 不用定义, 当用户试图按值传递或函数返回该类对象, 将得到一个编译错误, 从而可以避免按值传递或返回对象. 拷贝构造函数的几个问题: 拷贝构造函数类同于构造函数, 能调用private成员变量 对于一个类X, 如果一个构造函数的第一个参数是下列之一, 且没有其他参数或其他参数都有默认值, 那么这个函数是拷贝构造函数 X &amp; const X &amp; volatile X &amp; const volatile &amp; 类中可以存在超过一个拷贝构造函数; 如果一个类中只存在一个参数为X &amp;的拷贝构造函数, 那么就不能使用const X或volatile X的对象实行拷贝初始化; 默认拷贝构造函数的参数可能为X::X(const X &amp;)或X::X(X &amp;), 由编译器根据上下文决定选择哪一个 重载运算符:(参考自https://www.runoob.com/cplusplus/cpp-overloading.html)重载的运算符是带有特殊名称的函数, 函数名是由关键字operator 和其后要重载的运算符符号构成与其他函数一样, 重载运算符有一个返回类型和一个参数列表 不可重载的运算符: . 成员访问运算符 .*, -&gt;* 成员指针访问运算符 :: 域运算符 ?: 条件运算符 # 预处理符号 类重载, 覆盖, 重定义之间的区别: 重载指的是函数具有的不同的参数列表, 而函数名相同的函数; 重载要求参数列表必须不同, 比如参数的类型不同, 参数的个数不同, 参数的顺序不同; 如果仅仅是函数的返回值不同是没办法重载的, 因为重载要求参数列表必须不同(发生在同一个类里) 覆盖是存在类中, 子类重写从基类继承过来的函数; 被重写的函数不能是static的; 必须是virtual的; 但是函数名, 返回值, 参数列表都必须和基类相同(发生在基类和子类) 重定义也叫做隐藏, 子类重新定义父类中有相同名称的非虚函数(参数列表可以不同)(发生在基类和子类) 友元函数:(参考自https://blog.csdn.net/qq_26337701/article/details/53996104)友元函数是定义在类外的普通函数, 只是在类中声明该函数可以访问类中的private或者protected成员友元函数声明的一般形式: friend &lt;返回类型&gt; &lt;函数名&gt; (&lt;参数列表&gt;);注意: 由于该函数并不是类的成员函数, 其声明可以放在类的私有部分, 也可放在共有部分 一个类中的成员函数可以是另外一个类的友元函数, 而且一个函数可以是多个类的友元函数 友元函数访问类中的私有成员和其他数据需要通过对对象进行引用 友元函数在调用上同一般函数一样, 不必通过对对象进行引用 友元类:(参考自https://www.cnblogs.com/zhuguanhao/p/6286145.html)友元类的所有成员函数都是另一个类的友元函数友元类声明的一般形式: friend class &lt;类名&gt;;注意: 友元关系不能被继承 友元关系是单向的, 不具有交换性 友元关系不具有传递性 关于友元: 通常将友元声明成组地放在类定义的开始或结尾 不必预先声明类和非成员函数来将它们设为友元 优点: 可以灵活地实现需要访问若干类的私有或受保护的成员才能完成的任务 便于与其他不支持类概念的语言(如C语言, 汇编等)进行混合编程 通过使用友元函数重载可以更自然地使用C++语言的IO流库 缺点: 一个类将对其非公有成员的访问权限授予其他函数或者类, 会破坏该类的封装性, 降低该类的可靠性和可维护性 volatile:(参考自https://www.cnblogs.com/yc_sunniwell/archive/2010/07/14/1777432.html)遇到volatile关键字声明的变量, 编译器对访问该变量的代码不再进行优化, 从而可以提供对特殊地址的稳定访问volatile指出变量的值是随时可能发生变化的, 当要求使用volatile声明的变量的值的时候, 系统总是重新从它的所在的内存读取数据, 即使它前面的指令刚刚从该处读取过数据, 而且读取的数据立刻被保存 volatile的使用: 中断服务程序中修改的供其它程序检测的变量需要加volatile 多任务环境下个任务间共享的标志应该加volatile 存储器映射的硬件寄存器通常也要加volatile说明, 因为每次对它的读写都可能有不同的意义 内嵌汇编操纵栈(编译无法识别的变量改变) volatile指针: 修饰由指针指向的对象, 数据是const或volatile的: 12const char* cpch;volatile char* vpch; 指针自身的值(一个代表地址的整数变量)是const或volatile的: 12char* const cpch;char* volatile vpch; volatile注意: 可以把一个非volatile int赋给volatile int, 但是不能把非volatile 对象赋给volatile 对象 C++中一个有volatile标识符的类只能访问它接口的子集, 一个由类的实现者控制的子集; 用户只能用const_cast来获得对类型接口的完全访问; 此外，volatile向const一样会从类传递到它的成员 const_cast:(参考自https://www.cnblogs.com/ider/archive/2011/07/22/cpp_cast_operator_part2.html)C++提供了四个转换运算符用于进行指针和引用的转换: const_cast &lt;new_type&gt; (expression) static_cast &lt;new_type&gt; (expression) reinterpret_cast &lt;new_type&gt; (expression) dynamic_cast &lt;new_type&gt; (expression) 一般可以将这四个标准转换运算符看作对传统转换的统一, 但编译器会做更多的处理, 特别是dynamic_cast不能用传统转换方式来完全实现 const_cast转换符是用来移除变量的const或volatile限定符 12345# 以下的代码并不会更改constant的内容, 尽管 &amp;constant 和 modifier 指向了同一个地址const int constant = 21;const int* const_p = &amp;constant;int* modifier = const_cast&lt;int*&gt;(const_p);*modifier = 7; C++对于指针的转换是任意的, 它不会检查类型, 任何指针之间都可以进行相互转换 C++运算符重载之类型转换运算符:(参考自https://blog.csdn.net/small_prince_/article/details/80518982) 转换构造函数(特殊的构造函数, 属于隐式转换): 有且仅有一个参数 参数是基本类型 参数是其他类型 可以普通类型到自定义类, 类到类 如何阻止编译器隐式类型转换?C++提供了explicit关键字杜绝编译器的转换尝试, 转换构造函数被explicit修饰时只能进行显示转换 使用类型转换函数operate Type();(Type是要转换成的类型, 属于显示转换): 类型转换函数与转换构造函数具有同等的地位 使得编译器有能力将对象转化为其他类型 编译器能够隐式地使用类型转换函数 可以自定义类到普通类型, 类到类","categories":[{"name":"工作","slug":"工作","permalink":"https://didongdongdi.github.io/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"工作","slug":"工作","permalink":"https://didongdongdi.github.io/tags/%E5%B7%A5%E4%BD%9C/"},{"name":"C/C++","slug":"C-C","permalink":"https://didongdongdi.github.io/tags/C-C/"},{"name":"牛客网","slug":"牛客网","permalink":"https://didongdongdi.github.io/tags/%E7%89%9B%E5%AE%A2%E7%BD%91/"}],"author":"DiDong"},{"title":"Next(Hexo)主题更新","slug":"Next-Hexo-主题更新","date":"2020-01-21T14:22:00.000Z","updated":"2020-01-22T01:45:26.477Z","comments":true,"path":"2020/01/21/Next-Hexo-主题更新/","link":"","permalink":"https://didongdongdi.github.io/2020/01/21/Next-Hexo-%E4%B8%BB%E9%A2%98%E6%9B%B4%E6%96%B0/","excerpt":"更新Next主题git pull直接更新主题, 但是_config.yml中往往会有冲突产生, 所以需要仔细修改. 更新hexo及相关插件主题仓库重新拉取后, hexo clean清除生成的网页文件, hexo g再次生成时出现错误.","text":"更新Next主题git pull直接更新主题, 但是_config.yml中往往会有冲突产生, 所以需要仔细修改. 更新hexo及相关插件主题仓库重新拉取后, hexo clean清除生成的网页文件, hexo g再次生成时出现错误. 怀疑是hexo的版本太低, 根据https://whjkm.github.io/2018/07/17/Hexo%E7%89%88%E6%9C%AC%E5%8D%87%E7%BA%A7%E5%92%8CNext%E4%B8%BB%E9%A2%98%E5%8D%87%E7%BA%A7%E4%B9%8B%E5%9D%91/升级hexo, 参考其升级hexo版本的部分即可. 但是后面发现仍然出现错误, 而后升级node.js解决. 升级node.js的方法见https://github.com/nodesource/distributions#debinstall, 根据对应的版本执行对应的命令.","categories":[{"name":"Blog","slug":"Blog","permalink":"https://didongdongdi.github.io/categories/Blog/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://didongdongdi.github.io/tags/%E6%95%99%E7%A8%8B/"}],"author":"DiDong"},{"title":"Linux下STM32开发","slug":"Linux下STM32开发","date":"2019-12-07T04:25:00.000Z","updated":"2019-12-08T03:37:40.552Z","comments":true,"path":"2019/12/07/Linux下STM32开发/","link":"","permalink":"https://didongdongdi.github.io/2019/12/07/Linux%E4%B8%8BSTM32%E5%BC%80%E5%8F%91/","excerpt":"参考自http://panqiincs.me/2019/07/26/develop-stm32-on-linux/ 由于我是在Deepin下进行配置的, 所以和原教程有所差别 同时采用的编辑器是vim, 而不是VSC","text":"参考自http://panqiincs.me/2019/07/26/develop-stm32-on-linux/ 由于我是在Deepin下进行配置的, 所以和原教程有所差别 同时采用的编辑器是vim, 而不是VSC GNU Toolchain由于原教程的系统为Manjaro Linux, 使用pacman安装工具链, 但我在apt下找不到该工具链, 只好到官网下载 一共有三个包需要下载: gcc-arm-none-eabi-9-2019-q4-major-x86_64-linux.tar.bz2 git://sourceware.org/git/binutils-gdb.git git://sourceware.org/git/newlib-cygwin.git后两个需要使用git clone 第一个包, 将其解压到自己想要目录下就好了然后设定环境变量在~/.bashrc中加入: 1export PATH=$PATH:/home/didong/gcc-arm-none-eabi-9-2019-q4-major/bin 注意将其中的/home/didong换成你的路径 第二个和第三个库直接分别在库的根目录下执行: 123./configuremakemake install 我安装的时候, 中途有碰到过ERROR, 但是根据错误提示去做就好了, 但一定要确保最后没有ERROR STM32CubeMX这里的安装和工程代码生成基本同原教程一样, 但要注意安装的时候不仅仅需要.linux文件, .exe文件也需要 VIM原教程采用的是VSCode, 配置起来应该会比较简单 但习惯了vim, 还是用vim吧 最主要的问题是代码的补全, 我一直使用的是Youcompleteme来进行补全, 所以这里说一下YCM的配置, YCM的安装和基础配置可以参考YouCompleteMe 安装配置使用(写得比较简略, 主要是参考别人的) 打开.ycm_extra_conf.py文件在flags数组中加入 12345678910111213141516171819202122'-DUSE_HAL_DRIVER','-DSTM32F103xB','-I','Inc','-I','Drivers/STM32F1xx_HAL_Driver/Inc','-I','Drivers/STM32F1xx_HAL_Driver/Inc/Legacy','-I','Drivers/CMSIS/Device/ST/STM32F1xx/Include','-I','Drivers/CMSIS/Include','-isystem','/home/didong/gcc-arm-none-eabi-9-2019-q4-major/arm-none-eabi/include''-isystem','/home/didong/gcc-arm-none-eabi-9-2019-q4-major/arm-none-eabi/include/c++/9.2.1','-isystem','/home/didong/gcc-arm-none-eabi-9-2019-q4-major/arm-none-eabi/include/c++/9.2.1/backward','-isystem','/home/didong/gcc-arm-none-eabi-9-2019-q4-major/lib/gcc/arm-none-eabi/9.2.1/include''-isystem','/home/didong/gcc-arm-none-eabi-9-2019-q4-major/lib/gcc/arm-none-eabi/9.2.1/include-fixed' 注意:上面代码的1, 2行其实就是原教程中的C_DEFS后面的是C_INCLUDES要把路径换成自己的 每次生成工程后, 需要在工程根目录下执行: 12cp &#123;你的.ycm_extra_conf.py文件的路径&#125; .ctags -R 最后, make就可以了, 会生成build/目录, 同时该目录下会有一个.bin文件 事实上, 这一部分完全可以使用VSCode, 或者其他工具, 比如STM32CubeIDE(其中集成了STM32CubeMX), 关于STM32Cube生态系统可以看https://www.st.com/content/st_com/zh/stm32cube-ecosystem.html#DataTables_Table_0 STM32CubeProgrammer 原教程使用的是stm32flash, 我这里使用的是STM32CubeProgrammer, 一种编程工具它通过多种多样可用的通信媒介(JTAG、SWD、UART、USB DFU、I2C、SPI、CAN等)为读取、写入和验证设备和外部存储器等操作提供简单易用且高效的环境参考https://www.st.com/en/development-tools/stm32cubeprog.html 简而言之, 就是多种工具的集合, 这比单一的工具要方便多了 安装过程同STM32CubeMX 注意几点:使用UART时, 要注意跳线, 同时还要reset后再connect(不同的板子可能不同, 我这里是STM32F103C8T6)使用ST-Link, 需要升级固件, 当出现st-link is not in the dfu mode. please restart it.提示时, 不要关闭窗口, 将ST-Link拔下再插上, 然后就可以了使用ST-Link时, 每次下载完程序后, 都需要再次拔下然后插上, 然后connect 串口调试助手使用arduino的串口调试助手 网络调试助手使用http://blog.chinaunix.net/uid-21977056-id-4310527.html","categories":[{"name":"Linux","slug":"Linux","permalink":"https://didongdongdi.github.io/categories/Linux/"}],"tags":[{"name":"STM32","slug":"STM32","permalink":"https://didongdongdi.github.io/tags/STM32/"}],"author":"DiDong"},{"title":"犬种识别代码","slug":"犬种识别代码","date":"2019-12-07T04:21:00.000Z","updated":"2019-12-08T02:58:19.227Z","comments":true,"path":"2019/12/07/犬种识别代码/","link":"","permalink":"https://didongdongdi.github.io/2019/12/07/%E7%8A%AC%E7%A7%8D%E8%AF%86%E5%88%AB%E4%BB%A3%E7%A0%81/","excerpt":"模型训练","text":"模型训练 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178from google.colab import drivedrive.mount('/content/drive')# 接受截断的图片from PIL import ImageFileImageFile.LOAD_TRUNCATED_IMAGES = Trueimport osfrom keras.preprocessing.image import ImageDataGenerator# 数据集路径base_dir = '/content/drive/My Drive/MachineLearning/dogImages'train_dir = os.path.join(base_dir, 'train')valid_dir = os.path.join(base_dir, 'valid')test_dir = os.path.join(base_dir, 'test')# 使用图像生成器# 使用归一化 和 图像增强# 验证集不应该使用图像增强train_datagen = ImageDataGenerator( rescale=1./255, rotation_range=40, width_shift_range=0.2, height_shift_range=0.2, shear_range=0.2, zoom_range=0.2, horizontal_flip=True, vertical_flip=True, fill_mode='nearest')valid_datagen = ImageDataGenerator(rescale=1./255)# 加载数据集train_generator = train_datagen.flow_from_directory( train_dir, target_size=(512, 512), batch_size=32, class_mode='categorical')valid_generator = valid_datagen.flow_from_directory( valid_dir, target_size=(512, 512), batch_size=32, class_mode='categorical')import matplotlib.pyplot as pltfrom PIL import ImageImage.MAX_IMAGE_PIXELS = 1000000000%matplotlib inlineprint('训练集部分原始图像:')display(Image.open(os.path.join(train_dir, '039.Bull_terrier/Bull_terrier_02752.jpg')))print('训练集部分数据(图像)增强后的图像:')img = train_generator[0][0]fig = plt.figure(figsize=(40,4))for i in range(0, 12): ax = fig.add_subplot(1, 12, i+1) ax.imshow(img[i])plt.savefig('/content/drive/My Drive/MachineLearning/augmentation.png')plt.show()plt.close()from keras.applications.inception_v3 import InceptionV3from keras.models import Modelfrom keras.layers import Dense# 构建不带分类器的预训练模型base_model = InceptionV3( weights='imagenet', include_top=False, input_shape=(512, 512, 3), pooling='avg')x = base_model.output# 添加一个全连接层x = Dense(1024, activation='relu')(x)# 添加一个分类器predictions = Dense(133, activation='softmax')(x)# 构建需要训练的完整模型model = Model(inputs=base_model.input, outputs=predictions)# 锁住InceptionV3的卷积层# for layer in base_model.layers:# layer.trainable = False # 编译模型# model.compile(optimizer='rmsprop', loss='categorical_crossentropy', metrics=['accuracy'])# 现在顶层训练好了，开始微调 Inception V3 的卷积层。# 锁住底下的几层，然后训练其余的顶层。# 每一层的名字和层号，决定应该锁多少层呢：for i, layer in enumerate(base_model.layers): print(i, layer.name)# 选择训练最上面的两个 Inception block# 即锁住前面249层，然后放开之后的层。for layer in model.layers[:249]: layer.trainable = Falsefor layer in model.layers[249:]: layer.trainable = True# 重新编译模型，使上面的修改生效# 设置一个很低的学习率，使用 SGD 来微调from keras.optimizers import SGDmodel.compile(optimizer=SGD(lr=0.0001, momentum=0.9), loss='categorical_crossentropy', metrics=['accuracy'])# 查看模型结构model.summary()from keras.utils import plot_modelfrom PIL import Image# 生成网络结构的png图像plot_model(model, to_file='model.png', show_shapes=True, show_layer_names=True)# 显示png图像display(Image.open('model.png'))from keras.callbacks import ModelCheckpoint# 加载之前训练好的权重model.load_weights('/content/drive/My Drive/MachineLearning/dogImages.augmentation.model.weights.best.1.hdf5')checkpointer = ModelCheckpoint( filepath='/content/drive/My Drive/MachineLearning/dogImages.augmentation.model.weights.best.1.hdf5', verbose=1, save_best_only=True)history = model.fit_generator( generator=train_generator, epochs=10, validation_data=valid_generator, callbacks=[checkpointer], verbose=1, steps_per_epoch=210, validation_steps=50)import matplotlib.pyplot as plt# 绘制训练 &amp; 验证的准确率值plt.plot(history.history['acc'])plt.plot(history.history['val_acc'])plt.title('Model accuracy')plt.ylabel('Accuracy')plt.xlabel('Epoch')plt.legend(['Train', 'Val'], loc='upper left')plt.savefig('/content/drive/My Drive/MachineLearning/acc_2.png')plt.show()plt.close()# 绘制训练 &amp; 验证的损失值plt.plot(history.history['loss'])plt.plot(history.history['val_loss'])plt.title('Model loss')plt.ylabel('Loss')plt.xlabel('Epoch')plt.legend(['Train', 'Val'], loc='upper left')plt.savefig('/content/drive/My Drive/MachineLearning/loss_2.png')plt.show()plt.close()# 加载最佳模型model.load_weights('/content/drive/My Drive/MachineLearning/dogImages.augmentation.model.weights.best.1.hdf5')# 归一化 &amp; 加载测试集test_datagen = ImageDataGenerator(rescale=1./255)test_generator = test_datagen.flow_from_directory( test_dir, target_size=(512, 512), batch_size=20, class_mode='categorical')# 训练集, 验证集, 测试集 loss 和 accuracytrain_loss, train_acc = model.evaluate_generator(train_generator)print('train_loss: ', train_loss)print('train_acc: ', train_acc)valid_loss, valid_acc = model.evaluate_generator(valid_generator)print('valid_loss: ', valid_loss)print('valid_acc: ', valid_acc)test_loss, test_acc = model.evaluate_generator(test_generator)print('test_loss: ', test_loss)print('test_acc: ', test_acc) 模型预测123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596from keras.models import load_modelimport osimport numpy as npfrom keras.preprocessing import imageimport matplotlib.pyplot as pltfrom PIL import ImageImage.MAX_IMAGE_PIXELS = 1000000000%matplotlib inlineprint('loading model ...')model = load_model('./dogImages.augmentation.model.weights.best.1.hdf5')samples_dir = './samples/'classes = sorted(os.listdir(samples_dir))pred_dir = './pred/'pred_files = sorted(os.listdir(pred_dir))img = []for i in range(len(pred_files)): print('loading no.%s image %s ...' % (i, pred_files[i])) images = image.load_img(pred_dir+pred_files[i], target_size=(512, 512)) x = image.img_to_array(images) x = x / 255. x = np.expand_dims(x, axis=0) img.append(x)# 把图片数组联合在一起x = np.concatenate([x for x in img])print('predicting ...')preds = model.predict(x)preds_class = preds.argmax(axis=-1)preds_percent = preds.max(axis=-1)for i in range(len(pred_files)): print('no.%s image %s ' % (i, pred_files[i])) display(Image.open(pred_dir+pred_files[i])) print('&#123;:.2f&#125;% belong to '.format(preds_percent[i]*100)) print('%s' % classes[preds_class[i]]) display(Image.open(samples_dir+classes[preds_class[i]]+'/0.jpg')) print()# 网络认为预测向量中最大激活的元素对应是\"Afghan_hound\"类别的元素, 索引编号1preds_class[0]# 应用Grad-CAM算法from keras import backend as Kdog_output = model.output[:, preds_class[0]]# 预测向量中的\"Afghan_hound\"元素last_conv_layer = model.get_layer('conv2d_94')# conv2d_94层的输出特征图，它是该模型的最后一个卷积层grads = K.gradients(dog_output, last_conv_layer.output)[0]# \"Afghan_hound\"类别相对于conv2d_94输出特征图的梯度pooled_grads = K.mean(grads, axis=(0, 1, 2))# 形状是（192， ）的向量，每个元素是特定特征图通道的梯度平均大小iterate = K.function([model.input], [pooled_grads, last_conv_layer.output[0]])# 这个函数允许我们获取刚刚定义量的值：对于给定样本图像，pooled_grads和conv2d_94层的输出特征图pooled_grads_value, conv_layer_output_value = iterate([x])# 给我们两个\"Afghan_hound\"样本图像，这两个量都是Numpy数组for i in range(192): conv_layer_output_value[:, :, i] *= pooled_grads_value[i]# 将特征图数组的每个通道乘以这个通道对\"Afghan_hound\"类别重要程度heatmap = np.mean(conv_layer_output_value, axis=-1)# 得到的特征图的逐通道的平均值即为类激活的热力图# 热力图后处理heatmap = np.maximum(heatmap, 0)# heatmap与0比较，取其大者heatmap /= np.max(heatmap)plt.matshow(heatmap)plt.show()plt.close()# 将热力图与原始图叠加, 实现可视化import cv2 img = cv2.imread(pred_dir+pred_files[0])# 用cv2加载原始图像 heatmap = cv2.resize(heatmap, (img.shape[1], img.shape[0]))# 将热力图的大小调整为与原始图像相同 heatmap = np.uint8(255 * heatmap)# 将热力图转换为RGB格式 heatmap = cv2.applyColorMap(heatmap, cv2.COLORMAP_JET)# 将热力图应用于原始图像 superimposed_img = heatmap * 0.4 + img# 这里的0.4是热力图强度因子 cv2.imwrite('./CAM/Afghan_hound_00081.cam.jpg', superimposed_img)# 将图像保存到硬盘display(Image.open('./CAM/Afghan_hound_00081.cam.jpg'))","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://didongdongdi.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://didongdongdi.github.io/tags/Python/"}],"author":"DiDong"},{"title":"水下机器人传感技术_1","slug":"水下机器人传感技术-1","date":"2019-11-02T14:37:00.000Z","updated":"2019-11-03T00:49:15.681Z","comments":true,"path":"2019/11/02/水下机器人传感技术-1/","link":"","permalink":"https://didongdongdi.github.io/2019/11/02/%E6%B0%B4%E4%B8%8B%E6%9C%BA%E5%99%A8%E4%BA%BA%E4%BC%A0%E6%84%9F%E6%8A%80%E6%9C%AF-1/","excerpt":"机器人行业介绍 现实中机器人的主要特点: 基于目前的科技与制造水平 外形各异, 大部分并不与人相像 与人交流的方式不局限于语言 为完成某一种特定的场景与工作目标而设计","text":"机器人行业介绍 现实中机器人的主要特点: 基于目前的科技与制造水平 外形各异, 大部分并不与人相像 与人交流的方式不局限于语言 为完成某一种特定的场景与工作目标而设计 水下机器人概述 发展水下机器人产业的意义: 21世纪的人类面临的三大问题: 人口, 环境, 资源 地球表面70.8%被蕴藏了丰富的生物, 矿物和能源的海洋覆盖; 走向海洋已经是人们的共识 水下机器人是开发海洋, 水资源保护, 水下建筑物建设的重要工具 个人通过潜水探索, 欣赏水下世界的活动成为热潮, 全球已有超过1.5亿持证潜水爱好者, 并每年高速增长; 水下机器人是潜水爱好者开展水下活动的重要工具 行业应用: 船舶检修 水下建筑物探伤 水下工程 防险救生 水产养殖 水质检查 水下摄影 教育 潜水 水下机器人所涵盖的技术专业领域: 电路 嵌入式处理器 多类型传感器 通信 视频 电源管理 算法 多自由度运动控制 模糊控制 鲁棒控制 自动避障碍 图像增强 机器视觉 机械结构 密封舱体 深水接插件 水下电机 特殊外形设计 用户界面 图形化界面APP 专业摇杆控制 云分享平台 仿生学在机器人的应用: 声呐, 滑翔, 自稳等 水下机器人应用: 水下搜救 海下石油开采 海底光缆 海上风电 海洋牧场 水下建筑物探伤 机器人传感介绍 机器人产品设计的分层体系结构:用户界面编程 -&gt; ROS中间层 -&gt; 机器人执行机构 设计一个电子系统的目的: 获得真实世界的物理量 将其转换成可用的电子信号 分析, 操纵, 存储, 传送这些电子信号 返回真实世界 压力传感器: 测量部分 压力差 位移 电容值 转换部分 电流 放大 温湿度传感器 霍尔传感器:霍尔器件通过检测磁场变化, 转变为电信号输出, 可用于监视和测量汽⻋各部件运行参数的变化例如位置, 位移, 角度, 角速度, 转速等等, 并可将这些变量进行二次变换; 可测量压力, 质量, 液位, 流速, 流量等霍尔器件输出量直接与电控单元接口, 可实现自动检测 陀螺仪效应角动量守恒 声呐传感器 超声波测距 PH值检测传感器 红外传感 机器人传感器类别: 二维视觉传感器 三维视觉传感器 力扭矩传感器 碰撞检测传感器 安全传感器 电磁传感器 光纤传感器 仿生传感器 红外传感器 压力传感器 姿态检测(陀螺仪)传感器","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://didongdongdi.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://didongdongdi.github.io/tags/Notes/"}],"author":"DiDong"},{"title":"机器人操作系统ROS_6_MoveIt!机械臂控制","slug":"机器人操作系统ROS-6-MoveIt-机械臂控制","date":"2019-10-27T06:54:00.000Z","updated":"2019-10-27T07:17:40.509Z","comments":true,"path":"2019/10/27/机器人操作系统ROS-6-MoveIt-机械臂控制/","link":"","permalink":"https://didongdongdi.github.io/2019/10/27/%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FROS-6-MoveIt-%E6%9C%BA%E6%A2%B0%E8%87%82%E6%8E%A7%E5%88%B6/","excerpt":"MoveIt!系统架构 MoveIt! 由ROS中一系列移动操作的功能包组成, 包含运动规划, 操作控制, 3D感知, 运动学, 碰撞检测等等, 而且提供友好的GUI 官方网站http://moveit.ros.org/, 上边有MoveIt!的教程和API说明","text":"MoveIt!系统架构 MoveIt! 由ROS中一系列移动操作的功能包组成, 包含运动规划, 操作控制, 3D感知, 运动学, 碰撞检测等等, 而且提供友好的GUI 官方网站http://moveit.ros.org/, 上边有MoveIt!的教程和API说明 MoveIt! 整体架构 move_group是MoveIt的核心部分, 可以综合机器人的各独立组件, 为用户提供一系列需要的动作指令和服务从架构图中我们可以看到, move_group类似于一个积分器, 本身并不具备丰富的功能,主要做各功能包、插件的集成它通过消息或服务的形式接收机器人上传的点云信息, joints的状态消息, 还有机器人的tf tree,另外还需要ROS的参数服务器提供机器人的运动学参数, 这些参数会在使用setup assistant的过程中根据机器人的URDF模型文件,创建生成(SRDF和配置文件) 官方说明网站http://moveit.ros.org/documentation/concepts/ MoveIt!使用方法 MoveIt! 配置初始化 运动规划 避障规划 pick and place","categories":[{"name":"ROS","slug":"ROS","permalink":"https://didongdongdi.github.io/categories/ROS/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://didongdongdi.github.io/tags/Notes/"}],"author":"DiDong"},{"title":"水下机器人视觉_9_补充","slug":"水下机器人视觉-9-补充","date":"2019-10-27T01:24:00.000Z","updated":"2019-10-27T06:33:33.458Z","comments":true,"path":"2019/10/27/水下机器人视觉-9-补充/","link":"","permalink":"https://didongdongdi.github.io/2019/10/27/%E6%B0%B4%E4%B8%8B%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%A7%86%E8%A7%89-9-%E8%A1%A5%E5%85%85/","excerpt":"最后一层的激活函数和误差函数 问题类型 最后一层的激活函数 误差函数 二分类 sigmoid binary_crossentropy 多分类 softmax categorical_crossentropy 回归到任意值 没有 mse 回归到0到1之间的值 sigmoid mse or binary_crossentropy","text":"最后一层的激活函数和误差函数 问题类型 最后一层的激活函数 误差函数 二分类 sigmoid binary_crossentropy 多分类 softmax categorical_crossentropy 回归到任意值 没有 mse 回归到0到1之间的值 sigmoid mse or binary_crossentropy $$ MSE = \\frac{1}{m}\\sum_{i=1}^{m}(y_i - \\hat{y}_i)^2 $$ 超参数 隐藏层数量 每层的隐藏单元数目 训练误差和泛化误差 训练误差: 出自于训练数据泛化误差: 出自于新数据 K折交叉验证 在没有足够的数据时非常有用 算法: 将训练数据划分为K个部分 对于i = 1, ... , K 每次使用第i部分作为验证集, 其余部分用于训练 报告平均K个验证错误 常见的K值选择: 5-10 VC维度 VC维度反映了函数集的学习能力, VC维度越大, 则学习机器越复杂(容量越大), 学习能力越强参考https://www.iteye.com/blog/xiaoxia001-1163338, https://blog.csdn.net/houlaizhexq/article/details/22957591 VC维度的效用 提供理论解释模型的工作原理 限制了训练误差和泛化误差之间的差距 在深度学习的实践中很少使用 难以计算深度神经网络的VC维数 边界过于宽松 其他统计学习理论工具也是如此 特征工程 特征描述, 例如SIFT(尺度不变特征变换), SURF(更高效的完成特征的提取和描述) 视觉词袋(聚类) 应用SVM(支持向量机) 1 X 1 卷积层 不识别空间模式, 而是融合通道 池化层 最大池化层: 每个窗口中最强的模式信号平均池化层: 每个窗口中的平均信号强度 重要的网络结构 LeNet (第一个卷积层, 1998) AlexNet (2012) 升华版的LeNet ReLu激活, 丢弃法, 图像增强 VGG (2014) 升华版的AlexNet 重复的VGG块 GoogLeNet (Inception, 2014) 卷积的不均匀混合(不同深度) 批量归一化 ResNet (残差网络, 2015) DenseNet (稠密连接网络, 2016) 网络架构 神经网络可以大致分为两部分: 特征提取器将原始像素映射为线性可分离的特征 用线性分类做决定 微调 (迁移学习) 神经网络学习分层特征表示: 低层特征是通用的 高层特征与数据集中的对象更相关 Inception块参考https://zhuanlan.zhihu.com/p/37505777 与单个3x3或5x5卷积层相比, 初始块具有更少的参数和更低的计算复杂度 不同功能混合(多样的功能类) 内存计算高效(良好的泛化) 残差网络 (ResNet)参考https://www.cnblogs.com/wuliytTaotao/p/9560205.html 稠密连接网络 (DenseNet)参考https://blog.csdn.net/u014380165/article/details/75142664","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://didongdongdi.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://didongdongdi.github.io/tags/Notes/"}],"author":"DiDong"},{"title":"LL(1)分析法中求first集合的Python实现","slug":"LL-1-分析法中求first集合的Python实现","date":"2019-10-26T07:38:00.000Z","updated":"2019-10-26T07:45:26.069Z","comments":true,"path":"2019/10/26/LL-1-分析法中求first集合的Python实现/","link":"","permalink":"https://didongdongdi.github.io/2019/10/26/LL-1-%E5%88%86%E6%9E%90%E6%B3%95%E4%B8%AD%E6%B1%82first%E9%9B%86%E5%90%88%E7%9A%84Python%E5%AE%9E%E7%8E%B0/","excerpt":"源程序","text":"源程序 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788def First(string, G): string_firstset &#x3D; set() i &#x3D; 0 while True: if i &gt;&#x3D; len(string): string_firstset.add(&#39;~&#39;) return string_firstset elif (string[i] &gt;&#x3D; &#39;a&#39; and string[i] &lt;&#x3D; &#39;z&#39;) or string[i] &#x3D;&#x3D; &#39;+&#39; or string[i] &#x3D;&#x3D; &#39;*&#39; or string[i] &#x3D;&#x3D; &#39;~&#39; or string[i] &#x3D;&#x3D; &#39;(&#39; or string[i] &#x3D;&#x3D; &#39;)&#39;: # 如果是终结符, 直接返回集合 string_firstset.add(string[i]) return string_firstset else: # 如果是非终结符 # 表示E if i+1 &lt; len(string) and string[i+1] &#x3D;&#x3D; &quot;&#39;&quot;: E &#x3D; string[i] + string[i+1] else: E &#x3D; string[i] # 找到E所在的那一行 line &#x3D; 0 while G[line][0] !&#x3D; E: line +&#x3D; 1 # 求E的first集合 E_firstset &#x3D; set() column &#x3D; 1 while G[line][column] !&#x3D; &#39;&#39;: E_firstset &#x3D; E_firstset.union(First(G[line][column], G)) column +&#x3D; 1 # ~是否在E的first集合中 if &#39;~&#39; in E_firstset: if len(E) &#x3D;&#x3D; 1: i +&#x3D; 1 else: i +&#x3D; 2 # string_firtsset集合增加 E_firstset.remove(&#39;~&#39;) string_firstset &#x3D; string_firstset.union(E_firstset) else: string_firstset &#x3D; string_firstset.union(E_firstset) return string_firstset# 文法的数据化结构G &#x3D; [[&#39;&#39;]*10 for i in range(10)]line &#x3D; 0# 打开放有文法的文件f &#x3D; open(&#39;G.txt&#39;, &#39;r&#39;)lines &#x3D; f.readlines()f.close()for g in lines: print(g, end&#x3D;&#39;&#39;) i &#x3D; 0 column &#x3D; 0 while True: while g[i].isspace() or g[i] &#x3D;&#x3D; &#39;-&#39; or g[i] &#x3D;&#x3D; &#39;&gt;&#39; or g[i] &#x3D;&#x3D; &#39;|&#39;: # 去掉空白和无关紧要的符号 i +&#x3D; 1 if i &gt;&#x3D; len(g): break if i&gt;&#x3D; len(g): break while g[i].isalpha() or g[i] &#x3D;&#x3D; &quot;&#39;&quot; or g[i] &#x3D;&#x3D; &#39;+&#39; or g[i] &#x3D;&#x3D; &#39;*&#39; or g[i] &#x3D;&#x3D;&#39;(&#39; or g[i] &#x3D;&#x3D; &#39;)&#39; or g[i] &#x3D;&#x3D; &#39;~&#39;: # 获取各字符串 G[line][column] +&#x3D; g[i] i +&#x3D; 1 if i &gt;&#x3D; len(g): break column +&#x3D; 1 if i&gt;&#x3D; len(g): break line +&#x3D; 1# for i in range(10): # 打印效果 # print(G[i])# 打印各非终结符的first集合print(&#39;First(C) &#x3D; &#39;, end &#x3D; &#39;&#39;)print(First(&#39;C&#39;, G))print(&quot;First(B&#39;) &#x3D; &quot;, end &#x3D; &#39;&#39;)print(First(&quot;B&#39;&quot;, G))print(&#39;First(B) &#x3D; &#39;, end &#x3D; &#39;&#39;)print(First(&#39;B&#39;, G))print(&#39;First(A) &#x3D; &#39;, end &#x3D; &#39;&#39;)print(First(&#39;A&#39;, G))print(&#39;First(S) &#x3D; &#39;, end &#x3D; &#39;&#39;)print(First(&#39;S&#39;, G)) G.txt放文法的文件其中~代表\\(\\varepsilon\\) 12345S -&gt; ABA -&gt; Ca | ~B -&gt; cB&#39;B&#39; -&gt; aACB&#39; | ~C -&gt; b | ~","categories":[{"name":"编译原理","slug":"编译原理","permalink":"https://didongdongdi.github.io/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://didongdongdi.github.io/tags/Python/"}],"author":"DiDong"},{"title":"linux下使用lex和yacc","slug":"linux下使用lex和yacc","date":"2019-10-22T01:46:00.000Z","updated":"2019-10-22T02:02:17.444Z","comments":true,"path":"2019/10/22/linux下使用lex和yacc/","link":"","permalink":"https://didongdongdi.github.io/2019/10/22/linux%E4%B8%8B%E4%BD%BF%E7%94%A8lex%E5%92%8Cyacc/","excerpt":"安装lex和yacc sudo apt-get install flex bison","text":"安装lex和yacc sudo apt-get install flex bison linux下使用lex和yacc 参考https://blog.csdn.net/ruglcc/article/details/7817619 其中, gcc编译选项-ll表示链接lex的库 更多gcc编译选项总结参考https://blog.csdn.net/gatieme/article/details/21389603#commentBox","categories":[{"name":"编译原理","slug":"编译原理","permalink":"https://didongdongdi.github.io/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://didongdongdi.github.io/tags/Notes/"}],"author":"DiDong"},{"title":"机器人操作系统ROS_5_机器人导航","slug":"机器人操作系统ROS-5-机器人导航","date":"2019-10-21T14:49:00.000Z","updated":"2019-10-27T06:49:34.090Z","comments":true,"path":"2019/10/21/机器人操作系统ROS-5-机器人导航/","link":"","permalink":"https://didongdongdi.github.io/2019/10/21/%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FROS-5-%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AF%BC%E8%88%AA/","excerpt":"机器人SLAM SLAM(simultaneous localization and mapping), 也称为CML(Concurrent Mapping and Localization), 即时定位与地图构建, 或并发建图与定位问题可以描述为:将一个机器人放入未知的环境中的未知位置, 是否有办法让机器人一边移动一边逐步描绘出此环境完全的地图(所谓完全的地图 – a consistent map: 是指不受障碍行进到房间可进入的每个角落)","text":"机器人SLAM SLAM(simultaneous localization and mapping), 也称为CML(Concurrent Mapping and Localization), 即时定位与地图构建, 或并发建图与定位问题可以描述为:将一个机器人放入未知的环境中的未知位置, 是否有办法让机器人一边移动一边逐步描绘出此环境完全的地图(所谓完全的地图 – a consistent map: 是指不受障碍行进到房间可进入的每个角落) ROS的二维导航功能包, 简单来说, 就是根据输入的里程计等传感器的信息流和机器人的全局位置, 通过导航算法, 计算得出安全可靠的机器人速度控制指令但是, 如何在特定的机器人上实现导航功能包的功能, 却是一件较为复杂的工程作为导航功能包使用的必要先决条件, 机器人必须运行ROS, 发布tf变换树, 并发布使用ROS消息类型的传感器数据同时, 为了让机器人更好的完成导航任务, 开发者还要根据机器人的外形尺寸和性能, 配置导航功能包的一些参数 机器人必要的配置: ROS: 确保机器人安装了ROS框架 tf变换(sensortransforms): 导航功能包要求机器人以tf树的形式发布各个相关参考系的变换关系 传感器信息(sensor sources): 导航功能包需要才起机器人的传感器信息, 以达到实时避障的效果 里程计信息(odometry sources): 导航功能包要求机器人发布nav_msgs/Odometry格式的里程计信息, 同时也要发布相应的tf变换 机器人控制器(base_controller): 导航功能包最终的输出是针对机器人geometry_msgs/Twist格式的控制指令 地图(map_server): (不必须) 准备工作 可以对机器人进行控制, 通过消息rosmsg show geometry_msgs/Twist 导航功能包要求机器人必须有激光雷达等测距设备 导航功能包以长方形或圆柱形机器人模板进行开发, 其他外形机器人可以正常使用但可能功能不佳 传感器信息 rosmsg show sensor_msgs/LaserScan 里程计信息 里程计根据传感器获取的数据来预估机器人随时间发生的位置变化 比如, 利用旋转编码器计算机器人运行的距离 rosmsg show nav_msgs/Odometry pose: 机器人当前位置坐标, 以及用于矫正误差的协方差矩阵 twist: 机器人三轴的线速度与角速度 仿真平台创建 运行gazebo Edit -&gt; Building Editor 可绘制仿真环境 gmapping ROS开源社区汇集了多种SLAM算法, 可以直接用于二次开发, 其中最为常用和成熟的是gmapping功能包 下载方法: sudo apt-get install ros-kinetic-gmapping 优点: Gmapping可以实时构建室内地图, 在构建小场景地图所需的计算量较小且精度较高 缺点: 随着场景增大所需的粒子增加, 因为每个粒子都会携带一幅地图, 因此在构建大地图时所需内存和计算量都会增加, 因此不适合构建大场景地图 地图构建 自主导航 导航框架:导航的关键是机器人定位和路径规划两大部分针对这两个核心, ROS提供了以下两个功能包 move_base 实现机器人导航中最优路径规划 amcl 实现二维地图中机器人的定位 安装导航框架:sudo apt-get install ros-kinect-navigation move_base是ROS中完成路径规划的功能包, 主要由以下两大规划器组成: 全局规划路径: 根据给定的位置和全局地图进行总体路径规划 本地实时规划: 实际情况中不可能完全按照全局路线进行运动, 针对障碍物, 地图信息, 碰撞, 综合评价标准选取最优路径 acml自主定位, 即机器人在任意状态下都可以推算出自己在地图中的位置同样需要了解amcl提供的话题, 服务与参数 amcl与里程计定位的区别: 里程计定位: 只是处理/base与/odom之间的TF变换 amcl定位: 可以估算机器人在地图坐标系/map下的位资信息, 提供/base, /odom, /map之间的TF变换","categories":[{"name":"ROS","slug":"ROS","permalink":"https://didongdongdi.github.io/categories/ROS/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://didongdongdi.github.io/tags/Notes/"}],"author":"DiDong"},{"title":"机器人操作系统ROS_4_机器人视觉","slug":"机器人操作系统ROS-4-机器人视觉","date":"2019-10-21T12:00:00.000Z","updated":"2019-10-27T07:18:15.966Z","comments":true,"path":"2019/10/21/机器人操作系统ROS-4-机器人视觉/","link":"","permalink":"https://didongdongdi.github.io/2019/10/21/%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FROS-4-%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%A7%86%E8%A7%89/","excerpt":"usb_cam功能包及ROS中的图像数据类型usb_cam功能包 usb_cam是针对V4L协议USB摄像头的ROS驱动包, 核心及诶但是usb_cam_node","text":"usb_cam功能包及ROS中的图像数据类型usb_cam功能包 usb_cam是针对V4L协议USB摄像头的ROS驱动包, 核心及诶但是usb_cam_node 下载:sudo apt-get install ros-kinetic-usb-cam运行:roslaunch usb_cam usb_cam-test.launch也可以运行:roscorerosrun usb_cam usb_cam_noderqt_image_view rqt是一个基于qt开发的可视化工具, 拥有可扩展性好, 灵活以用, 跨平台等特点, 主要作用和RViz一致都是可视化, 但是和RViz相比, rqt要高级一个层次 usb_cam中的节点, 话题和参数 ROS中的图像数据类型 查看二维图像rostopic info /usb_cam/image_rawrosmsg show sensor_msgs/Image ROS也设计了压缩图像消息类型(JEPG, PNG, BMP)rosmsg show sensor_msgs/CompressedImage 除了普通USB摄像头, 很多场景下会使用RGB-D摄像头来获取更丰富的环境细腻(Kinect, 微软XBOX360体感周边外设) 查看三维点云数据:rosmsg show sensor_msgs/PointCloud2 除此之外还有激光雷达:rosmsg show sensor_msgs/LaserScan 摄像头标定 摄像头这种精密仪器对光学器件的要求较高, 由于摄像头内部与外部的一些原因, 生成的图像往往会发生畸变为了避免误差, 需要针对摄像头的参数进行标定 ROSwiki相机矫正的官方文档 相机标定第一步, 准备一张标定板, 打印出来标定板为8x6, 我用A4纸打印出来为, 用直尺量square边长为24.5mm, 即0.0245m, 作为标定输入参数 roslaunch usb_cam usb_cam-test.launch运行摄像头 下载摄像头标定功能包camera_calibrationsudo apt-get install ros-kinect-camera-calibration 运行矫正窗口rosrun camera_calibration cameracalibrator.py –size 8x6 –square 0.0245 image:=/usb_cam/image_raw camera:=/usb_cam 采集样本数据没有标定成功前, 按钮均为灰色x: 左右移动y: 上下移动size: 前后移动skew: 倾斜转动不断移动标定靶, 到按钮变色CALIBRATE按钮: 计算标定参数SAVE: 保存到显示的默认路径COMMIT: 提交并退出程序 解压(tar xzf 标定生成的文件.tar.gz)得到yaml格式的配置文件 标定摄像头生成的配置文件是yaml格式的, 可以在启动摄像头的launch文件中进行加载 摄像头人脸与物体识别 ROS为开发者提供了OpenCV接口的功能包: cv_bridge开发者通过该功能包将ROS中的图像数据转成OpenCV格式的图像, 并调用OpenCV库进行各种图像处理或者将OpenCV处理后的数据转化成ROS图像, 并通过话题发布","categories":[{"name":"ROS","slug":"ROS","permalink":"https://didongdongdi.github.io/categories/ROS/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://didongdongdi.github.io/tags/Notes/"}],"author":"DiDong"},{"title":"机器人操作系统ROS_3_机器人建模与仿真","slug":"机器人操作系统ROS-3-机器人建模与仿真","date":"2019-10-21T08:09:00.000Z","updated":"2019-11-11T01:53:16.197Z","comments":true,"path":"2019/10/21/机器人操作系统ROS-3-机器人建模与仿真/","link":"","permalink":"https://didongdongdi.github.io/2019/10/21/%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FROS-3-%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%BB%BA%E6%A8%A1%E4%B8%8E%E4%BB%BF%E7%9C%9F/","excerpt":"机器人统一描述格式urdfurdf介绍 Unified Robot Description Format, 统一机器人描述(URDF)是种用于描述机器人机器结构, 关节, 自由度等的xml格式文件ROS中的urdf功能包包含一个URDF的C++解析器, URDF文件使用XML格式描述机器人模型 URDF语法规范见:http://wiki.ros.org/urdf/XML","text":"机器人统一描述格式urdfurdf介绍 Unified Robot Description Format, 统一机器人描述(URDF)是种用于描述机器人机器结构, 关节, 自由度等的xml格式文件ROS中的urdf功能包包含一个URDF的C++解析器, URDF文件使用XML格式描述机器人模型 URDF语法规范见:http://wiki.ros.org/urdf/XML urdf中机器人创建以树的格式 123456789101112131415161718192021&lt;robot name=\"test_robot\"&gt; &lt;link name=\"link1\" /&gt; &lt;link name=\"link2\" /&gt; &lt;link name=\"link3\" /&gt; &lt;link name=\"link4\" /&gt; &lt;joint name=\"joint1\" type=\"continuous\"&gt; &lt;parent link=\"link1\" /&gt; &lt;child link=\"link2\" /&gt; &lt;/joint&gt; &lt;joint name=\"joint2\" type=\"continuous\"&gt; &lt;parent link=\"link1\" /&gt; &lt;child link=\"link3\" /&gt; &lt;/joint&gt; &lt;joint name=\"joint3\" type=\"continuous\"&gt; &lt;parent link=\"link3\" /&gt; &lt;child link=\"link2\" /&gt; &lt;/joint&gt;&lt;/robot&gt; urdf文件编写常见标签 link标签 标签 功能 连接的可视化, 碰撞和惯性属性设置 设置连接的可视化属性 设置连接的碰撞计算属性 设置连接的惯性属性 输入模型的形状; 提供box, cylinder(圆柱), sphere(球体)等形态 设置相对于连接相对坐标系的移动和旋转 设置连接的颜色和纹理 连接重量(单位: kg)的设置 joint标签 标签 功能 与连接的关系和关节类型的设置 关节的父连接 关节的子连接 将父连接坐标系转换为子连接坐标系 设置旋转轴 设置关节的速度, 力和半径(仅当关节是revolutei(后旋的)或prismatic(棱柱)时) transmission标签 &lt;transmission&gt;是与ROS-CONTROL一起运行所必须的标签, 它输入关节与舵机之间的命令接口 标签 功能 设置关节和舵机之间的变量 设置力的传递方式的形状 设置关节信息设置 设置硬件接口 设置舵机信息 设置舵机与关节之间的齿轮比 物理属性与碰撞属性 如果想要在gazebo或者其他仿真软件上进行机器人仿真, 就需要添加物理属性和碰撞属性这意味着我们需要设定几何尺寸来计算可能的碰撞, 例如设定重量我们才能够计算惯性等需要保证模型文件中的所有连接都有这些参数, 否则就无法对这些机器人进行仿真要为所有连接添加collision和inertial属性, 因为如果不这样做, gazebo将无法使用这些模型 123456789101112&lt;link name=\"base_link\"&gt; ... &lt;collision&gt; &lt;geometry&gt; &lt;box size=\"0.2 .3 0.1\"/&gt; &lt;/geometry&gt; &lt;/collision&gt; &lt;inertial&gt; &lt;mass value=\"100\"/&gt; &lt;inertia ixx=\"1.0\" ixy=\"0.0\" ixz=\"0.0\" iyy=\"1.0\" iyz=\"0.0\" izz=\"1.0\"/&gt; &lt;/inertial&gt;&lt;/link&gt; 3D可视化与仿真1234567891011&lt;launch&gt; &lt;param name=\"robot_description\" textfile=\"$(find mrobot_description)/urdf/mrobot_chassis.urdf\" /&gt; &lt;!-- 设置GUI参数,显示关节控制插件 --&gt; &lt;param name=\"use_gui\" value=\"true\"/&gt; &lt;!-- 运行joint_state_publisher节点,发布机器人的关节状态 --&gt; &lt;node name=\"joint_state_publisher\" pkg=\"joint_state_publisher\" type=\"joint_state_publisher\" /&gt; &lt;!-- 运行robot_state_publisher节点,发布tf --&gt; &lt;node name=\"robot_state_publisher\" pkg=\"robot_state_publisher\" type=\"state_publisher\" /&gt; &lt;!-- 运行rviz可视化界面 --&gt; &lt;node name=\"rviz\" pkg=\"rviz\" type=\"rviz\" args=\"-d $(find mrobot_description)/config/mrobot_urdf.rviz\" required=\"true\" /&gt;&lt;/launch&gt; 运行launch文件, 启动rviz查看自己创建的模型 检查urdf文件语法是否有误check_urdf smartcar.urdf 查看检查urdf模型的整体结构urdf_to_graphiz robot.urdf 使用xacro优化urdfxacro介绍 xacro是一种宏语言(macro language)xacro程序(xacro program)运行所有宏并输出结果 xacro作用: 精简模型代码: 创建宏定义, 文件包含 提供可编程接口: 常量, 变量, 数学计算, 条件语句 xacro使用 常量 常量定义 &lt;xacro:property name=&quot;M_pi&quot; value=&quot;3.14159&quot;/&gt;常量使用 &lt;origin xyz=&quot;0 0 0&quot; rpy=&quot;${M_PI/2} 0 0&quot; /&gt; 类似于C语言中的宏定义, 在头部定义, 如&lt;xacro:property name=&quot;WIDTH&quot; value=&quot;0.2&quot; /&gt;, 以${WIDTH}的方式进行使用经常会看到的一个常量定义, &lt;property name=&quot;prefix&quot; value=&quot;my_&quot; /&gt;, 后面关节名字就可以类似的进行更新&lt;joint name=&quot;${prefix}joint&quot; type=&quot;revolute&quot; /&gt; 数学计算 &lt;origon xyz=&quot;0 ${(motor_length+wheel_length)/2} 0&quot; rpy=&quot;0 0 0&quot; /&gt; 所有数学计算都会转换成浮点数运行 宏定义 1234&lt;xacro:macro name=\"default_origin\"&gt; &lt;origin xyz=\"0 0 0\" rpy=\"0 0 0\" /&gt;&lt;/xacro:macro&gt;&lt;xacro:default_origin /&gt; 12345&lt;xacro:macro name=\"default_link\" params=\"prefix\"&gt; &lt;link name=\"$&#123;prefix&#125;_link1\" /&gt;&lt;/xacro:macro&gt;&lt;xacro:default_link prefix=\"my\" /&gt;&lt;xacro:default_link prefix=\"your\" /&gt; 不单由这样简单的参数, 还可以使用块参数 文件包含 很多模型都是以宏的形式进行定义, 并以最小集团分成很多个文件而最终的机器人描述就变得非常简单了 &lt;xacro:include filename=&quot;$(find mbot_description)/urdf/xacro/mbot_base.xacro&quot; /&gt; 显示xacro文件的方法 方法1:将.xacro文件转化成urdf文件:xacro --inorder model.xacro &gt; model.urdf 12345&lt;!--调用解析器--&gt;&lt;arg name=\"model\" default=\"$(find xacro)/xacro --inorder '$(find mbot_description)/urdf/xacro/mbot.xacro'\" /&gt;&lt;arg name=\"gui\" default=\"true\" /&gt;&lt;!--将结果放入robot_description参数中--&gt;&lt;param name=\"robot_description\" command=\"$(arg model)\" /&gt;","categories":[{"name":"ROS","slug":"ROS","permalink":"https://didongdongdi.github.io/categories/ROS/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://didongdongdi.github.io/tags/Notes/"}],"author":"DiDong"},{"title":"水下机器人视觉_8_CNN应用","slug":"水下机器人视觉-8-CNN应用","date":"2019-10-20T14:12:00.000Z","updated":"2019-10-27T02:03:42.236Z","comments":true,"path":"2019/10/20/水下机器人视觉-8-CNN应用/","link":"","permalink":"https://didongdongdi.github.io/2019/10/20/%E6%B0%B4%E4%B8%8B%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%A7%86%E8%A7%89-8-CNN%E5%BA%94%E7%94%A8/","excerpt":"卷积神经网络应用CNNs用于图像分类 卷积层: 检测局部图片的局部特征池化层: 降低维度","text":"卷积神经网络应用CNNs用于图像分类 卷积层: 检测局部图片的局部特征池化层: 降低维度 MLPs和CNNs都要求图片的尺寸经过处理 在做任何操作之前, 将所有图片的尺寸变为相同 将每一张图片变成方形 上面方形的空间维度(宽度和高度)应该为2的幂(如\\(2^5\\)等) 彩色图片的深度为3黑白图片的深度为1 CNN的结构的设计目标: 增加深度(卷积层的作用) 减少宽度和高度(池化层的作用) 卷积层的设置: 卷积核通常是方形, 大小从(2, 2)到(5, 5) 步长通常设置成1 填充通常设为same(代表会使用0填充) 卷积核的数目总是随着层数的增加缓慢增加(特征图深度逐渐增加) 最大池化层的设置: 最大池化层通常跟在一个或两个卷积层后面 池化尺寸通常设成2 步长通常设为2 使得池化后的特征图的空间维度(宽度和高度)是原来的一半 所有的空间信息最终会丢失而最后一层可以回答: 图片里是否有轮子, 眼睛, 腿, 尾巴等等 图像增强 模型可以学习图像的不变表示但是不想让模型的预测因为如下原因改变: 物体的大小 – 尺度不变性 物体的角度 – 旋转不变性 物体的平移 – 平移不变性 现有数据集的基础上, 增加多样性数据集: 在训练数据集中添加各种背景噪音 转换为其他图像: 改变颜色, 改变形状 反转: 左右反转, 上下反转 裁剪: 从图像中裁剪一块区域, 然后调整其大小 随机高宽比 (例如[3/4, 4/3]) 随机区域大小 (例如[8%, 100%]) 一个随机的位置 变色: 调整色调, 饱和度和亮度 (例如[0.5, 1.5]) 迁移学习 迁移学习是一种机器学习的方法, 指的是一个预训练的模型被重新用在另一个任务中 参考https://www.cnblogs.com/charlotte77/p/8399926.html","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://didongdongdi.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://didongdongdi.github.io/tags/Notes/"}],"author":"DiDong"},{"title":"水下机器人视觉_mnist手写数字识别","slug":"水下机器人视觉-mnist手写数字识别","date":"2019-10-20T01:26:00.000Z","updated":"2019-10-20T05:49:06.595Z","comments":true,"path":"2019/10/20/水下机器人视觉-mnist手写数字识别/","link":"","permalink":"https://didongdongdi.github.io/2019/10/20/%E6%B0%B4%E4%B8%8B%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%A7%86%E8%A7%89-mnist%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/","excerpt":"In this notebook, we train an MLP to classify images from the MNIST database. 1. Load MNIST Database","text":"In this notebook, we train an MLP to classify images from the MNIST database. 1. Load MNIST Database 1234567from keras.datasets import mnist# use Keras to import pre-shuffled MNIST database(X_train, y_train), (X_test, y_test) = mnist.load_data()print(\"The MNIST database has a training set of %d examples.\" % len(X_train))print(\"The MNIST database has a test set of %d examples.\" % len(X_test)) The MNIST database has a training set of 60000 examples. The MNIST database has a test set of 10000 examples.2. Visualize the First Six Training Images1234567891011import matplotlib.pyplot as plt%matplotlib inlineimport matplotlib.cm as cmimport numpy as np# plot first six training imagesfig = plt.figure(figsize=(20,20))for i in range(6): ax = fig.add_subplot(1, 6, i+1, xticks=[], yticks=[]) ax.imshow(X_train[i], cmap='gray') ax.set_title(str(y_train[i])) 3. View an Image in More Detail1234567891011121314def visualize_input(img, ax): ax.imshow(img, cmap='gray') width, height = img.shape thresh = img.max()/2.5 for x in range(width): for y in range(height): ax.annotate(str(round(img[x][y],2)), xy=(y,x), horizontalalignment='center', verticalalignment='center', color='white' if img[x][y]&lt;thresh else 'black')fig = plt.figure(figsize = (12,12)) ax = fig.add_subplot(111)visualize_input(X_train[0], ax) 4. Rescale the Images by Dividing Every Pixel in Every Image by 255123# rescale [0,255] --&gt; [0,1]X_train = X_train.astype('float32')/255X_test = X_test.astype('float32')/255 5. Encode Categorical Integer Labels Using a One-Hot Scheme12345678910111213from keras.utils import np_utils# print first ten (integer-valued) training labelsprint('Integer-valued labels:')print(y_train[:10])# one-hot encode the labelsy_train = np_utils.to_categorical(y_train, 10)y_test = np_utils.to_categorical(y_test, 10)# print first ten (one-hot) training labelsprint('One-hot labels:')print(y_train[:10]) Integer-valued labels: [5 0 4 1 9 2 1 3 1 4] One-hot labels: [[0. 0. 0. 0. 0. 1. 0. 0. 0. 0.] [1. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 1. 0. 0. 0. 0. 0.] [0. 1. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0. 0. 1.] [0. 0. 1. 0. 0. 0. 0. 0. 0. 0.] [0. 1. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 1. 0. 0. 0. 0. 0. 0.] [0. 1. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 1. 0. 0. 0. 0. 0.]]6. Define the Model Architecture1234567891011121314151617from keras.models import Sequentialfrom keras.layers import Dense, Dropout, Flatten# define the modelmodel = Sequential()# 将输入展平, 不影响批量大小model.add(Flatten(input_shape=X_train.shape[1:]))# 全连接层model.add(Dense(512, activation='relu'))model.add(Dropout(0.2))model.add(Dense(512, activation='relu'))model.add(Dropout(0.2))model.add(Dense(10, activation='softmax'))# summarize the modelmodel.summary() _________________________________________________________________ Layer (type) Output Shape Param # ================================================================= flatten_5 (Flatten) (None, 784) 0 _________________________________________________________________ dense_13 (Dense) (None, 512) 401920 _________________________________________________________________ dropout_9 (Dropout) (None, 512) 0 _________________________________________________________________ dense_14 (Dense) (None, 512) 262656 _________________________________________________________________ dropout_10 (Dropout) (None, 512) 0 _________________________________________________________________ dense_15 (Dense) (None, 10) 5130 ================================================================= Total params: 669,706 Trainable params: 669,706 Non-trainable params: 0 _________________________________________________________________7. Compile the Model12345# compile the modelmodel.compile(loss='categorical_crossentropy', optimizer='rmsprop', metrics=['accuracy'])# optimizer 优化器 如 rmsprop sgd monentum nag adagrad adadelta rmsprop# metics 在训练和测试期间的模型评估标准, 通常使用 metircs = ['accuracy'] . 要为多输出模型的不同输出指定不同的评估标准, 还可以传递一个字典, 如 metrics = &#123;'output_a':'accuracy'&#125; WARNING:tensorflow:From /home/didong/anaconda/anaconda3/lib/python3.7/site-packages/keras/optimizers.py:790: The name tf.train.Optimizer is deprecated. Please use tf.compat.v1.train.Optimizer instead. WARNING:tensorflow:From /home/didong/anaconda/anaconda3/lib/python3.7/site-packages/keras/backend/tensorflow_backend.py:3295: The name tf.log is deprecated. Please use tf.math.log instead.8. Calculate the Classification Accuracy on the Test Set (Before Training)123456# evaluate test accuracyscore = model.evaluate(X_test, y_test, verbose=0)accuracy = 100*score[1]# print test accuracyprint('Test accuracy: %.4f%%' % accuracy) Test accuracy: 7.8400%9. Train the Model12345678910111213from keras.callbacks import ModelCheckpoint # train the modelcheckpointer = ModelCheckpoint(filepath='mnist.model.best.hdf5', verbose=1, save_best_only=True)# ModelCkeckpoint 在每个训练期之后保存模型hist = model.fit(X_train, y_train, batch_size=128, epochs=20, validation_split=0.2, callbacks=[checkpointer], verbose=1, shuffle=True)# batch_size 每次梯度更新的样本数, 如果未指定, 默认为32# validation_split 用作验证集的训练数据的比例# callbacks 一系列的 keras.callbacks.Callback 实例. 一系列可以在训练时使用的回调函数# shuffle 是否在每轮迭代之前混洗数据 WARNING:tensorflow:From /home/didong/anaconda/anaconda3/lib/python3.7/site-packages/tensorflow/python/ops/math_grad.py:1250: add_dispatch_support.&lt;locals&gt;.wrapper (from tensorflow.python.ops.array_ops) is deprecated and will be removed in a future version. Instructions for updating: Use tf.where in 2.0, which has the same broadcast rule as np.where Train on 48000 samples, validate on 12000 samples Epoch 1/20 48000/48000 [==============================] - 6s 130us/step - loss: 0.2958 - acc: 0.9087 - val_loss: 0.1198 - val_acc: 0.9655 Epoch 00001: val_loss improved from inf to 0.11977, saving model to mnist.model.best.hdf5 Epoch 2/20 48000/48000 [==============================] - 5s 114us/step - loss: 0.1234 - acc: 0.9628 - val_loss: 0.1111 - val_acc: 0.9690 Epoch 00002: val_loss improved from 0.11977 to 0.11112, saving model to mnist.model.best.hdf5 Epoch 3/20 48000/48000 [==============================] - 6s 116us/step - loss: 0.0874 - acc: 0.9734 - val_loss: 0.0892 - val_acc: 0.9766 Epoch 00003: val_loss improved from 0.11112 to 0.08923, saving model to mnist.model.best.hdf5 Epoch 4/20 48000/48000 [==============================] - 6s 118us/step - loss: 0.0697 - acc: 0.9784 - val_loss: 0.0876 - val_acc: 0.9772 Epoch 00004: val_loss improved from 0.08923 to 0.08760, saving model to mnist.model.best.hdf5 Epoch 5/20 48000/48000 [==============================] - 5s 114us/step - loss: 0.0580 - acc: 0.9827 - val_loss: 0.0985 - val_acc: 0.9732 Epoch 00005: val_loss did not improve from 0.08760 Epoch 6/20 48000/48000 [==============================] - 5s 114us/step - loss: 0.0484 - acc: 0.9853 - val_loss: 0.0957 - val_acc: 0.9769 Epoch 00006: val_loss did not improve from 0.08760 Epoch 7/20 48000/48000 [==============================] - 5s 113us/step - loss: 0.0417 - acc: 0.9872 - val_loss: 0.1031 - val_acc: 0.9784 Epoch 00007: val_loss did not improve from 0.08760 Epoch 8/20 48000/48000 [==============================] - 5s 112us/step - loss: 0.0388 - acc: 0.9884 - val_loss: 0.0966 - val_acc: 0.9795 Epoch 00008: val_loss did not improve from 0.08760 Epoch 9/20 48000/48000 [==============================] - 5s 115us/step - loss: 0.0351 - acc: 0.9897 - val_loss: 0.1009 - val_acc: 0.9788 Epoch 00009: val_loss did not improve from 0.08760 Epoch 10/20 48000/48000 [==============================] - 5s 115us/step - loss: 0.0312 - acc: 0.9906 - val_loss: 0.1055 - val_acc: 0.9786 Epoch 00010: val_loss did not improve from 0.08760 Epoch 11/20 48000/48000 [==============================] - 5s 111us/step - loss: 0.0316 - acc: 0.9907 - val_loss: 0.1150 - val_acc: 0.9787 Epoch 00011: val_loss did not improve from 0.08760 Epoch 12/20 48000/48000 [==============================] - 5s 112us/step - loss: 0.0275 - acc: 0.9919 - val_loss: 0.1186 - val_acc: 0.9786 Epoch 00012: val_loss did not improve from 0.08760 Epoch 13/20 48000/48000 [==============================] - 5s 111us/step - loss: 0.0265 - acc: 0.9923 - val_loss: 0.1151 - val_acc: 0.9801 Epoch 00013: val_loss did not improve from 0.08760 Epoch 14/20 48000/48000 [==============================] - 5s 111us/step - loss: 0.0250 - acc: 0.9928 - val_loss: 0.1140 - val_acc: 0.9796 Epoch 00014: val_loss did not improve from 0.08760 Epoch 15/20 48000/48000 [==============================] - 5s 111us/step - loss: 0.0246 - acc: 0.9930 - val_loss: 0.1263 - val_acc: 0.9780 Epoch 00015: val_loss did not improve from 0.08760 Epoch 16/20 48000/48000 [==============================] - 6s 115us/step - loss: 0.0215 - acc: 0.9938 - val_loss: 0.1170 - val_acc: 0.9804 Epoch 00016: val_loss did not improve from 0.08760 Epoch 17/20 48000/48000 [==============================] - 5s 114us/step - loss: 0.0232 - acc: 0.9937 - val_loss: 0.1234 - val_acc: 0.9795 Epoch 00017: val_loss did not improve from 0.08760 Epoch 18/20 48000/48000 [==============================] - 6s 116us/step - loss: 0.0192 - acc: 0.9944 - val_loss: 0.1197 - val_acc: 0.9811 Epoch 00018: val_loss did not improve from 0.08760 Epoch 19/20 48000/48000 [==============================] - 6s 115us/step - loss: 0.0207 - acc: 0.9945 - val_loss: 0.1258 - val_acc: 0.9800 Epoch 00019: val_loss did not improve from 0.08760 Epoch 20/20 48000/48000 [==============================] - 6s 116us/step - loss: 0.0203 - acc: 0.9944 - val_loss: 0.1354 - val_acc: 0.9797 Epoch 00020: val_loss did not improve from 0.0876010. Load the Model with the Best Classification Accuracy on the Validation Set12# load the weights that yielded the best validation accuracymodel.load_weights('mnist.model.best.hdf5') 11. Calculate the Classification Accuracy on the Test Set123456# evaluate test accuracyscore = model.evaluate(X_test, y_test, verbose=0)accuracy = 100*score[1]# print test accuracyprint('Test accuracy: %.4f%%' % accuracy) Test accuracy: 97.9200%","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://didongdongdi.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://didongdongdi.github.io/tags/Notes/"}],"author":"DiDong"},{"title":"水下机器人视觉_6_张量","slug":"水下机器人视觉-6-张量","date":"2019-09-28T23:55:00.000Z","updated":"2019-10-20T00:43:25.516Z","comments":true,"path":"2019/09/29/水下机器人视觉-6-张量/","link":"","permalink":"https://didongdongdi.github.io/2019/09/29/%E6%B0%B4%E4%B8%8B%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%A7%86%E8%A7%89-6-%E5%BC%A0%E9%87%8F/","excerpt":"Feedforward","text":"Feedforward 神经网络的数据表示–张量 张量的关键属性 Shape: a matrix has shape (3, 5) a 3D tensor has shape (3, 3, 5) a vector has a shape (5, ) a scalar has an empty shape () 数据类型(在python库中叫做dtype): 一个张量的数据类型可以是float32, uint8, float64, .. 在少数场合下, 可以看到char类型的张量 string类型的张量在Numpy中不存在(或其他大多数的库中) 现实世界中的数据张量 vector data – 2D tensors of shape (samples, features)attribute information: gender length diameter height whole weight shucked weight viscera weight shell weight rings timeseries data – 3D tensors of shape (samples, timesteps, features)every minute, the current highest/lowest/average price of the stock400 minutes in a trading day250 samples (or 250 days)a 3D tensor of shape (250, 400, 3) image datathree dimensions: height, width, and color deptha batch of 128 color images could be stored in a 4D tensor of shape (128, 256, 256, 3) video dataa 4D tensor (frames, height, width, color_depth)a batch of different videos can be stored in a 5D tensor of shape (samples, frames, height, width, color_depth)","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://didongdongdi.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://didongdongdi.github.io/tags/Notes/"}],"author":"DiDong"},{"title":"水下机器人视觉_7_卷积神经网络","slug":"水下机器人视觉-7-卷积神经网络","date":"2019-09-28T23:55:00.000Z","updated":"2019-10-20T14:11:16.941Z","comments":true,"path":"2019/09/29/水下机器人视觉-7-卷积神经网络/","link":"","permalink":"https://didongdongdi.github.io/2019/09/29/%E6%B0%B4%E4%B8%8B%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%A7%86%E8%A7%89-7-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/","excerpt":"深度神经网络识别手写字mnist手写数字识别 独热编码(One-Hot Encoding)","text":"深度神经网络识别手写字mnist手写数字识别 独热编码(One-Hot Encoding) 关于独热编码的更多内容参考https://zhuanlan.zhihu.com/p/35287916 卷积神经网络 多层感知机(MLPs) 卷积神经网络(CNNs) 只用全连接层 也使用稀疏层 只接收向量作为输入 也接收矩阵作为输入 卷积层 filer(卷积核)同输入层中与卷积核重叠的部分进行求和运算, 而后将求和后的结果经过激活函数处理, 得到卷积后的结果(卷积层)中的一个像素的值 使用一个卷积核可以获得输入层的一种输入特征使用多个卷积核可以获得输入层的多种输入特征, 从而使得到的特征更加丰富, 使模型更加准确 步长(stride)卷积核每次移动的长度(几个像素) 填充(padding)当卷积核移动到边缘时, 覆盖的像素数少于卷积核的像素数, 此时在空白处填0进行填充 在Keras中使用卷积层:参考Keras中文文档e.g. 12345from keras.models import Sequentialfrom keras.layers import Conv2Dmodel &#x3D; Sequential()model.add(Conv2D(filters&#x3D;32, kernel_size&#x3D;3, strides&#x3D;2, padding&#x3D;&#39;same&#39;, activation&#x3D;&#39;relu&#39;, input_shape&#x3D;(128, 128, 3))) 注意: activation如果不指定, 则不使用激活函数(即线性激活函数: a(x) = x) input_shape, 当使用该层作为模型第一层时, 必须提供 padding, same代表保留边界处的卷积结果, 即会padding, 而vaild代表只进行有效的卷积, 对边界数据不处理, 即丢弃, 详细内容参考https://oldpan.me/archives/tf-keras-padding-vaild-same 池化层是什么 在CNN网络中卷积层之后会跟上一个池化层, 根据计算出来的值不一样, 分为均值池化层和最大池化层, 一般常见的多为最大池化层池化操作不改变通道数, 且不需要参数控制 池化层的种类(参考自https://blog.csdn.net/XX_123_1_RJ/article/details/86677482): 一般池化 平均池化 最大池化 重叠池化(OverlappingPooling): 相邻池化窗口之间有重叠区域, 此时一般sizeX &gt; stride 空金字塔池化(Spatial Pyramid Pooling): 空金字塔池化的思想源自Spatial Pyramid Model, 它将一个pooling变成了多个scale的pooling; 用不同大小池化窗口作用于上层卷积特征; 也就是活spatial pyramid pooling layer就是把前一卷积层的feature maps的每一个图片上进行了3个卷积操作, 并把结果输出给全连接层; 其中每一个pool操作可以看成是一个空间金字塔的一层 这样做的好处是, 空间金字塔池化可以把任意尺度的图像的卷积特征转化成相同维度, 这不仅可以让CNN处理任意尺度的图像, 还能避免cropping和warping操作, 导致一些信息的丢失, 具有非常重要的意义 为什么 池化层的作用https://blog.csdn.net/XX_123_1_RJ/article/details/86677482: 下采样(downsamping), 即缩小图像, 主要目的是(参考自https://blog.csdn.net/majinlei121/article/details/46742339) 使得图像符合显示区域的大小 生成对应图像的缩略图 降维, 去除冗余信息, 对特征进行压缩, 简化网络复杂度, 减小计算量, 减小内存消耗等等; 总之就是减少参数量 实现非线性 扩大感知野(感知野是卷积神经网络每一层输出的特征图上的像素点在原始图像上映射的区域的大小, 参考https://blog.csdn.net/m0_37561765/article/details/79943816) 实现不变性, 其中不变性包括: 平移不变性, 旋转不变性和尺度不变性 知乎相关问题 怎么办(Keras中使用池化层)参考Keras官方中文文档","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://didongdongdi.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://didongdongdi.github.io/tags/Notes/"}],"author":"DiDong"},{"title":"水下机器人视觉_5_深度学习算法调优","slug":"水下机器人视觉-5-深度学习算法调优","date":"2019-09-28T09:30:00.000Z","updated":"2019-10-19T23:59:28.874Z","comments":true,"path":"2019/09/28/水下机器人视觉-5-深度学习算法调优/","link":"","permalink":"https://didongdongdi.github.io/2019/09/28/%E6%B0%B4%E4%B8%8B%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%A7%86%E8%A7%89-5-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E8%B0%83%E4%BC%98/","excerpt":"学习率学习率太大或太小的问题:","text":"学习率学习率太大或太小的问题: 降低学习率的准则: 曲线越陡, 步伐越大 曲线越平, 步伐越小 训练集 验证集 测试集 训练集用来训练模型, 验证集用来验证模型的准确性(需要通过验证集来不断调整参数), 测试集用来测试模型最后的准确性测试集和验证集都会对模型产生影响 e.g.400个数据点, 350个用来做训练比较合适 (X_train, X_test) = X[50:], X[:50] (y_train, y_test) = y[50:], y[:50] 过拟合与欠拟合当神经网络过于复杂, 或者模型迭代次数过多时, 就会出现过拟合; 反之, 则出现欠拟合 Early Stopping通过早停机来防止过拟合 正则化 由于参数过多容易造成过拟合通过惩罚大的权重来防止过拟合 L1: $$ ERROR\\quad FUNCTION = -\\frac{1}{m}\\sum_{i=1}^{m}(1 - y_i)ln(1 - \\hat{y_i}) + y_iln(\\hat{y_i}) + \\lambda(|\\omega_1|+…+|\\omega_n|) $$ L2: $$ ERROR\\quad FUNCTION = -\\frac{1}{m}\\sum_{i=1}^{m}(1 - y_i)ln(1 - \\hat{y_i}) + y_iln(\\hat{y_i}) + \\lambda({\\omega_1}^2 + … + {\\omega_n}^2) $$ Dropout dropout是指在深度学习网络的训练过程中, 对于神经网络单元, 按照一定的概率将其暂时从网络中丢弃注意是暂时, 对于随机梯度下降来说, 由于是随机丢弃, 故而每个mini-bath都在训练不同的网络 为什么dropout是有效的?(参考自https://blog.csdn.net/stdcoutzyx/article/details/49022443)解释一:大规模的神经网络有两个缺点: 费时 过拟合 为了解决过拟合问题, 一般会采用ensemble方法, 即训练多个模型做组合, 此时, 费事就称为一个大问题, 不经训练起来费时, 测试起来多个模型也费事; 总之, 几乎形成一个死锁dropouot的出现很好地解决这个问题, 每次做完dropout, 相当于从原始的网络中找到一个更瘦的网络因而, 对于一个有N个节点的神经网络, 有了dropout后, 就可以看做是\\(2^n\\)个模型的集合了, 但此时要训练的参数数目却是不变的, 这就解脱了费时的问题解释二:dropout强迫一个神经单元, 和随机挑选出来的其他神经单元共同工作, 达到好的效果; 消除减弱了神经元节点间的联合适应性, 增强了泛化能力(更多dropout有效的原因及相关知识, 参考https://blog.csdn.net/stdcoutzyx/article/details/49022443) 在keras中应用dropout: 12model.add(Dense(32, activation&#x3D;&#39;sigmoid&#39;))model.add(Dropout(0.2)) 其中, 0.2是每个神经元会被drop的概率(上面链接中的文章表明, 0.5可能最好, 原因是0.5的时候dropout随机生成的网络结构最多) ReLU激活函数 sigmoid激活函数存在的问题:梯度消失, 在反向传播的过程中, 当神经网络深度很大时, 随着求导次数的增加, 最终的导数值会很小, 接近于0, 从而难以对靠近输入层的参数做出改变 其他激活函数: 123456# 激活函数model.add(Activation(&#39;sigmoid&#39;))model.add(Activation(&#39;softmax&#39;))model.add(Activation(&#39;relu&#39;))model.add(Activation(&#39;tanh&#39;))# ... Random Restart由于存在局部最优, 故通过随机开始迭代, 来尝试从不同的地方获得局部最优解, 从而比较获得全局最优解(不一定找得到, 则选择次优) 梯度下降优化(以下内容参考自: https://blog.csdn.net/google19890102/article/details/69942970) 梯度下降法是最小化目标函数\\(J(\\theta)\\)的一种方法, 其中, \\(\\theta\\in R^d\\)为模型参数, 梯度下降法用目标案数关于参数的梯度\\(\\nabla_\\theta J(\\theta)\\)的反方向更新参数学习率\\(\\eta\\)或\\(\\alpha\\)决定达到最小值或者局部最小值过程中所采用的步长的大小即, 我们沿着目标函数的斜面下降的方向, 直到到达谷底 梯度下降法中有三种变形形式, 它们之间的区别为我们在计算目标函数的梯度时使用到多少数据根据数据量的不同, 我们在参数更新的精度和更新过程中所需要的时间两个方面做出权衡 梯度下降法的变形形式批梯度下降法Vanilla梯度下降法, 又称为批梯度下降法(batch gradient descent), 在整个训练数据集上计算损失函数关于参数\\(\\theta\\)的梯度: $$ \\theta = \\theta - \\eta \\cdot \\nabla_\\theta J(\\theta) $$ 因为在执行每次更新时, 我们需要在整个数据集上计算所有梯度, 所以批梯度下降法的速度会很慢, 同时, 批梯度下降法无法处理超出内存容量限制的数据集, 同样也不能在线更新模型, 即在运行的过程中, 不能增加新的样本. 代码示例: 123for i in range(nb_epochs): params_grad &#x3D; evaluate_gradient(loss_function, data, params) params &#x3D; params - learning_rate * params_grad 对于凸误差函数, 批梯度下降法能够保证收敛到全局最小值, 对于非凸函数, 则收敛到一个局部最小值 随机梯度下降法随机梯度下降法(stochastic gradient descent, SGD)根据每一条训练样本\\(x^{(i)}\\)和标签\\(y^{(i)}\\)更新参数: $$ \\theta = \\theta - \\eta \\cdot \\nabla_\\theta J(\\theta; x^{(i)}; y^{(i)}) $$ 对于的大数据集, 因为批梯度下降法在每一个参数更新之前, 会对相似的样本计算梯度, 所以在计算过程中会有冗余; 而SGD在每一次更新中只执行一次, 从而消除了冗余; 因而, 通常SGD的运行速度更快, 同时, 可以用于在线学习; SGD以高方差频繁地更新, 导致目标函数出现如下图所示的剧烈波动 与梯度下降法的收敛会使得损失函数陷入局部最小相比, 由于SGD的波动性, 一方面, 波动性使得SGD可以跳到新的和潜在更好的局部最优; 另一方面, 这使得最终收敛到特定最小值的过程变得复杂, 因为SGD会一直持续波动; 然而, 已经证明当我们缓慢减小学习率, SGD与批梯度下降法具有相同的收敛行为, 对于非凸优化和凸优化, 可以分别收敛到局部最小值和全局最小值; 与批梯度下降的代码相比, SGD的代码片段仅仅是在对训练样本的遍历和利用每一条样本计算梯度的过程中增加一层循环; 在每一次循环中, 我们打乱训练样本 代码示例: 12345for i in range(nb_epochs): np.random.shuffle(data) for example in data: params_grad &#x3D; evaluate_gradient(loss_function, example, params) params &#x3D; params - learning_rate * params_grad 小批量梯度下降法小批量梯度下降法最终结合了上述两种方法的优点, 在每次更新时使用n个小批量训练样本: $$ \\theta = \\theta - \\eta \\cdot \\nabla_\\theta J(\\theta; x^{(i:i+n)}; y^{(i:i+n)}) $$ 这种方法 减少参数更新的方差, 这样可以得到更加稳定的收敛结果 可以利用最新的深度学习库中高度优化的矩阵优化方法, 高效地求解每个小批量数据的梯度 通常, 小批量数据的大小在50到256之间, 也可以根据不同的应用有所变化; 当训练神经网络模型时, 小批量梯度下降法是典型的选择算法 代码示例: 123456789# 在大小为50的小批量数据上做迭代for i in range(nb_epochs): np.random.shuffle(data) for batch in get_batches(data, batch_size&#x3D;50): params_grad &#x3D; evaluate_gradient(loss_function, batch, params) params &#x3D; params - learning_rate * params_grad# 在keras中使用小批量梯度下降model.fit(X_train, y_train, epochs&#x3D;1000, batch_size&#x3D;100, verbose&#x3D;0) 挑战虽然Vanilla小批量梯度下降法并不能保证较好的收敛性, 但是需要强调的是, 这也给我们留下了如下的一些挑战: 选择一个合适的学习率是困难的; 学习率太小会导致收敛的速度很慢, 学习率太大会妨碍收敛, 导致损失函数在最小值附近波动甚至偏离最小值 学习率调整试图在训练的过程中通过例如退火(annealing)的方法调整学习率, 即根据预定义的策略或者当相邻两代之间的下降值小于某个阀值时减小学习率; 然而, 策略和阀值需要预先设定好, 因此无法适应数据集的特点 此外, 对所有的参数更新使用同样的学习率; 如果数据是稀疏的, 同时, 特征的频率差异很大时, 我们也许不想以同样的学习率更新所有的参数, 对于出现次数较少的特征, 我们对其执行更大的学习率 高度非凸误差函数普遍出现在神经网络中, 在优化这类函数时, 另一个关键的挑战是使函数避免陷入无数次优的局部最小值; Dauphin等人指出出现这种困难实际上并不是来自局部最小值, 而是来自鞍点, 即那些在一个维度上是递增的, 而在另一个维度上是递减的; 这些鞍点通常被具有相同误差的点包围, 因为在任意维度上的梯度都近似为0, 所以SGD很难从这些鞍点中逃开 梯度下降优化算法下面, 我们将列举一些算法, 这些算法被深度学习社区广泛用来处理前面提到的挑战; 我们不会讨论在实际中不适合在高维数据集中计算的算法, 例如二阶方法中的牛顿法 动量法SGD很难通过陡谷, 即在一个维度上的表面弯曲程度远大于其他维度的区域, 这种情况通常出现在局部最优点附近; 在这种情况下, SGD摇摆地通过陡谷的斜坡, 同时, 沿着底部到局部最优点的路径上只是缓慢地前进, 这个过程如下图中的(a)所示 如上图(b)所示, 动量法是一种帮助SGD在相关方向上加速并抑制摇摆的一种方法; 动量法将历史步长的更新向量的一个分量\\(\\gamma\\)增加到当前的更新向量中(部分实现中交换了公式中的符号) $$ v_t = \\gamma v_{t-1} + \\eta\\nabla_\\theta J(\\theta) $$ $$ \\theta = \\theta - v_t $$ 动量项\\gamma通常设置为0.9或者类似的值 从本质上说, 动量法, 就像我们从山上推下一个球, 球在滚下来的过程中累积动量, 变得越来越快(知道达到终极速度, 如果有空气阻力的存在, 则\\(\\gamma &lt; 1\\)); 同样的事情也发生在参数的更新过程中: 对于在梯度点处具有相同的方向的维度, 其动量项增大, 对于在梯度点处改变方向的维度, 其动量项减小; 因此, 我们可以得到更快的收敛的速度, 同时减少摇摆 更多关于: 梯度下降优化算法(Nesterov加速梯度下降法, Adagrad, Adadelta, RMSprop, Adam) 算法可视化 选择使用哪种优化算法? 并行和分布式SGD 优化SGD的其他策略参考https://blog.csdn.net/google19890102/article/details/69942970","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://didongdongdi.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://didongdongdi.github.io/tags/Notes/"}],"author":"DiDong"},{"title":"机器人操作系统ROS_2_ROS通信机制与编程基础","slug":"机器人操作系统ROS-2-ROS通信机制与编程基础","date":"2019-09-27T12:28:00.000Z","updated":"2019-10-21T08:14:35.637Z","comments":true,"path":"2019/09/27/机器人操作系统ROS-2-ROS通信机制与编程基础/","link":"","permalink":"https://didongdongdi.github.io/2019/09/27/%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FROS-2-ROS%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6%E4%B8%8E%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/","excerpt":"ROS的通信机制 ROS通信架构: 各种数据的处理 进程的运行 消息的传递 等等","text":"ROS的通信机制 ROS通信架构: 各种数据的处理 进程的运行 消息的传递 等等 ROS的核心: 分布式通信机制 ROS的通信方式主要有: 话题 服务 参数 动作 ROS编程基础ros编程目前最常用的只有roscpp和rospy Client Library 介绍 roscpp ROS的C++库, 是目前最广泛应用的ROS客户端库, 执行效率高 rospy ROS的Python库, 开发效率高, 通常用在对运行时间没有太大要求的场合, 例如配置、初始化等操作 … … 整个ROS包括的packages: roscpp roscpp位于/opt/ros/kinetic之下, 用C++实现了ROS通信 在ROS中, C++的代码是通过catkin这个编译系统(扩展的CMake)来进行编译构建的(简单地理解, roscpp就是C++的库, 创建一个CMake工程, 在其中include了roscpp等ROS的libraries, 这样就可以在工程中使用ROS提供的函数) 调用ROS的C++接口, 首先#include &lt;ros/ros.h&gt; roscpp的主要部分: 内容 说明 ros::init() 解析传入的ROS参数, 创建node第一步需要用到的函数 ros::NodeHandle 和topic、service、param等交互的公共接口 ros::master 包含从master查询信息的函数 ros::this_node 包含查询这个进程(node)的函数 ros::service 包含查询服务的函数 ros::param 包含查询参数服务器的函数, 而不需要用到NodeHandle ros::names 包含处理ROS图资源名称的函数 主要功能分类: 功能 说明 Initialization and Shutdown 初始与关闭 Topics 话题 Services 服务 Parameter Server 参数服务器 Timers 定时器 NodeHandles 节点句柄 Callbacks and Spinning 回调和自旋(轮询、循环) Logging 日志 Names and Node Information 名称管理 Time 时钟 Exception 异常 初始化节点: 调用ros::init()函数, 初始化节点的名称和其他信息, 一般ROS程序以这种方式开始 创建ros::NodeHandle对象, 也就是节点的句柄, 它可以用来创建Publisher Subscriber 以及做其他事情 关闭节点: 通常直接在终端上按Ctrl+C关闭一个节点, 系统会自动触发SIGINT句柄来关闭这个进程 也可以通过调用ros::shutdown()来手动关闭节点, 但通常很少这样做 roscpp开发步骤 创建源文件 mkdir -r ros_catkin_wksp/src cd ros_catkin_wksp catkin_make cd src catkin_create_pkg ros_node_test roscpp std_msgs cd ros_node_test/src rosed ros_node_test node_test.cpp 或 vim node_test.cpp 编辑源文件 123456789#include&lt;ros/ros.h&gt;int main(int argc, char** argv)&#123; ros::init(argc, argv, \"my_node\"); ros::NodeHandle nh; //...节点功能 //... ros::spin();//用于触发topic, service的相应队列 return 0;&#125; 运行程序 打开ros_node_test下的CMakeLists.txt文件, 添加 add_executable(node src/node_test.cpp) target_link_libraries(node ${catkin_LIBRARIES}) cd ../.. catkin_make (编译, 如果成功) source devel/setup.sh roscore rosrun ros_node_test node (新终端) rosnode list (新终端, 查看新创建的节点) roscpp总体编程步骤: 创建工作空间(创建包之前的操作只需要一次, 以后不再需要) 编写roscpp程序启动节点 修改CMakeLists.txt文件 编译并运行 rosnode查看节点是否运行成功 rospy rospy是Python版本的ROS客户端库, 提供了Python编程需要的接口, 可以认为rospy就是一个Python的模块这个模块位于/opt/ros/kinetic/lib/python2.7/dist-packages/rospy之中 由于Python的开发效率高, 但执行效率低所以, 开发SLAM(即时定位与地图构建), 路径规划, 机器视觉等方面的算法时, 往往优先选择C++对于一些简单的功能可以优先选用Python rospy包含的功能与roscpp相似, 都有关于node, topic, service , param, time相关操作 但同时rospy和roscpp也有一些区别: rospy没有一个NodeHandle, 像创建publisher, subscriber等操作都被直接封装成了rospy中的函数或类, 调用起来简单直观 rospy一些接口的命名和roscpp不一致, 有些地方需要开发者注意, 避免调用错误 rospy的组织形式 通常来说, Python代码有两种组织方式, 一种是单独的一个Python脚本, 适用于简单的程序, 另一种是Python模块, 适合体量较大的程序对于一些小体量的ROS程序, 一般就是一个Python文件, 放在script/路径下 ROS建议按照以下规范来建立一个Python的模块:your_package|- src/|- your_package/|- init.py|- modulefiles.py|- scripts/|- your_script.py|- setup.py 通常常用的ROS命令, 大多数其实都是一个个Python模块, 源代码存放在ros_comm仓库的tools路径下:https://github.com/ros/ros_comm/tree/lunar-devel/tools一个命令行工具(如rosbag, rosmsg)都是用模块的形式组织核心代码, 然后在script/下建立一个脚本来调用模块 rospy中具体的API参考http://docs.ros.org/api/rospy/html/rospy-module.html rospy中的各种接口 rospy开发的步骤 创建源文件:cd my_ros_test/srccatkin_create_pkg node_rospy std_msgs rospycd node_rospymkdir scriptscd scriptsvim node.py 编辑源文件: 1234567#!&#x2F;usr&#x2F;bin&#x2F;env python# -*- coding:usf-8 -*-import rospyif __name__ &#x3D;&#x3D; &quot;__main__&quot;: rospy.init_node(&#39;rospy_node&#39;) while not rospy.is_shutdown(): pass 执行程序:chmod +x node.pysource my_ros_test/devel/setup.shrosrun node_rospy node.py 或者直接 ./node.pyrosnode list (新终端) ROS话题通信机制 话题在ROS中使用最为频繁, 通信模型也相对复杂话题分为发布者和订阅者, 发布和订阅的顺序没有要求 话题通信流程 Talker注册 Listener注册 ROS Master进行信息匹配 Listener发送连接请求 Talker确认连接请求 Listener尝试与Talker建立网络连接 Talker向Listener发布数据 Publisher的编程 Publisher开发流程: 初始化ROS节点 向ROS Master注册节点信息, 包括发布的话题名和话题中的消息类型 创建消息数据 按照一定的频率循环发布消息 Subscriber的编程 Subscriber的编程: 初始化ROS节点 订阅需要的话题 循环等待话题消息, 接收到消息后进入回调函数 回调函数中完成消息处理 自定义消息的发布和订阅 自定义话题消息, 创建msg文件, 内容如下 string nameuint8 ageuint8 sex uint8 unknow = 0uint8 male = 1uint8 female = 2 在package.xml中添加功能包依赖 12&lt;build_depend&gt;message_generation&lt;/build_depend&gt;&lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt; 在CMakeLists.txt中添加编译选项 find_package(… message_generation)add_message_files(FILES Person.msg)generate_messages(DEPENDENCIES std_msgs)catkin_package(CATKIN_DEPENDS geometry_msgs roscpp rospy std_msgs turtlesim message_runtime) 编辑roscpp和rospy程序 在CMakeLsts.txt中添加 1234567add_executable(person_publisher src&#x2F;person_publisher.cpp)target_link_libraries(person_publisher $&#123;catkin_LIBRARIES&#125;)add_dependencies(person_publisher $&#123;PROJECT_NAME&#125;_generate_messages_cpp)add_executable(person_subscriber src&#x2F;person_subscriber.cpp)target_link_libraries(person_subscriber $&#123;catkin_LIBRARIES&#125;)add_dependencies(person_subscriber $&#123;PROJECT_NAME&#125;_generate_messages_cpp) ROS服务通信机制 服务是一种带有应答的通信机制, 与话题相比它减少了listener与talker之间的rpc通信 服务通信流程 Talker注册 Listener注册 ROS Master 进行信息匹配 Listener与Talker建立网络连接 Taker向Listener发布服务应答数据 服务通信机制的特点 同步通信 双向 简单高效 客户端client的编程 客户端client开发流程 初始化一个ROS节点 创建一个Client实例 发布服务请求数据 等待server处理之后的应答结果 服务端server的编程 服务端server开发流程 初始化ROS节点 创建Server实例 循环等待服务请求, 进入回调函数 在回调函数中完成服务功能的处理, 并反馈应答数据 自定义服务数据的编程 定义srv文件 string nameuint8 ageuint8 sex uint8 unknown = 0uint8 male = 1uint8 female = 2 在package.xml中添加功能包依赖 12&lt;build_depend&gt;message_generation&lt;/build_depend&gt;&lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt; 在CMakeLists.txt中添加编译选项 find_package(… message_generation)add_service_files(FILES Person.srv)generate_messages(DEPENDENCIES std_msgs) 编写相应程序 配置CMakeLists.txt, 向其中添加 1234567add_executable(person_server src&#x2F;person_server.cpp)target_link_libraries(person_server $&#123;catkin_LIBRARIES&#125;)add_dependencies(person_server $&#123;PROJECT_NAME&#125;_gencpp)add_executable(person_clent src&#x2F;person_client.cpp)target_link_libraries(person_client $&#123;catkin_LIBRARIES&#125;)add_dependencies(person_client $&#123;PROJECT_NAME&#125;_gencpp) ROS参数通信机制ROS参数管理机制 参数类似于ROS中的全局变量, 有ROS Master进行管理, 其通信机制较为简单不涉及TCP, UDP的通信 参数通信流程: Talker设置变量(使用RPC向master发送参数设置数据) Listener查询参数值(使用RPC向master查询参数值) ROS Master向Listener发送参数值 注意: 如果Listener不主动查询, 则无法获得更新后的参数 ROS参数通信程序设计 参数通信程序设计流程: 初始化ROS节点 get函数获取参数 set函数设置参数 launch文件的编写launch文件介绍 启动文件(launch file)便是ros中一种同时启动多个节点的途径, 还可以自动启动ROS Master节点管理器, 而且可以实现每个节点的各种配置, 为多个节点的操作提供了很大便利 在ros中以.launch或.xml后缀结尾的文件就是启动文件 使用launch文件启动时, 会自动启动ROSMaster launch文件的编写使用xml格式 运行launch文件的方法: roslaunch 包名称 launch文件名 在功能包目录下创建文件夹launch, 存放所有的launch文件 launch文件编写基本元素一个简单的launch文件: 1234&lt;launch&gt; &lt;nodepkg=\"turtlesim\" name=\"sim1\" type=\"turtlesim_node\"/&gt; &lt;nodepdg=\"turtlesim\" name=\"sim2\" type=\"turtlesim_node\"/&gt;&lt;/launch&gt; 这是一个简单而完整的launch文件, 包含一个根元素和两个节点元素 元素xml文件必须要包含一个根元素, launch文件中的根元素采用标签定义, 文件中的其他内容都必须包含在这个标签之中 123&lt;launch&gt; ...&lt;/launch&gt; 元素启动文件的核心是启动ros节点, 采用标签定义, 语法如下 1&lt;node pkg=\"package-name\" type=\"executable-name\" name = \"node-name\" /&gt; 的其他属性output = “screen”: 将节点的标准输出打印到中断屏幕, 默认输出为日志文档respawn = “true”: 复位属性, 该节点停止时, 会自动重启, 默认为falserequired = “true”: 必要节点, 当该节点终止时, launch文件中的其他节点也被终止ns = “namespace”: 命名空间, 为节点内的相对名称添加命名空间前缀args = “arguments”: 节点需要的输入参数 实际机器人中的节点:见robot.launch文件中还出现了, , , 这些都是常用的标签元素 1234567891011121314151617181920212223242526272829&lt;!-- robot.launch --&gt;&lt;launch&gt; &lt;node pkg=\"mrobot_bringup\" type=\"mrobot_bringup\" name=\"mrobot_bringup\" output=\"screen\" /&gt; &lt;arg name=\"urdf_file\" default=\"$(find xacro)/xacro --inorder '$(find mrobot_description)/urdf/mrobot_with_rplidar.urdf.xacro'\" /&gt; &lt;param name=\"robot_description\" command=\"$(arg urdf_file)\" /&gt; &lt;node name=\"joint_state_publisher\" pkg=\"joint_state_publisher\" type=\"joint_state_publisher\" /&gt; &lt;node pkg=\"robot_state_publisher\" type=\"robot_state_publisher\" name=\"state_publisher\"&gt; &lt;param name=\"publish_frequency\" type=\"double\" value=\"5.0\" /&gt; &lt;/node&gt; &lt;node name=\"base2laser\" pkg=\"tf\" type=\"static_transform_publisher\" args=\"0 0 0 0 0 0 1 /base_link /laser 50\"/&gt; &lt;node pkg=\"robot_pose_ekf\" type=\"robot_pose_ekf\" name=\"robot_pose_ekf\"&gt; &lt;remap from=\"robot_pose_ekf/odom_combined\" to=\"odom_combined\"/&gt; &lt;param name=\"freq\" value=\"10.0\"/&gt; &lt;param name=\"sensor_timeout\" value=\"1.0\"/&gt; &lt;param name=\"publish_tf\" value=\"true\"/&gt; &lt;param name=\"odom_used\" value=\"true\"/&gt; &lt;param name=\"imu_used\" value=\"false\"/&gt; &lt;param name=\"vo_used\" value=\"false\"/&gt; &lt;param name=\"output_frame\" value=\"odom\"/&gt; &lt;/node&gt; &lt;include file=\"$(find mrobot_bringup)/launch/rplidar.launch\" /&gt; &lt;/launch&gt; 参数 - parameter是ros系统运行中的参数, 存储在参数服务器中 - 在launch文件中通过元素加载parameter - launch文件执行后, parameter就加载到ROS的参数服务器上了 - 每个活跃的节点都可以通过`ros::param::get()`接口来获取parameter的值, 用户也可以在终端中通过rosparam命令获得parameter的值 用法: - `` - 在很多复杂的系统中, 参数的数量很多, ros也为我们提供了另外一种类似的参数加载方式 用法: - `` - 将一个yaml格式文件中的参数全部加载到ROS参数服务器中 - argument是另外一个概念, 类似于launch文件内部的局部变量, 仅限于launch文件使用, 便于launch文件的重构, 和ROS节点内部的实现没有关系 设置launch文件的内部变量 - `` launch文件中需要使用到argument时, 可以使用如下方式调用: - `` - `` 重映射 - ros的设计目标是提高代码的复用率, 所以ros社区中的很多功能包我们都可以拿来直接使用, 而不需要关注功能包的内部实现, 那么问题就来了, 别人功能包的接口不一定和我们的系统兼容 - ROS提供一种重映射的机制, 简单来说就是取别名 例如: - `` 嵌套复用 - 在复杂的系统当中, launch文件往往有很多, 这些launch文件之间也会存在依赖关系 - 如果需要直接复用一个已有launch文件中的内容, 可以使用``标签包含其他launch文件, 这个C语言中的include几乎是一样的 例如: - `` 内容小结 launch是ROS框架中非常实用, 灵活的功能, 它类似于一种高级编程语言, 可以帮助我们管理启动系统时的方方面面在使用ROS的过程中, 很多情况下我们并不需要编写大量代码, 仅需要私用已有的功能包, 编辑一下launch文件, 就可以完成很多机器人功能 参考:http://wiki.ros.org/roslaunch/XMLhttps://blog.csdn.net/weixin_41995979/article/details/81784987","categories":[{"name":"ROS","slug":"ROS","permalink":"https://didongdongdi.github.io/categories/ROS/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://didongdongdi.github.io/tags/Notes/"}],"author":"DiDong"},{"title":"水下机器人视觉_4_反向传播","slug":"水下机器人视觉-4-反向传播","date":"2019-09-21T11:37:00.000Z","updated":"2019-09-21T14:23:36.953Z","comments":true,"path":"2019/09/21/水下机器人视觉-4-反向传播/","link":"","permalink":"https://didongdongdi.github.io/2019/09/21/%E6%B0%B4%E4%B8%8B%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%A7%86%E8%A7%89-4-%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/","excerpt":"sigmoid函数的导数计算:","text":"sigmoid函数的导数计算: 由于没太看懂PPT内容, 最后还是参考https://www.cnblogs.com/charlotte77/p/5629865.html 简而言之, 信号前向传播, 权重的更新反向传播; 反向传播算法利用链式法则, 来获得总误差值对每个权重的偏导数, 是对梯度下降算法中求偏导数的具体实现","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://didongdongdi.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://didongdongdi.github.io/tags/Notes/"}],"author":"DiDong"},{"title":"水下机器人视觉_3_深度神经网络","slug":"水下机器人视觉-3-深度神经网络","date":"2019-09-15T13:46:00.000Z","updated":"2019-09-21T14:06:31.932Z","comments":true,"path":"2019/09/15/水下机器人视觉-3-深度神经网络/","link":"","permalink":"https://didongdongdi.github.io/2019/09/15/%E6%B0%B4%E4%B8%8B%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%A7%86%E8%A7%89-3-%E6%B7%B1%E5%BA%A6%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/","excerpt":"非线性模型","text":"非线性模型 多层感知机(神经网络) 通过线性模型拼出非线性模型 bias提供偏差 通过sigmoid函数处理使结果为处于0-1之间的概率 调整感知机的权重, 会获得不同的曲线(非线性模型) 神经网络分为三层: 输入层 隐藏层(可以有多层) 输出层 深度神经网络: 隐藏层大于一层 多分类和softmax 多少种分类代表输出层的神经元有多少个 多分类使用softmax函数二分类使用sigmoid函数 使用softmax函数的原因: sigmoid是softmax的一个特例, 如下图(图片来源: https://www.zhihu.com/question/294679135) 第一步:创建一个函数集Create a function set feedforward(前向传播) 神经网络是一个函数, 输入向量, 输出向量给定一个网络结构, 定义一个函数集合通过调整W和b的值(调参), 来不断降低误差函数的值, 优化神经网络j 每个神经元进行矩阵运算使用并行计算技术可以加速矩阵运算 第二步:定义什么样函数是好的函数Define goodness of function 第三步:获得最好的函数Get the best function backpropagation(反向传播)让梯度下降效率更高 训练神经网络过程 训练神经网络过程: 做前向传播操作(feedforward) 比较模型输出和期望输出(\\(\\hat{y}\\)和\\(y\\)) 计算误差(error function) 运行梯度下降算法散布误差到每个权重(backpropagation) 利用这个去更新权重, 从而获得一个更好的模型 持续这个过程, 直到获得一个好的模型 模型出错的原因: 迭代次数有问题 或者学习率的设置有问题","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://didongdongdi.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://didongdongdi.github.io/tags/Notes/"}],"author":"DiDong"},{"title":"机器人操作系统ROS_1_ROS系统架构及概念","slug":"机器人操作系统ROS-1-ROS系统架构及概念","date":"2019-09-14T02:47:00.000Z","updated":"2019-10-21T08:15:56.702Z","comments":true,"path":"2019/09/14/机器人操作系统ROS-1-ROS系统架构及概念/","link":"","permalink":"https://didongdongdi.github.io/2019/09/14/%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FROS-1-ROS%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%8F%8A%E6%A6%82%E5%BF%B5/","excerpt":"初识ROSROS介绍 ros的设计目标: 提高机器人研发中的软件复用率 ros集成了大量的工具, 库, 协议, 提供了类似操作系统的功能, 把原本松散的零部件耦合在了一起","text":"初识ROSROS介绍 ros的设计目标: 提高机器人研发中的软件复用率 ros集成了大量的工具, 库, 协议, 提供了类似操作系统的功能, 把原本松散的零部件耦合在了一起 解耦: 分成模块 ros是一个机器人软件平台 在这个环境上, 机器人的感知, 决策, 控制算法可以更好的组织和运行 通信机制ros提供了松耦合的分布式的通信方法 开发工具 配置 启动 自检 调试 可视化 登录 测试 终止 应用功能 聚焦于移动性, 操作性和感知性, ros提供了实现机器人功能的广泛的库 生态系统ros的支持和发展依托着一个强大的社区 发行版 软件源 ros wiki 邮件列表 ros answer 博客 ROS的起源与发展 ROS的特点点对点设计 ros通过点对点设计以及服务和节点管理器等机制可以分散由于计算机视觉和语音识别等功能带来的实时计算压力, 这种设计能适应服务机器人遇到的挑战 不依赖编程语言 为了支持多语言编程, ros采用了一种语言中立的接口定义语言(IDL)来实现各模块之间的消息传送 精简与集成 ros建立的系统具有模块化的特点, 各模块中的代码可以单独编译, 而且编译使用的cmake工具使它很容易的就实现精简的理念 ros基本将复杂的代码封装在库里, 只是创建了一些小的应用程序为ros显示库的功能, 这就允许了对简单的代码超越原型进行移植和重新使用 ros不修改用户的主函数, 所以代码可以被其他的机器人软件使用, 其优点是ros很容易和其他的机器人软件平台集成, 例如, 在计算机视觉方面, ros已经与opencv实现集成 便于测试 精心设计的ros系统框架将底层硬件控制模块和顶层数据处理与决策模块分离, 从而可以使用模拟器替代底层硬件模块, 独立测试顶层部分, 提高测试效率 ros另外提供了一种简单的方法可以在调试过程中记录传感器数据及其他类型的消息数据, 并在试验后按时间戳回访(rosbag), 通过这种方式, 每次运行机器人可以获得更多的测试机会, 例如, 可以记录传感器的数据, 并通过多次回放测试不同的数据处理算法 组件化工具包丰富为了管理复杂的ros软件框架, ros利用了大量的小工具*去编译和运行多种多样的ros组件, 从而设计成了内核, 而不是构建一个庞大的开发和运行环境, *(组件化的方式), 例如3d可视化工具rviz, rqt工具箱, gazebo仿真等等 免费且开源遵从BSD协议 存在的缺点 通信实时性能有限 系统稳定性尚不满足工业级要求 安全性上没有防护措施 目前仅支持linux(Ubuntu) ros系统架构及概念_ros文件系统ros的架构ros架构的三个层次 os层: linux(ubuntu) 中间层: tcpros/udpros通信 向上提供client library 应用层: master负责整个系统正常运行 功能包中模块以节点为单位 只需了解接口, 提高开发效率 ros系统的架构设计 ros系统的架构主要被设计和划分成了三个部分, 每一个部分是一个层级: 文件系统级: 程序是如何运行的 计算图级: 程序文件是如何组织和构建的 开源社区级: 程序的分布式管理 ros的文件系统理解ros文件系统ros程序的不同组件要被放在不同的文件夹下 catkin编译系统 gcc/g++ make: 编译工具 cmake: makefile生成器 catkin: ros对cmake的拓展 catkin编译的工作流程: 首先在工作空间catkin_ws/src/下递归地查找其中每一个ros的package package中会有package.xml和CmakeLists.txt文件, catkin(cmake)编译系统依据CMakeLists.txt文件, 从而生成makefiles(放在catkin_ws/build/) 然后make刚刚生成的makefiles等文件, 编译链接生成可执行文件(放在catkin_ws/devel/) catkin工作空间catkin_make, 编译src中所有的软件包 创建package: 进入src文件夹 catkin_create_pkg package depends, package是包名, depends是依赖的包名, 可以依赖多个软件包 catkin_create_pkg帮你完成了软件包的初始化, 填充好了CMakeLists.txt和package.xml, 并且将依赖项填进了这两个文件夹中 package的文件结构: CMakeLists.txt #packag的编译规则(必须) package.xml #package的描述信息(必须) src/ #源代码文件 include/ #C++头文件 scripts/ #可执行脚本 msg/ #自定义消息 srv/ #自定义服务 models/ #3D模型文件 urdf/ #urdf文件 launch/ #launch文件 软件包相关命令 rosdep rosdep命令 作用 rosdep check [package] 检查package的依赖是否满足 rosdep install [package] 安装package的依赖 rosdep db 生成和显示依赖数据库 rosdep init 初始化 /etc/ros/rosdep中的源 rosdep keys 检查package的依赖是否满足 rosdep update 更新本地的rosdep数据库 rosls rosls [package]列出某package roscd roscd [package]进入到某package的目录 roscp roscp [package] filename dest_path直接从某个package中复制某个文件到指定目录下 rospack rospack命令 作用 rospack help 显示rospack的用法 rospack list 列出本机所有package rospack depends [package] 显示package的依赖包 rospack find [package] 定位某个package rospack profile 刷新所有package的位置记录 其他常见文件类型 launch文件 launch文件一般以.launch或.xml结尾, 它对ROS需要运行程序进行了打包, 通过一句命令来启动 msg/srv/action文件 ROS程序中自定义的消息/服务/动作文件 urdf/xacro文件 urdf/xacro文件是机器人模型的描述文件, 以urdf或.xacro结尾 yaml文件 yaml文件一般存储了ROS需要加载的参数信息, 一些属性的配置, 通常我们会把yaml文件存放在param/路径下 dae/stl文件 dae或stl文件是3D模型问津, 机器人的urdf或仿真环境通常会引用这类文件, 它们描述了机器人的三维模型, 相比urdf简单定义的性状, dae/stl文件可以定义复杂的模型, 可以直接从solidworks或其他建模软件导出机器人装配模型, 从而显示出更加精确的外形 rviz文件 rviz文件本质上是固定格式的文本文件, 其中存储了rviz窗口的配置(显示哪些控件, 视角, 参数), 通常rviz文件不需要我们去手动修改, 而是直接在rviz工具里保存, 下次运行时直接读取 ROS系统架构及概念_ROS计算图ROS计算图ROS计算图内容 ROS会创建一个连接到所有进程的网络, 在系统中的任何节点都可以访问此网络, 并通过该网络与其他节点交互, 获取其他节点发布的信息, 并将自身数据发布到网络上 在这一层中最基本的概念包括: 节点, 节点管理器, 参数服务器, 消息, 服务, 话题和消息记录包 节点 节点是主要的计算执行进程(可执行文件运行时的进程) 如果你想要有一个可以与其他节点进行交互的进程, 那么你需要创建一个节点, 并将此节点连接到ROS网络; 通常情况下, 系统包含能够实现不同功能的多个节点; 你最好让每个节点都具有特定的单一的功能, 而不是在系统中创建一个包罗万象的大节点;节点需要使用如roscpp或rospy的ros客户端库进行编写 节点管理器(master) 节点管理器用于节点的名称注册和查找等; 它也设置节点间的通信; 如果在你的整个ROS系统中没有节点管理器, 就不会有节点, 服务, 消息之间的通信; 需要注意的是, 由于ROS本身就是一个分布式网络系统, 你可以在某一台计算机上运行节点管理器, 在该管理器上或其他计算机上运行节点 注意: 如果master没有运行起来, 其他节点不会运行 两个roscore(master)不能在两个终端中同时运行 rosout节点:因为这个节点用于收集和记录节点调试输出信息, 所以它总是在运行 rosnode命令 消息(message) 节点之间可以通过传送消息进行通讯 每一个消息都是一个严格的数据结构 原来标准的数据类型(整型, 浮点型, 布尔型等等)都是支持的, 同时也支持原始数组类型; 消息可以包含任意的嵌套结构和数组(很类似于C语言的结构structs) msg文件夹中存放消息 话题(topic) 两个节点需要通信, 需要先定义一个共同话题 一个节点可以发布多个话题, 一个节点可以订阅多个话题 topic的名称必须是独一无二的 topic保证了消息的发布者与订阅者的相互解耦, 彼此不需要知晓对方的存在 话题的缺点: 同步性不高 单向通信 案例与应用 rosrun turtlesim turtle_teleop_key, 键盘控制 rqt_graph能够创建一个显示当前系统运行情况的动态图形; rqt_graph是rqt程序包中的一部分 rosrun rqt_graph rqt_graph, 查看节点及话题 rostopic list, 查看所有话题 rostopic echo /turtle/cmd_vel, 输出话题信息 rosrun rqt_graph rqt_graph, 再打开rqt_graph rostopic type 与 rosmsg show 一起使用 rostopic pub [topic] [msg_type] [args], 使用命令发布话题 rostopic pub -1 /turtle1/cmd_vel geometry_msgs/Twist -- &#39;[2.0, 0.0, 0.0]&#39; &#39;[0.0, 0.0, 1.8]&#39;, -1, 表示运行一次 rostopic pub /turtle1/cmd_vel geometry_msgs/Twist -r 1 -- &#39;[2.0, 0.0, 0.0]&#39; &#39;[0.0, 0.0, 1.8]&#39;, 表示频率为1, 每一秒一次 再次运行rqt_graph查看 rostopic hz /turtle1/pose, 查看频率 rostopic type /turtle/cmd_vel | rosmsg show, 查看话题的参数 rqt_plot命令可以实时显示一个发布到某个话题上的数据变化图形; 这里我们将使用rqt_plot命令来绘制正在发布到/turtle1/pose话题上的数据变化图形 rosrun rqt_plot rqt_plot 服务(service) 服务是节点之间通讯的另一种方式; 服务允许节点发送请求, 并获得一个响应 请求/回复交互方式经常被用于分布式系统中; 请求服务通过sevice来进行, service被定义为一对消息结构: 一个用于请求, 一个用于回复 服务(service)与话题(topic)的对比: 名称 topic service 通信方式 异步通信 同步通信 实现原理 TCP/IP TCP/IP 通信模型 Publish-Subscribe Request-Reply 映射关系 多对多 多对一 特点 接受者收到的数据会回调(Callback) 远程过程调用(RPC)服务器端的服务 应用场景 连续, 高频的数据发布 偶尔使用的功能/具体的任务 举例 激光雷达, 里程计发布数据 开关传感器, 拍照, 逆解计算 rosservice 用法: 命令 说明 rosservice args 打印服务的参数 rosservice call 以命令行的形式调用服务, 可以指定具体参数 rosservice find 根据服务类型查找当前服务 rosservice info 打印服务信息 rosservice list 列出当前服务类型 rosservice type 打印服务类型 rosservice uri 打印服务的 ROSRPC uri rossrv 用法(该命令针对的是静态的服务文件*.srv): 命令 说明 rossrv show /srv_name 显示服务类型的所有信息 rossrv list 显示所有服务类型信息 rossrv md5 /srv_name 显示服务类型的md5sum信息(校验) rossrv package 列出一个程序包中的所有服务类型 rossrv packages 列出包含服务的所有程序包 案例与应用 rosservice list, 显示提供的服务 rosservice type [service] rosservice info [service] rossrv show [service] rosservice call [service] [args] rosservice call clear, 清空线 rosservice call /turtle1/set_pen 255 0 0 3 0, 红线 rosservice type spawn | rossrv show, 查看spawn再生服务的信息 rosservice call spawn 2 2 0.2 &quot;turtle2&quot; (x y 角度 名字), 参数 rosservice call kill &quot;name: &#39;turtle2&#39;&quot; (或 `rosservice call kill “turtle2”``) 参数服务器 参数服务器维护一个存储着各种参数的字典, 字典就是为了方便读写一些不常改变的参数, 给它们加上索引, 这个索引是唯一的通过使用参数, 就能够在运行时配置节点或改变节点的工作任务 字典: 键值对 Key /rosdistro /rosversion /use_sim_time … Value ‘kinetic’ ‘1.12.7’ true … rosservice call clear, 清空参数, 设置生效 rospara 命令: 命令 功能 rosparam set 设置参数 rosparam get 获取参数 rosparam load 从文件读取参数 rosparam dump 向文件中写入参数 rosparam delete 删除参数 rosparam list 列出参数名 消息记录包 消息记录包是一种用于保存和回放ROS消息数据的文件格式 消息记录包是一种用于存储数据的重要机制, 它能够获取并记录各种收集的传感器数据 通过消息记录包可以反复获取实验数据, 进行必要的开发计算法测试 rosbag 命令: 命令 作用 check 确定一个包是否可以在当前系统中进行, 或者是否可以迁移 decompress 压缩一个或多个包文件 filter 解压一个或多个包文件 fix 在包文件中修复消息, 以便在当前系统中播放 help 获取相关命令指示帮助信息 info 总结一个或多个包文件的内容 play 以一种时间同步的方式回放一个或多个包文件的内容 record 用指定主题的内容记录一个包文件 reindex 重新索引一个或多个包文件 rosbag受制于其本身的性能无法完全复制录制时的系统运行行为, rosplay也一样用户不应该期望能够完美的模仿系统行为","categories":[{"name":"ROS","slug":"ROS","permalink":"https://didongdongdi.github.io/categories/ROS/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://didongdongdi.github.io/tags/Notes/"}],"author":"DiDong"},{"title":"水下机器人视觉_2_感知机","slug":"水下机器人视觉-2-感知机","date":"2019-09-08T05:17:00.000Z","updated":"2019-09-15T14:01:14.576Z","comments":true,"path":"2019/09/08/水下机器人视觉-2-感知机/","link":"","permalink":"https://didongdongdi.github.io/2019/09/08/%E6%B0%B4%E4%B8%8B%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%A7%86%E8%A7%89-2-%E6%84%9F%E7%9F%A5%E6%9C%BA/","excerpt":"线性模型–分类例子二维","text":"线性模型–分类例子二维 多维 感知机感知机的三种表达方式: 含多个w的感知机的表达方式: 激活函数: 线性函数与激活函数: 感知机与神经元: 第一步:感知机创建了一个函数集(无数多的线性函数)create a function set 误差函数(损失函数) 误差函数用于评价模型的好坏 降低误差高度: 离散 vs. 连续: 误差函数应该是连续和可微的: 离散预测 vs. 连续预测: 离散激活函数 vs. 连续激活函数: 离散的感知机 vs. 连续的感知机: 通过sigmoid函数, 将线性函数的输出结果变为概率: 最大似然法: 交叉熵 最大似然法存在的问题:当数据点很多时, 所得乘积会很小, 不便于比较, 需要转化为加法, 使用log函数 交叉熵公式: 概率, 取对数, 取负数, 求和, 值越小越好交叉熵公式是一种误差公式 误差函数公式 第二步:定义什么样的模型是好的define goodness of function 梯度下降算法 其中:\\(\\alpha\\)称为学习率(learning rate), 用于调整每次迭代的宽度当计算出来的微分小于0时, 增加w; 大于0时, 减少w 第三步:获得最好(次好)的模型get the best function","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://didongdongdi.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://didongdongdi.github.io/tags/Notes/"}],"author":"DiDong"},{"title":"水下机器人视觉_1_介绍","slug":"水下机器人视觉-1-介绍","date":"2019-09-08T05:13:00.000Z","updated":"2019-09-14T23:55:22.028Z","comments":true,"path":"2019/09/08/水下机器人视觉-1-介绍/","link":"","permalink":"https://didongdongdi.github.io/2019/09/08/%E6%B0%B4%E4%B8%8B%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%A7%86%E8%A7%89-1-%E4%BB%8B%E7%BB%8D/","excerpt":"机器人水下机器人水下机器人视觉目标检测 实例分割 人工智能","text":"机器人水下机器人水下机器人视觉目标检测 实例分割 人工智能 发展阶段: 逻辑推理 -&gt; 专家系统 -&gt; 机器学习/深度学习 人工智能: 研究, 开发用于模拟, 延伸和扩展人的智能的理论, 方法, 技术及应用系统的一门新的技术科学 机器学习: 如果一个程序可以在任务T上, 随着经验E增加, 效果P也可以随之增加, 则称这个程序可以从经验中学习 深度学习: 基于深度人工神经网络, 自动地将简单的特征组合成更加复杂的特征, 并使用这些组合特征解决问题 推荐算法的改变: 协同过滤 -&gt; 深度学习 人工智能第三次崛起的三大因素: 算法 大数据(互联网产生的海量大数据) 计算力(CPU, GPU, TPU) cpu和gpu的区别: cpu: 核数较少 单核运算速度较快 gpu: 核数很多 单核运算速度较慢 擅长并行计算 做矩阵运算 经典的程序设计: 数据 + 规则 -&gt; 答案 机器学习: 数据 + 答案 -&gt; 规则 机器学习是通过学习而不是显式编程的方式, 赋予机器解决问题能力的方法training: lableled data -&gt; machine learning algorithm&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vprediction: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data -&gt; learned model -&gt; prediction 机器学习的学习方法: 监督学习(通过标签的训练数据集, 如人脸识别) 无监督学习(通过无标签数据集自动发掘模式, 如文本自聚类) 增强/强化学习(通过反馈或者奖惩罚机制学习, 如游戏, 机器人) 半监督学习以上深度学习都可以做 特征学习: 深度学习的本质之一input data -&gt; feature engineering(特征工程) -&gt; traditional learning algorithm (costs lots of time)input data ———————————-&gt; deep learning algorithm 深度学习学到了什么?图片 -&gt; 底层特征 -&gt; 中层特征 -&gt; 高层特征 -&gt; 分类器 -&gt; …像素 -&gt; 边缘 -&gt; 部件 -&gt; 轮廓 -&gt; 物体 人工提取特征 -&gt; 简单训练分类器 -&gt; 传统人工智能学习特征 -&gt; 学习分类器 -&gt; 深度学习 深度学习大事件 alphago 图像识别(IMAGENET大赛) 语音系统表现力 问答竞赛(自然语言处理) 深度学习应用领域 深度学习应用三大领域: 视觉 语音处理 自然语言处理 看图说话 风格迁移 目标检测 普适的目标检测, 不局限于特定问题(如: 人脸检测) 是什么 目标类别 在哪里 目标位置 评价指标 精度: 分类精度 位置精度 速度 智能安防(人脸检测和生理特征识别) 疾病检测 ocr识别 无人驾驶 物体检测 行人检测 标志识别 速度识别 实例分割 语音处理 自然语言处理 深度学习发展历史 1958 感知机(神经元) -&gt; 1969 感知机被否定 -&gt; 1974 反向传播算法 -&gt; 1995 SVM reigns -&gt; 1998 卷积神经网络(手写数字识别) -&gt; 2006 Restricted Boltzmann Machine -&gt; 2012 imagenet大赛 -&gt; 2012 Google Brain Project on 16k Cores 深度神经网络:多个感知机形成的网络 $$深度学习 \\approx 深度神经网络$$ 深度学习的问题: 端到端学习: 黑盒子, 不具有逻辑可解释性 依赖于大数据, 学习效率低 能耗大, 计算成本高 信息模态单一, 泛化迁移能力差 对抗样本","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://didongdongdi.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://didongdongdi.github.io/tags/Notes/"}],"author":"DiDong"},{"title":"eclipse Unhandled event loop exception No more handles 错误解决","slug":"eclipse-Unhandled-event-loop-exception-No-more-handles-错误解决","date":"2019-09-03T04:04:00.000Z","updated":"2019-09-03T04:10:08.554Z","comments":true,"path":"2019/09/03/eclipse-Unhandled-event-loop-exception-No-more-handles-错误解决/","link":"","permalink":"https://didongdongdi.github.io/2019/09/03/eclipse-Unhandled-event-loop-exception-No-more-handles-%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3/","excerpt":"","text":"将tomcat安装到非root用户下后, 同时将eclipse也安装到同一用户下, 使用该用户的权限启动后, 不再出现该问题 建议以后统一将自定义安装软件安装到普通用户目录下, 而不是root用户","categories":[{"name":"Problem","slug":"Problem","permalink":"https://didongdongdi.github.io/categories/Problem/"}],"tags":[{"name":"java","slug":"java","permalink":"https://didongdongdi.github.io/tags/java/"}],"author":"DiDong"},{"title":"git(hub)项目合作教程","slug":"git-hub-项目合作教程","date":"2019-07-01T06:57:00.000Z","updated":"2019-07-28T03:03:20.730Z","comments":true,"path":"2019/07/01/git-hub-项目合作教程/","link":"","permalink":"https://didongdongdi.github.io/2019/07/01/git-hub-%E9%A1%B9%E7%9B%AE%E5%90%88%E4%BD%9C%E6%95%99%E7%A8%8B/","excerpt":"前言大二小学期的项目终于开始正式起来了, 一起做东西的人也多了, 同时大家对git(hub)的了解也逐渐多了起来, 以及java有C++做铺垫, 相对以前来说, 有更多的时间去考虑项目(代码)管理. git(hub)终于可以发挥其真正的用途.","text":"前言大二小学期的项目终于开始正式起来了, 一起做东西的人也多了, 同时大家对git(hub)的了解也逐渐多了起来, 以及java有C++做铺垫, 相对以前来说, 有更多的时间去考虑项目(代码)管理. git(hub)终于可以发挥其真正的用途. 流程远程库的建立 有了github账号后, new一个远程库 填入库的名称 填入库的描述, 如果在后面勾选了README, 则描述会添加到README中 选择公开库就好(私有库只支持3人及以下免费, 支持无限创建, 虽然说以前完全不免费. 有个有钱的微软爸爸就是好啊(滑稽)! 而且, 学生项目没有必要, 开源学习就好.) 由于是新开启了一个项目, 可以勾选生成README; 如果是一个已经存在的项目, 这里不用勾选, 可以在项目根目录中再添加, 以及下面两个步骤都要忽略, 否则会在push和pull的时候起冲突, 也可通过合并本地仓库和远程仓库解决冲突 选择.gitignore文件对应的项目编程语言, 关于.gitignore文件参考https://www.liaoxuefeng.com/wiki/896043488029600/900004590234208, 不同的编程语言有不同的模板, 可参考https://github.com/github/gitignore 添加license, 关于不同开源项目协议的选择, 参考下面的图片 如果想更换协议, 或是在原有项目的基础上添加协议, 参考https://www.cnblogs.com/chenmingjun/p/8555906.html 添加协作者, 在远程库setting - Collaborators中添加协作者 本地仓库的建立在新开启一个项目的情况下, git clone &lt;刚建立的远程仓库的地址&gt;, 克隆远程仓库, 建议使用ssh协议 或者 在已有项目的基础上, 进入项目根目录, git init, 创建本地仓库 开始开发在仓库根目录下, 开始项目开发后, 或者已有项目的基础上 git add *提交所有更改到缓存区, 或者, git add &lt;文件路径&gt;提交该文件的更改到缓存区 有些时候git add *可能不管用, 使用git status查看库的状态, 如果有文件没有提交到缓存区, 单独提交一下即可 git commit -m &lt;提交的描述&gt;, 在所有文件提交到缓存区后, 需要再做一次对整体的提交, 这才是真正的提交了, 同时注意写明这一次提交的描述 git push origin master, 推送主分支的更改到远程库, 关于分支的内容, 由于项目较简单, 故暂不应用 git pull, 拉取远程库的更改 其他更多git(hub)的内容参考最后的链接 其他刚安装完git后, 需要设置github的账户和密码, 按照git给出的提示设置即可 git remote add origin &lt;github仓库地址&gt;, 将本地的仓库连接到某个远程服务器, 用于本地仓库不是从远程库克隆而来. 本地仓库和远程仓库冲突时, 参考https://blog.csdn.net/M87138/article/details/44921583, 如果冲突无法自动合并, 则需要通过手动合并来解决 如果push的时候总是需要输入用户名和密码, 原因是未采用ssh方式来克隆仓库; 如果就是希望使用https方式来克隆仓库, 参考https://blog.csdn.net/nongweiyilady/article/details/77772602 最后git教程参考https://www.liaoxuefeng.com/wiki/896043488029600 git使用简易指南参考http://www.bootcss.com/p/git-guide/","categories":[{"name":"Git","slug":"Git","permalink":"https://didongdongdi.github.io/categories/Git/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://didongdongdi.github.io/tags/%E6%95%99%E7%A8%8B/"}],"author":"DiDong"},{"title":"vim下写java","slug":"vim下写java","date":"2019-06-25T06:23:00.000Z","updated":"2019-07-28T03:08:37.052Z","comments":true,"path":"2019/06/25/vim下写java/","link":"","permalink":"https://didongdongdi.github.io/2019/06/25/vim%E4%B8%8B%E5%86%99java/","excerpt":"前言由于已经习惯了vim下的各种姿势, 刚开始学习java时虽然有很多优秀的IDE可以选, 但本着vim下一切皆有可能, 一切都可编辑的本性, 尝试着配置vim, 使其足以应付java的学习.","text":"前言由于已经习惯了vim下的各种姿势, 刚开始学习java时虽然有很多优秀的IDE可以选, 但本着vim下一切皆有可能, 一切都可编辑的本性, 尝试着配置vim, 使其足以应付java的学习. 文件编译运行单文件 直接vim Test.java 由于之前已经安装了YCM, 所以有基本的java关键字补全, 但远远不够 编译和运行时, 需要退出vim或者使用!javac Test.java和!java Test, 或者切换到另外一个命令行执行, 虽然可以使用历史命令, 但依旧很不方便 于是, 在~/.vimrc文件中添加如下内容: 12\" java代码编译执行autocmd BufNewFile,BufReadPre *.java nnoremap &lt;leader&gt;cr :w&lt;cr&gt;:!javac %&lt;cr&gt;:!java %:r&lt;cr&gt; normal模式下;cr直接编译执行 多文件 如果多个关联的文件放在一个目录下, 为了编译执行方便, 在~/.vimrc中添加如下内容: 1autocmd BufNewFile,BufReadPre *.java nnoremap &lt;leader&gt;cra :w&lt;cr&gt;:!javac *.java&lt;cr&gt;:!java Main&lt;cr&gt; 注意! main方法必须在Main.java文件中. normal模式下;cr直接编译执行 java工程管理采用eclim java代码补全只有关键字的补全太鸡肋, 只能借助eclim java代码调试jdk中有jdb工具调试, 但是可能我觉得System.out.println(&quot; &quot;);更好用? eclim安装配置及使用安装 以下安装过程参考自官方文档 准备条件 jdk1.8或者更高版本, 我的是jdk11 这个可以直接通过apt安装(主要是官方包下载太慢), 参考https://blog.51cto.com/vvxyz/1642258 vim7.1或者更高版本, 我的是vim8.1 vim中, 如果:echo &amp;compatible输出不为0 同时:filetype输出不为filetype detection:ON plugin:ON indent:ON 需要在~/.vimrc文件中添加: 12set nocompatiblefiletype plugin indent on eclipse4.8.x(Photon), 这个包不是很大, 但是鉴于国内网速太慢, 请自备梯子, 也可以通过其他方式下载, 只要清楚eclipse的安装位置 (虽然只有安装了eclipse才能安装eclim, 貌似明明可以使用eclipse却偏不用, 但是vim好用啊) python(2.7或3.x) make gcc eclim github项目地址 开始安装 首先需要给下好的bin文件添加执行权限, chmod +x eclim_2.8.0.bin 由于安装时需要联网验证, 而国内又不允许, 所以请自备梯子代理 ./eclim_2.8.0.bin --proxy 127.0.0.1:1080 或者 ./eclim_2.8.0.bin --proxy user:password@127.0.0.1:1080 ip地址和端口号请自行更改 然后, 就可以安装安装提示, 进行输入安装了 其他更多安装以及更新以及卸载方式, 请参考eclim官网安装教程 配置由于eclim是通过运行服务器来处理请求, 所以需要先运行eclim服务, 找到eclimd运行程序的路径(在安装eclim时告诉了你) 为了以后执行方便, 可以alias eclimd=&#39;/home/didong/eclipse/committers-2019-06/eclipse/eclimd&#39;, 将其放在/etc/bash.bashrc中, 设置永久别名 甚至为了方便, 可以在/etc/rc.local文件中设置开机自启 eclimd -b可设置后台启动 java代码补全在安装了YCM的前提下, 在~/.vimrc中添加let g:EclimCompletionMethod = &#39;omnifunc&#39; 注意, java的代码补全只能在工程java文件中使用 如果没有安装YCM, 或者安装了其他的第三方补全插件, 参考http://eclim.org/vim/code_completion.html 使用简单工程管理 官网入门教程 :ProjectCreate ./my_java_project -n java, 创建一个java工程, 也可以创建其他类型的工程, 详情参考官网入门教程 在创建项目后, 会有一个.project 文件添加到项目的根目录, 以及另外一个文件(java为.classpath文件)由于引用项目的源目录和项目使用的任何第三方库, 其他语言的文件类型, 请参考官方入门教程 :ProjectList列出可用项目 :NewSrcEntry src/java添加名为java的源目录, 这会在.classpath文件的末尾添加必要的条目&lt;classpathentry kind=&quot;src&quot; path=&quot;src/java&quot;/&gt;, 注意, 依旧需要自己通过mkdir创建目录 :Java运行代码 代码格式化:JavaFormat, 格式化当前行或visual模式下选中行 :%JavaFormat, 格式化整个文件 重命名将光标放到希望重命名的元素上, :JavaRename 新名即可 类型创建 class (a new class) interface (a new interface) abstrac (a new abstract class) enum (a new enum) @interface (a new annotation) :JavaNew class MyNewClass 其他更多参考http://eclim.org/vim/java/index.html 参考内容https://www.jianshu.com/p/b0fb705c171a https://segmentfault.com/a/1190000005642590 eclim.org","categories":[{"name":"vim","slug":"vim","permalink":"https://didongdongdi.github.io/categories/vim/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://didongdongdi.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"java","slug":"java","permalink":"https://didongdongdi.github.io/tags/java/"}],"author":"DiDong"},{"title":"shell笔记","slug":"shell笔记","date":"2019-06-06T14:17:00.000Z","updated":"2019-07-28T03:09:11.098Z","comments":true,"path":"2019/06/06/shell笔记/","link":"","permalink":"https://didongdongdi.github.io/2019/06/06/shell%E7%AC%94%E8%AE%B0/","excerpt":"参考自https://www.runoob.com/linux/linux-shell.html 运行shell脚本 作为可执行程序, ./test.sh, 注意添加#!/bin/bash标记, 打开一个子shell来读取并执行test.sh中的命令, 需要”执行权限” 作为解释器参数bash test.sh, 打开一个子shell来读取并执行test.sh中的命令, 可以无”执行权限” source命令, source test.sh, 在当前bash环境下读取并执行test.sh中的命令, 可以无”执行权限”","text":"参考自https://www.runoob.com/linux/linux-shell.html 运行shell脚本 作为可执行程序, ./test.sh, 注意添加#!/bin/bash标记, 打开一个子shell来读取并执行test.sh中的命令, 需要”执行权限” 作为解释器参数bash test.sh, 打开一个子shell来读取并执行test.sh中的命令, 可以无”执行权限” source命令, source test.sh, 在当前bash环境下读取并执行test.sh中的命令, 可以无”执行权限” shell变量赋值 显式赋值 注意: 变量名和等号之间不能有空格 your_name=&quot;didong&quot; 语句赋值 123for file in `ls /etc`或for file in $(ls /etc) 使用1234your_name=\"didong\"echo $your_name或echo $&#123;your_name&#125; 注意: 花括号可选, 但花括号可以用来识别变量边界, 比如: 123for skill in Ada Coffe Action Java; do echo \"I am good at $&#123;skill&#125;Script\"done 只读变量readonly your_name, 将变量设为只读 删除变量unset your_name, 删除变量, 但不能删除只读变量 变量类型 局部变量 在脚本或命令中定义, 仅在当前shell示例中有效, 其他shell启动的程序不能访问局部变量 环境变量 所有的程序, 包括shell启动的程序, 都能访问环境变量, 有些程序需要环境变量来保证其正常运行; 必要的时候shell脚本也可以定义环境变量. shell变量 shell变量是由shell程序设置的特殊变量; shell变量中有一部分是环境变量, 有一部分是局部变量, 这些变量保证了shell的正常运行 字符串单引号 限制: 单引号里的任何字符都会原样输出, 单引号字符串中的变量是无效的 单引号字串中不能出现单独一个单引号(对单引号使用转义符后也不行), 但可成对出现, 作为字符串拼接使用 双引号 优点: 双引号里可以有变量 双引号里可以出现转义字符 拼接字符串123456789your_name=\"runoob\"# 使用双引号拼接greeting=\"hello, \"$your_name\" !\"greeting_1=\"hello, $&#123;your_name&#125; !\"echo $greeting $greeting_1# 使用单引号拼接greeting_2='hello, '$your_name' !'greeting_3='hello, $&#123;your_name&#125; !'echo $greeting_2 $greeting_3 输出结果: 12hello, runoob ! hello, runoob !hello, runoob ! hello, $&#123;your_name&#125; ! 获取字符串长度12string=\"abcd\"echo $&#123;#string&#125; #输出 4 或使用length: 12string=\"hello, everyone my name is didong\"expr length \"$string\" 使用expr命令时, 表达式中的运算符左右必须包含空格, 如果不包含空格, 将会输出表达式本身对于某些运算符, 还需要我们使用\\进行转义, 否则会提示语法错误, 如* expr命令expr命令是一个手工命令行计数器, 用于求表达式变量的值, 一般用于整数值, 也可用于字符串 语法: expr 表达式 详细内容直接man 提取子字符串从字符串第 2 个字符开始截取 4 个字符(从0开始计数): 12345string=\"runoob is a great site\"echo $&#123;string:1:4&#125; # 输出 unooecho $&#123;string:4&#125; # 输出 runoecho $&#123;string:0-4:3&#125; # 0-4表示从右边算起第四个字符开始, 3表示字符个数, 输出sitecho $&#123;string:0-4&#125; # 输出site 字符串截取设有变量var=http://qiniu.wangqy.top/didong/images/ #号截取, 删除左边字符, 保留右边字符 echo ${var#*//} 从左边开始删除第一个//号及左边的所有字符 ##号截取, 删除左边字符, 保留右边字符 echo ${var##*/} 从左边开始删除最后(最右边)一个/号及左边所有字符 %号截取, 删除右边字符, 保留左边字符 echo ${var%/*} 从左边开始删除第一个/号及右边字符 %%号截取, 删除右边字符, 保留左边字符 echo ${var%%/*} 从左边开始, 删除最后(最左边)一个/号及右边的字符 查找子字符查找字符 i 或 o 的位置(哪个字母先出现就计算哪个)： 12string=\"runoob is a great site\"echo `expr index \"$string\" io` # 输出 4 注意: 这里的输出是从 1 开始计数 数组只支持一维数组, 不支持多位数组, 并且没有限定数组的大小, 数组下标由0开始 定义12345678array_name=(value0 value1 value2 value3)# 或array_name=(value0value1value2value3) 下标的范围没有限制 读取12valuen=$&#123;array_name[n]&#125; # 单个元素echo $&#123;array_name[@]&#125; # 使用 @或* 获取所有元素 获取数组长度123456# 取得数组元素的个数length=$&#123;#array_name[@]&#125;# 或者length=$&#123;#array_name[*]&#125;# 取得数组单个元素的长度lengthn=$&#123;#array_name[n]&#125; Bourne shell (原生kernel下) 下不支持数组, 只能通过模拟来实现数组功能12345678910#!/bin/sh#注意不是/bin/bashecho \"##############使用eval函数###############\"eval a1=bilieval a2=nicoeval a3=yamafor i in 1 2 3 ; do eval echo \"\\$a$i\"done eval函数语法: eval cmdline eval会对后面的cmdline进行两遍扫描, 如果第一遍扫描后, cmdline是个普通命令, 则执行此命令; 如果cmdline中含有变量的间接引用, 则保证间接引用的语义 注释单行1# 这是注释 多行 可以把这一段要注释的代码用一对花括号括起来，定义成一个函数，没有地方调用这个函数，这块代码就不会执行，达到了和注释一样的效果 如下: 1234567891011121314151617181920:&lt;&lt;EOF注释内容...注释内容...注释内容...EOF###########或:&lt;&lt;'注释内容...注释内容...注释内容...'###########或:&lt;&lt;!注释内容...注释内容...注释内容...!###########或# 等等# 其中符号可以更换 read命令用于获取键盘输入信息read [-options] [variable...] read命令一个一个词组地接受输入的参数, 每个词组需要使用空格进行分隔; 如果输入的词组个数大于需要的参数个数, 则多出的词组将被作为整体为最后一个参数接收 参数 | 说明-p | 输入提示文字-n | 输入字符长度限制-t | 输入限时-s | 隐藏输入内容 12read -p \"请输入一段文字:\" -n 6 -t 5 -s passwordecho -e \"\\npassword is $password\" 输出结果: 12请输入一段文字:password is didong 传递参数 传递参数: 执行shell脚本时, 向脚本传递参数获取参数: $n, 0为脚本文件名, 1为第一个参数, 2为第二个参数, 以此类推… 特殊参数处理字符 参数处理 说明 $# 传递到脚本的参数个数 $* 以一个单字符串显示所有向脚本传递的参数 $$ 脚本运行的当前进程id号 $! 后台运行的最后一个进程的id号 $@ 与$*相同, 但使用时加引号, 并在引号中返回每个参数 $- 显示shell使用的当前选项, 与set命令功能相同 $? 显示最后命令的退出状态, 0表示没有错误, 其他任何值表示有错误 注意: 传递的参数中如果包含空格, 应该使用单引号或者双引号将该参数括起来, 以便于脚本将这个参数作为整体来接收 中括号的用法[]常常可以使用test命令来代替 [与]与操作数之间一定要有一个空格, 否则会报错 算数比较12[ $var -eq 0 ] # 当 $var 等于 0 时, 返回真[ $var -ne 0 ] # 当 $var 不等于 0 时, 返回真 其他比较操作符: 操作符 说明 -gt 大于 -lt 小于 -ge 大于或等于 -le 小于或等于 文件系统属性测试操作符 | 说明[ -f $file_var ] | 变量 $file_var 是一个正常的文件路径或文件名 (file), 则返回真[ -x $var ] | 变量 $var 包含的文件可执行 (execute), 则返回真[ -d $var ] | 变量 $var 包含的文件是目录 (directory), 则返回真[ -e $var ] | 变量 $var 包含的文件存在 (exist), 则返回真[ -c $var ] | 变量 $var 包含的文件是一个字符设备文件的路径 (character), 则返回真[ -b $var ] | 变量 $var 包含的文件是一个块设备文件的路径 (block), 则返回真[ -w $var ] | 变量 $var 包含的文件可写(write), 则返回真[ -r $var ] | 变量 $var 包含的文件可读 (read), 则返回真[ -L $var ] | 变量 $var 包含是一个符号链接 (link), 则返回真 字符串比较在进行字符串比较时, 最好使用双中括号[[ ]], 因为单中括号可能会导致一些错误, 因此最好避开它们 操作符 说明 [[ $str1 = $str2 ]] 当 str1等于str2 时返回真, =前后有空格, 如果不加空格, 就变成了赋值语句 [[ $str1 == $str2 ]] 同上 [[ $str1 != $str2 ]] 如果 str1 与 str2 不相同, 则返回真 [[ -z $str1 ]] 如果 str1 是空字符串, 则返回真 [[ -n $str1 ]] 如果 str1 是非空字符串, 则返回真 组合中括号中可以通过-a(and)或-o(or)结合多个条件进行测试: 12[ $var1 -ne 0 -a $var2 -gt 2 ] # 使用逻辑与 -a[ $var1 -ne 0 -o $var2 -gt 2 ] # 使用逻辑或 -o 中括号外使用逻辑运算符&amp;&amp;和||将多个条件组合起来: 123456str1=\"Not empty\"str2=\"\"if [[ -n $str1 ]] &amp;&amp; [[ -z $str2 ]];then echo str1 is nonempty and str2 is empty string.fi test命令test命令也可以执行条件检测, 用test可以避免使用过多的括号, 如: if [ $var -eq 0 ]; then echo &quot;True&quot;; fi 等价于: if test $var -eq 0; then echo &quot;True&quot;; fi set命令功能用于设置shell的执行方式 语法set [+-abCdefhHklmnpPtuvx] 参数说明 参数 说明 a 标示已修改的变量, 以供输出至环境变量 b 使被中止的后台程序立刻回报执行状态 C 转向所产生的文件无法覆盖已存在的文件 d Shell预设会用杂凑表记忆使用过的指令, 以加速指令的执行; 使用-d参数可取消 e 若指令回传值不等于0, 则立即退出shell f 取消使用通配符 h 自动记录函数的所在位置 H 可利用!加&lt;指令编号&gt;的方式来执行history中记录的指令 k 指令所给的参数都会被视为此指令的环境变量 l 记录for循环的变量名称 m 使用监视模式 n 只读取指令, 而不实际执行 p 启动优先顺序模式 P 执行指令时, 会以实际的文件或目录来取代符号连接 t 执行完随后的指令, 即退出shell u 当执行时使用到未定义过的变量, 则显示错误信息 v 显示shell所读取的输入值 x 执行指令后, 会显示该指令及所下的参数 +&lt;参数&gt; 取消某个set曾启动的参数 基本运算符原生bash不支持简单的数学运算, 但是可以通过其他命令来实现, 如awk和expr, expr最常用 算数运算符+ - * / % = == != 关系运算符关系运算符只支持数字, 不支持字符串, 除非字符串的值是数值 参照算数比较部分 布尔运算符注: 变量a为10, b为20 运算符 说明 举例 ! 非运算 [ ! false ] 返回 true -o 或运算 [ $a -lt 20 -o $b -gt 100 ] 返回 true -a 与运算 [ $a -lt 20 -a $b -gt 100 ] 返回 false 逻辑运算符 运算符 说明 &amp;&amp; 逻辑的AND &#124;&#124; 逻辑的OR 字符串运算符变量a为”abc”, b为”efg” 运算符 | 说明 | 举例= | 相等 | [ $a = $b ] 返回 false!= | 不相等 | [$a != $b ] 返回 true-z | 检测字符串长度是否为0, 为0返回true | [ -z $a ] 返回 false-n | 检测字符串长度是否为0, 不为0返回true | [ -n $a ]返回 true$ | 检测字符串是否为空, 不为空返回true | [ $a ]返回 true 文件测试运算符用于检测Unix文件的各种属性 操作符 | 说明-b file | 检测文件是否是块设备, 如果是, 则返回true-c file | 检测文件是否是字符设备文件, 如果是, 则返回true-d file | 检测文件是否是目录, 如果是, 则返回true-f file | 检测文件是否是普通文件(既不是目录也不是设备文件), 如果是, 则返回true-g file | 检测文件是否设置了SGID位, 如果是, 则返回true-k file | 检测文件是否设置了粘着位(Sticky Bit), 如果是, 则返回true-p file | 检测文件是否是有名管道, 如果是, 则返回true-u file | 检测文件是否设置了SUID位, 如果是, 则返回true-r file | 检测文件是否可读, 如果是, 则返回true-w file | 检测文件是否可写, 如果是, 则返回true-x file | 检测文件是否可执行, 如果是, 则返回true-s file | 检测文件是否为空(文件大小是否大于0), 不为空返回true-e file | 检测文件(包括目录)是否存在, 如果是, 则返回true-S file | 判断某文件是否socket-L file | 检测文件是否存在并且是一个符号链接 其他 使用[[ ... ]]条件判断结构, 而不是[ ... ], 能够防止脚本中的许多逻辑错误. 比如, &amp;&amp;, ||, &lt;和&gt;操作附能够正常存在于[[]]条件判断结构中, 但是如果出现在[]结构中的话, 会报错 使用[]时, &gt;和&lt;需要使用反斜线转义 相加的写法 1. 1234a=10b=20c=`expr $&#123;a&#125; + $&#123;b&#125;`echo \"$c\" 2. 12c=$&#123; `expr 10 + 20` &#125;echo \"$c\" 3. 12c=$[ 10 + 20]echo \"$c\" 4. 123a=10b=20c=$(($a+$b)) echo命令 显示普通字符串 echo &quot;It is a test&quot; 双引号可省略 echo It is a test 显示转义字符 echo &quot;\\&quot;It is a test\\&quot;&quot; 结果为 &quot;It is a test&quot; 同样, 双引号也可以省略 显示变量 read 命令从标准输入中读取一行, 并把输入行的每个字段的值指定给shell变量 12read nameecho \"$name It is a test\" 显示换行 12echo -e \"OK! \\n\" # -e 开启转义echo \"It is a test\" 输出结果: 123OK!It is a test 显示不换行 12echo -e \"OK! \\c\"echo \"It is a test\" 输出结果: 1OK! It is a test 显示结果定向至文件 1echo \"It is a test\" &gt; myfile 原样输出字符串, 不进行转义或取变量(用单引号) 1echo '$name\\\"' 输出结果: 1$name\\\" 显示命令执行结果(反引号) 1echo `date` 结果将显示当前日期 总结能否引用变量 | 能否引用转义符 | 能否引用文本格式符(如: 换行符, 制表符)单引号 | 否 | 否 | 否双引号 | 能 | 能 | 能无引号 | 能 | 能 | 否 printf命令printf由POSIX标准所定义, 因此使用printf的脚本比使用echo移植性好 printf使用引用文本或空格分割的参数 语法; printf format-string [arguments...] 具体格式化字符串参照C中的printf()函数 注意: 单引号与双引号效果一样 没有引号也可以输出 格式只指定了一个参数, 但多出的参数仍然会安装该格式输出, format-string被重用 如果没有arguments, 那么 %s 用 NULL 代替, %d 用 0 代替 流程控制和Java, PHP等语言不一样, sh的流程控制不可为空, 如果else分支没有语句执行, 就不要写这个else if elseif1234567if conditionthen command1 command2 ... commandNfi 也可以写成一行(每行命令末尾要加分号) if else123456789if conditionthen command1 command2 ... commandNelse commandfi if else-if else123456789if conditionthen command1elif condition2then command2else commandNfi for循环1234567for var in item1 item2 ... itemNdo command1 command2 ... commandNdone 也可以写成一行(每行命令末尾要加分号) 类似于C中的for循环 1234567for((assignment;condition;next));do command1; command2; ... commandN;done; 注意: 如果要在循环体中进行for中的next操作, 记得变量要加$, 不然程序会变成死循环 while语句123while conditiondo commanddone let命令let命令是BASH中用于计算的工具, 用于执行一个或多个表达式, 变量计算中不需要加上$来表示变量. 如果表达式中包含了空格或其他特殊字符, 则必须引起来. 语法格式: let arg [arg ...], 其中arg为要执行的表达式 与C/C++表达式类似 无限循环1234while :do commanddone 或者 1234while truedo commanddone 或者 1for (( ; ; )) until循环until循环执行一系列命令直至条件为true时停止, while循环执行一系列命令直至条件为false时停止 1234until conditiondo commanddone case 语句1234567891011121314case 值 in 模式1) command1 command2 ... commandN ;; 模式2) command1 command2 ... commandN ;;esac 如果没有匹配的模式, 使用*捕获该值 跳出循环breakcontinueshell函数12345[ function ] funname [()]&#123; action; [return int;]&#125; 说明: 可以带function funname()定义, 也可以直接funname()定义, 不带任何参数 参数返回, 可以显示加return返回, 如果不加, 将以最后一条命令运行结果, 作为返回值, return后跟数值n(o-255) funname调用函数 输入/输出重定向 命令 说明 command &gt; file 将输出重定向到file command &lt; file 将输入重定向到file command &gt;&gt; file 将输出以追加的方式重定向到file n &gt; file 将文件描述符为n的文件重定向到file n &gt;&gt; file 将文件描述符为n的文件以追加的方式重定向到file n &gt;&amp; m 将输出文件m和n合并 n &lt;&amp; m 将输入文件m和n合并 &lt;&lt; tag 将开始标记tag和结束标记tag之间的内容作为输入 文件描述符0通常是标准输入(STDIN), 1是标准输出(STDOUT), 2是标准错误输出(STDERR) command1 &lt; infile &gt; outfile同时替换输入和输出, 执行command1, 从文件infile读取内容, 然后将输出写入到outfile中 如果希望stderr重定向到filecommand 2 &gt; file如果希望stderr追加到file文件末尾command 2 &gt; file 如果希望将stdout和stderr合并后重定向到filecommand &gt; file 2&gt;&amp;1或者command &gt;&gt; file 2&gt;&amp;1 Here Document123command &lt;&lt; delimiter documentdelimiter 将两个delimiter之间的内容(documnet)作为输入传递给command结尾的delimiter一定要顶格写, 前面不能有任何字符, 后面也不能有任何字符, 包括空格和tab缩进开始的delimiter前后的空格会被忽略掉 示例: 123456wc -l &lt;&lt; EOF DIDA LAB DiDongEOF3 # 输出结果为3行 /dev/null文件 如果希望执行某个命令, 但又不希望在屏幕上显示输出结果, 那么可以将输出重定向到/dev/nullcommand &gt; /dev/null/dev/null是一个特殊的文件, 写入到它的内容都会被丢弃; 如果尝试从该文件读取内容, 什么也读不到如果希望屏蔽stdout和stderrcommand &gt; /dev/null 2&gt;&amp;1 顺序问题1234find /etc -name .bashrc &gt; list 2&gt;&amp;1# 和find /etc -name .bashrc 2&gt;&amp;1 &gt; list# 之间的区别 第一种先要将输出到stdout的内容重定向到文件, 此时文件list就是这个程序的stdout, 再将stderr重定向到stdout, 也就是文件list第二种先将要输出的stderr的内容重定向到stdout, 此时会产生一个stdout拷贝, 作为程序的stderr, 而程序原本要输出到stdout的内容, 依然是对接在stdout原身上的, 因此第二步重定向stdout, 对stdout的拷贝不产生任何影响 其他问题 直接在FreeBSD或者csh中使用command &gt; file 2&gt;&amp;1的时候会得到这个错误:Ambiguous output redirect. 出错的原因在于FreeBSD默认使用csh, 在csh中如果想把标准输出和错误输出同时重定向到一个文件, 需要用command &gt;&amp; file shell文件包含包含外部脚本, 方便封装一些公用的代码作为一个独立的文件 123. filename# 或source filename 被包含的文件不需要可执行权限","categories":[{"name":"Linux","slug":"Linux","permalink":"https://didongdongdi.github.io/categories/Linux/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://didongdongdi.github.io/tags/Notes/"}],"author":"DiDong"},{"title":"操作系统笔记_2_实验1_答案","slug":"操作系统笔记-2-实验1-答案","date":"2019-06-06T09:12:00.000Z","updated":"2019-07-28T03:09:55.698Z","comments":true,"path":"2019/06/06/操作系统笔记-2-实验1-答案/","link":"","permalink":"https://didongdongdi.github.io/2019/06/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0-2-%E5%AE%9E%E9%AA%8C1-%E7%AD%94%E6%A1%88/","excerpt":"Lab1 report[练习1][练习1.1] 操作系统镜像文件 ucore.img 是如何一步一步生成的?(需要比较详细地解释 Makefile 中每一条相关命令和命令参数的含义,以及说明命令导致的结果)","text":"Lab1 report[练习1][练习1.1] 操作系统镜像文件 ucore.img 是如何一步一步生成的?(需要比较详细地解释 Makefile 中每一条相关命令和命令参数的含义,以及说明命令导致的结果) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133bin&#x2F;ucore.img| 生成ucore.img的相关代码为| $(UCOREIMG): $(kernel) $(bootblock)| $(V)dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;$@ count&#x3D;10000| $(V)dd if&#x3D;$(bootblock) of&#x3D;$@ conv&#x3D;notrunc| $(V)dd if&#x3D;$(kernel) of&#x3D;$@ seek&#x3D;1 conv&#x3D;notrunc|| 为了生成ucore.img，首先需要生成bootblock、kernel||&gt; bin&#x2F;bootblock| | 生成bootblock的相关代码为| | $(bootblock): $(call toobj,$(bootfiles)) | $(call totarget,sign)| | @echo + ld $@| | $(V)$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 $^ \\| | -o $(call toobj,bootblock)| | @$(OBJDUMP) -S $(call objfile,bootblock) &gt; \\| | $(call asmfile,bootblock)| | @$(OBJCOPY) -S -O binary $(call objfile,bootblock) \\| | $(call outfile,bootblock)| | @$(call totarget,sign) $(call outfile,bootblock) $(bootblock)| || | 为了生成bootblock，首先需要生成bootasm.o、bootmain.o、sign| || |&gt; obj&#x2F;boot&#x2F;bootasm.o, obj&#x2F;boot&#x2F;bootmain.o| | | 生成bootasm.o,bootmain.o的相关makefile代码为| | | bootfiles &#x3D; $(call listf_cc,boot) | | | $(foreach f,$(bootfiles),$(call cc_compile,$(f),$(CC),\\| | | $(CFLAGS) -Os -nostdinc))| | | 实际代码由宏批量生成| | | | | | 生成bootasm.o需要bootasm.S| | | 实际命令为| | | gcc -Iboot&#x2F; -fno-builtin -Wall -ggdb -m32 -gstabs \\| | | -nostdinc -fno-stack-protector -Ilibs&#x2F; -Os -nostdinc \\| | | -c boot&#x2F;bootasm.S -o obj&#x2F;boot&#x2F;bootasm.o| | | 其中关键的参数为| | | -ggdb 生成可供gdb使用的调试信息。这样才能用qemu+gdb来调试bootloader or ucore。| | | -m32 生成适用于32位环境的代码。我们用的模拟硬件是32bit的80386，所以ucore也要是32位的软件。| | | -gstabs 生成stabs格式的调试信息。这样要ucore的monitor可以显示出便于开发者阅读的函数调用栈信息| | | -nostdinc 不使用标准库。标准库是给应用程序用的，我们是编译ucore内核，OS内核是提供服务的，所以所有的服务要自给自足。| | | -fno-stack-protector 不生成用于检测缓冲区溢出的代码。这是for 应用程序的，我们是编译内核，ucore内核好像还用不到此功能。| | | -Os 为减小代码大小而进行优化。根据硬件spec，主引导扇区只有512字节，我们写的简单bootloader的最终大小不能大于510字节。| | | -I&lt;dir&gt; 添加搜索头文件的路径| | | | | | 生成bootmain.o需要bootmain.c| | | 实际命令为| | | gcc -Iboot&#x2F; -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc \\| | | -fno-stack-protector -Ilibs&#x2F; -Os -nostdinc \\| | | -c boot&#x2F;bootmain.c -o obj&#x2F;boot&#x2F;bootmain.o| | | 新出现的关键参数有| | | -fno-builtin 除非用__builtin_前缀，| | | 否则不进行builtin函数的优化| || |&gt; bin&#x2F;sign| | | 生成sign工具的makefile代码为| | | $(call add_files_host,tools&#x2F;sign.c,sign,sign)| | | $(call create_target_host,sign,sign)| | | | | | 实际命令为| | | gcc -Itools&#x2F; -g -Wall -O2 -c tools&#x2F;sign.c \\| | | -o obj&#x2F;sign&#x2F;tools&#x2F;sign.o| | | gcc -g -Wall -O2 obj&#x2F;sign&#x2F;tools&#x2F;sign.o -o bin&#x2F;sign| || | 首先生成bootblock.o| | ld -m elf_i386 -nostdlib -N -e start -Ttext 0x7C00 \\| | obj&#x2F;boot&#x2F;bootasm.o obj&#x2F;boot&#x2F;bootmain.o -o obj&#x2F;bootblock.o| | 其中关键的参数为| | -m &lt;emulation&gt; 模拟为i386上的连接器| | -nostdlib 不使用标准库| | -N 设置代码段和数据段均可读写| | -e &lt;entry&gt; 指定入口| | -Ttext 制定代码段开始位置| || | 拷贝二进制代码bootblock.o到bootblock.out| | objcopy -S -O binary obj&#x2F;bootblock.o obj&#x2F;bootblock.out| | 其中关键的参数为| | -S 移除所有符号和重定位信息| | -O &lt;bfdname&gt; 指定输出格式| || | 使用sign工具处理bootblock.out，生成bootblock| | bin&#x2F;sign obj&#x2F;bootblock.out bin&#x2F;bootblock||&gt; bin&#x2F;kernel| | 生成kernel的相关代码为| | $(kernel): tools&#x2F;kernel.ld| | $(kernel): $(KOBJS)| | @echo + ld $@| | $(V)$(LD) $(LDFLAGS) -T tools&#x2F;kernel.ld -o $@ $(KOBJS)| | @$(OBJDUMP) -S $@ &gt; $(call asmfile,kernel)| | @$(OBJDUMP) -t $@ | $(SED) &#39;1,&#x2F;SYMBOL TABLE&#x2F;d; s&#x2F; .* &#x2F; &#x2F;; \\| | &#x2F;^$$&#x2F;d&#39; &gt; $(call symfile,kernel)| | | | 为了生成kernel，首先需要 kernel.ld init.o readline.o stdio.o kdebug.o| | kmonitor.o panic.o clock.o console.o intr.o picirq.o trap.o| | trapentry.o vectors.o pmm.o printfmt.o string.o| | kernel.ld已存在| || |&gt; obj&#x2F;kern&#x2F;*&#x2F;*.o | | | 生成这些.o文件的相关makefile代码为| | | $(call add_files_cc,$(call listf_cc,$(KSRCDIR)),kernel,\\| | | $(KCFLAGS))| | | 这些.o生成方式和参数均类似，仅举init.o为例，其余不赘述| |&gt; obj&#x2F;kern&#x2F;init&#x2F;init.o| | | 编译需要init.c| | | 实际命令为| | | gcc -Ikern&#x2F;init&#x2F; -fno-builtin -Wall -ggdb -m32 \\| | | -gstabs -nostdinc -fno-stack-protector \\| | | -Ilibs&#x2F; -Ikern&#x2F;debug&#x2F; -Ikern&#x2F;driver&#x2F; \\| | | -Ikern&#x2F;trap&#x2F; -Ikern&#x2F;mm&#x2F; -c kern&#x2F;init&#x2F;init.c \\| | | -o obj&#x2F;kern&#x2F;init&#x2F;init.o| | | | 生成kernel时，makefile的几条指令中有@前缀的都不必需| | 必需的命令只有| | ld -m elf_i386 -nostdlib -T tools&#x2F;kernel.ld -o bin&#x2F;kernel \\| | obj&#x2F;kern&#x2F;init&#x2F;init.o obj&#x2F;kern&#x2F;libs&#x2F;readline.o \\| | obj&#x2F;kern&#x2F;libs&#x2F;stdio.o obj&#x2F;kern&#x2F;debug&#x2F;kdebug.o \\| | obj&#x2F;kern&#x2F;debug&#x2F;kmonitor.o obj&#x2F;kern&#x2F;debug&#x2F;panic.o \\| | obj&#x2F;kern&#x2F;driver&#x2F;clock.o obj&#x2F;kern&#x2F;driver&#x2F;console.o \\| | obj&#x2F;kern&#x2F;driver&#x2F;intr.o obj&#x2F;kern&#x2F;driver&#x2F;picirq.o \\| | obj&#x2F;kern&#x2F;trap&#x2F;trap.o obj&#x2F;kern&#x2F;trap&#x2F;trapentry.o \\| | obj&#x2F;kern&#x2F;trap&#x2F;vectors.o obj&#x2F;kern&#x2F;mm&#x2F;pmm.o \\| | obj&#x2F;libs&#x2F;printfmt.o obj&#x2F;libs&#x2F;string.o| | 其中新出现的关键参数为| | -T &lt;scriptfile&gt; 让连接器使用指定的脚本|| 生成一个有10000个块的文件，每个块默认512字节，用0填充| dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;bin&#x2F;ucore.img count&#x3D;10000|| 把bootblock中的内容写到第一个块| dd if&#x3D;bin&#x2F;bootblock of&#x3D;bin&#x2F;ucore.img conv&#x3D;notrunc|| 从第二个块开始写kernel中的内容| dd if&#x3D;bin&#x2F;kernel of&#x3D;bin&#x2F;ucore.img seek&#x3D;1 conv&#x3D;notrunc [练习1.2] 一个被系统认为是符合规范的硬盘主引导扇区的特征是什么? 从sign.c的代码来看，一个磁盘主引导扇区只有512字节。且第510个（倒数第二个）字节是0x55，第511个（倒数第一个）字节是0xAA。 [练习2][练习2.1] 从 CPU 加电后执行的第一条指令开始,单步跟踪 BIOS 的执行。 练习2可以单步跟踪，方法如下： 1 修改 lab1/tools/gdbinit,内容为: 12set architecture i8086target remote :1234 2 在 lab1目录下，执行 1make debug 3 在看到gdb的调试界面(gdb)后，在gdb调试界面下执行如下命令 1si 即可单步跟踪BIOS了。 4 在gdb界面下，可通过如下命令来看BIOS的代码 1x &#x2F;2i $pc &#x2F;&#x2F;显示当前eip处的汇编指令 [进一步的补充] 12345改写Makefile文件 debug: $(UCOREIMG) $(V)$(TERMINAL) -e &quot;$(QEMU) -S -s -d in_asm -D $(BINDIR)&#x2F;q.log -parallel stdio -hda $&lt; -serial null&quot; $(V)sleep 2 $(V)$(TERMINAL) -e &quot;gdb -q -tui -x tools&#x2F;gdbinit&quot; 在调用qemu时增加-d in_asm -D q.log参数，便可以将运行的汇编指令保存在q.log中。为防止qemu在gdb连接后立即开始执行，删除了tools/gdbinit中的continue行。 [练习2.2] 在初始化位置0x7c00 设置实地址断点,测试断点正常。 在tools/gdbinit结尾加上 12345 set architecture i8086 &#x2F;&#x2F;设置当前调试的CPU是8086b *0x7c00 &#x2F;&#x2F;在0x7c00处设置断点。此地址是bootloader入口点地址，可看boot&#x2F;bootasm.S的start地址处c &#x2F;&#x2F;continue简称，表示继续执行x &#x2F;2i $pc &#x2F;&#x2F;显示当前eip处的汇编指令set architecture i386 &#x2F;&#x2F;设置当前调试的CPU是80386 运行”make debug”便可得到 1234567891011Breakpoint 2, 0x00007c00 in ?? ()&#x3D;&gt; 0x7c00: cli 0x7c01: cld 0x7c02: xor %eax,%eax 0x7c04: mov %eax,%ds 0x7c06: mov %eax,%es 0x7c08: mov %eax,%ss 0x7c0a: in $0x64,%al 0x7c0c: test $0x2,%al 0x7c0e: jne 0x7c0a 0x7c10: mov $0xd1,%al [练习2.3] 在调用qemu 时增加-d in_asm -D q.log 参数，便可以将运行的汇编指令保存在q.log 中。将执行的汇编代码与bootasm.S 和 bootblock.asm 进行比较，看看二者是否一致。 在tools/gdbinit结尾加上 123b *0x7c00cx &#x2F;10i $pc 便可以在q.log中读到”call bootmain”前执行的命令 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869----------------IN: 0x00007c00: cli ----------------IN: 0x00007c01: cld 0x00007c02: xor %ax,%ax0x00007c04: mov %ax,%ds0x00007c06: mov %ax,%es0x00007c08: mov %ax,%ss----------------IN: 0x00007c0a: in $0x64,%al----------------IN: 0x00007c0c: test $0x2,%al0x00007c0e: jne 0x7c0a----------------IN: 0x00007c10: mov $0xd1,%al0x00007c12: out %al,$0x640x00007c14: in $0x64,%al0x00007c16: test $0x2,%al0x00007c18: jne 0x7c14----------------IN: 0x00007c1a: mov $0xdf,%al0x00007c1c: out %al,$0x600x00007c1e: lgdtw 0x7c6c0x00007c23: mov %cr0,%eax0x00007c26: or $0x1,%eax0x00007c2a: mov %eax,%cr0----------------IN: 0x00007c2d: ljmp $0x8,$0x7c32----------------IN: 0x00007c32: mov $0x10,%ax0x00007c36: mov %eax,%ds----------------IN: 0x00007c38: mov %eax,%es----------------IN: 0x00007c3a: mov %eax,%fs0x00007c3c: mov %eax,%gs0x00007c3e: mov %eax,%ss----------------IN: 0x00007c40: mov $0x0,%ebp----------------IN: 0x00007c45: mov $0x7c00,%esp0x00007c4a: call 0x7d0d----------------IN: 0x00007d0d: push %ebp 其与bootasm.S和bootblock.asm中的代码相同。 [练习3]分析bootloader 进入保护模式的过程。 从%cs=0 $pc=0x7c00，进入后 首先清理环境：包括将flag置0和将段寄存器置0 1234567.code16 cli cld xorw %ax, %ax movw %ax, %ds movw %ax, %es movw %ax, %ss 开启A20：通过将键盘控制器上的A20线置于高电位，全部32条地址线可用，可以访问4G的内存空间。 123456789101112131415seta20.1: # 等待8042键盘控制器不忙 inb $0x64, %al # testb $0x2, %al # jnz seta20.1 # movb $0xd1, %al # 发送写8042输出端口的指令 outb %al, $0x64 #seta20.1: # 等待8042键盘控制器不忙 inb $0x64, %al # testb $0x2, %al # jnz seta20.1 # movb $0xdf, %al # 打开A20 outb %al, $0x60 # 初始化GDT表：一个简单的GDT表和其描述符已经静态储存在引导区中，载入即可 1lgdt gdtdesc 进入保护模式：通过将cr0寄存器PE位置1便开启了保护模式 123movl %cr0, %eaxorl $CR0_PE_ON, %eaxmovl %eax, %cr0 通过长跳转更新cs的基地址 123 ljmp $PROT_MODE_CSEG, $protcseg.code32protcseg: 设置段寄存器，并建立堆栈 12345678movw $PROT_MODE_DSEG, %axmovw %ax, %dsmovw %ax, %esmovw %ax, %fsmovw %ax, %gsmovw %ax, %ssmovl $0x0, %ebpmovl $start, %esp 转到保护模式完成，进入boot主方法 1call bootmain [练习4]分析bootloader加载ELF格式的OS的过程。 首先看readsect函数，readsect从设备的第secno扇区读取数据到dst位置 123456789101112131415161718192021static voidreadsect(void *dst, uint32_t secno) &#123; waitdisk(); outb(0x1F2, 1); &#x2F;&#x2F; 设置读取扇区的数目为1 outb(0x1F3, secno &amp; 0xFF); outb(0x1F4, (secno &gt;&gt; 8) &amp; 0xFF); outb(0x1F5, (secno &gt;&gt; 16) &amp; 0xFF); outb(0x1F6, ((secno &gt;&gt; 24) &amp; 0xF) | 0xE0); &#x2F;&#x2F; 上面四条指令联合制定了扇区号 &#x2F;&#x2F; 在这4个字节线联合构成的32位参数中 &#x2F;&#x2F; 29-31位强制设为1 &#x2F;&#x2F; 28位(&#x3D;0)表示访问&quot;Disk 0&quot; &#x2F;&#x2F; 0-27位是28位的偏移量 outb(0x1F7, 0x20); &#x2F;&#x2F; 0x20命令，读取扇区 waitdisk(); insl(0x1F0, dst, SECTSIZE &#x2F; 4); &#x2F;&#x2F; 读取到dst位置， &#x2F;&#x2F; 幻数4因为这里以DW为单位&#125; readseg简单包装了readsect，可以从设备读取任意长度的内容。 1234567891011121314static voidreadseg(uintptr_t va, uint32_t count, uint32_t offset) &#123; uintptr_t end_va &#x3D; va + count; va -&#x3D; offset % SECTSIZE; uint32_t secno &#x3D; (offset &#x2F; SECTSIZE) + 1; &#x2F;&#x2F; 加1因为0扇区被引导占用 &#x2F;&#x2F; ELF文件从1扇区开始 for (; va &lt; end_va; va +&#x3D; SECTSIZE, secno ++) &#123; readsect((void *)va, secno); &#125;&#125; 在bootmain函数中， 1234567891011121314151617181920212223242526272829303132voidbootmain(void) &#123; &#x2F;&#x2F; 首先读取ELF的头部 readseg((uintptr_t)ELFHDR, SECTSIZE * 8, 0); &#x2F;&#x2F; 通过储存在头部的幻数判断是否是合法的ELF文件 if (ELFHDR-&gt;e_magic !&#x3D; ELF_MAGIC) &#123; goto bad; &#125; struct proghdr *ph, *eph; &#x2F;&#x2F; ELF头部有描述ELF文件应加载到内存什么位置的描述表， &#x2F;&#x2F; 先将描述表的头地址存在ph ph &#x3D; (struct proghdr *)((uintptr_t)ELFHDR + ELFHDR-&gt;e_phoff); eph &#x3D; ph + ELFHDR-&gt;e_phnum; &#x2F;&#x2F; 按照描述表将ELF文件中数据载入内存 for (; ph &lt; eph; ph ++) &#123; readseg(ph-&gt;p_va &amp; 0xFFFFFF, ph-&gt;p_memsz, ph-&gt;p_offset); &#125; &#x2F;&#x2F; ELF文件0x1000位置后面的0xd1ec比特被载入内存0x00100000 &#x2F;&#x2F; ELF文件0xf000位置后面的0x1d20比特被载入内存0x0010e000 &#x2F;&#x2F; 根据ELF头部储存的入口信息，找到内核的入口 ((void (*)(void))(ELFHDR-&gt;e_entry &amp; 0xFFFFFF))();bad: outw(0x8A00, 0x8A00); outw(0x8A00, 0x8E00); while (1);&#125; [练习5]实现函数调用堆栈跟踪函数 ss:ebp指向的堆栈位置储存着caller的ebp，以此为线索可以得到所有使用堆栈的函数ebp。ss:ebp+4指向caller调用时的eip，ss:ebp+8等是（可能的）参数。 输出中，堆栈最深一层为 123ebp:0x00007bf8 eip:0x00007d68 \\ args:0x00000000 0x00000000 0x00000000 0x00007c4f &lt;unknow&gt;: -- 0x00007d67 -- 其对应的是第一个使用堆栈的函数，bootmain.c中的bootmain。bootloader设置的堆栈从0x7c00开始，使用”call bootmain”转入bootmain函数。call指令压栈，所以bootmain中ebp为0x7bf8。 [练习6]完善中断初始化和处理 [练习6.1] 中断向量表中一个表项占多少字节？其中哪几位代表中断处理代码的入口？ 中断向量表一个表项占用8字节，其中2-3字节是段选择子，0-1字节和6-7字节拼成位移，两者联合便是中断处理程序的入口地址。 [练习6.2] 请编程完善kern/trap/trap.c中对中断向量表进行初始化的函数idt_init。 见代码 [练习6.3] 请编程完善trap.c中的中断处理函数trap，在对时钟中断进行处理的部分填写trap函数 见代码 [练习7]增加syscall功能，即增加一用户态函数（可执行一特定系统调用：获得时钟计数值），当内核初始完毕后，可从内核态返回到用户态的函数，而用户态的函数又通过系统调用得到内核态的服务 在idt_init中，将用户态调用SWITCH_TOK中断的权限打开。 SETGATE(idt[T_SWITCH_TOK], 1, KERNEL_CS, __vectors[T_SWITCH_TOK], 3); 在trap_dispatch中，将iret时会从堆栈弹出的段寄存器进行修改 对TO User 1234tf-&gt;tf_cs &#x3D; USER_CS;tf-&gt;tf_ds &#x3D; USER_DS;tf-&gt;tf_es &#x3D; USER_DS;tf-&gt;tf_ss &#x3D; USER_DS; 对TO Kernel123tf-&gt;tf_cs &#x3D; KERNEL_CS;tf-&gt;tf_ds &#x3D; KERNEL_DS;tf-&gt;tf_es &#x3D; KERNEL_DS; 在lab1_switch_to_user中，调用T_SWITCH_TOU中断。注意从中断返回时，会多pop两位，并用这两位的值更新ss,sp，损坏堆栈。所以要先把栈压两位，并在从中断返回后修复esp。 1234567asm volatile ( &quot;sub $0x8, %%esp \\n&quot; &quot;int %0 \\n&quot; &quot;movl %%ebp, %%esp&quot; : : &quot;i&quot;(T_SWITCH_TOU)); 在lab1_switch_to_kernel中，调用T_SWITCH_TOK中断。注意从中断返回时，esp仍在TSS指示的堆栈中。所以要在从中断返回后修复esp。 123456asm volatile ( &quot;int %0 \\n&quot; &quot;movl %%ebp, %%esp \\n&quot; : : &quot;i&quot;(T_SWITCH_TOK)); 但这样不能正常输出文本。根据提示，在trap_dispatch中转User态时，将调用io所需权限降低。 1tf-&gt;tf_eflags |&#x3D; 0x3000;","categories":[{"name":"OS","slug":"OS","permalink":"https://didongdongdi.github.io/categories/OS/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://didongdongdi.github.io/tags/Notes/"}],"author":"DiDong"},{"title":"操作系统笔记_2_实验1","slug":"操作系统笔记-2-实验1","date":"2019-06-06T05:48:00.000Z","updated":"2019-08-03T10:03:41.300Z","comments":true,"path":"2019/06/06/操作系统笔记-2-实验1/","link":"","permalink":"https://didongdongdi.github.io/2019/06/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0-2-%E5%AE%9E%E9%AA%8C1/","excerpt":"实验内容完成一个能够切换到x86的保护模式并显示字符的bootloader 注意事项Bootloader可以让CPU进入保护模式, 读磁盘并加载ELF执行文件格式, 并显示字符 OS只是一个可以处理时钟中断和显示字符的幼儿园级别OS","text":"实验内容完成一个能够切换到x86的保护模式并显示字符的bootloader 注意事项Bootloader可以让CPU进入保护模式, 读磁盘并加载ELF执行文件格式, 并显示字符 OS只是一个可以处理时钟中断和显示字符的幼儿园级别OS 重点连续内存的管理 中断的管理 练习1 一个被系统认为是符合规范的硬盘主引导扇区的特征是什么?tools/sign.c中完成了特征的标记 12345678910111213141516171819202122232425262728293031323334353637383940414243// tools/sign.c#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;sys/stat.h&gt;int main(int argc, char *argv[]) &#123;//关于main函数参数的问题, 参考https://blog.csdn.net/yhawaii/article/details/7361302 struct stat st;//struct stat结构体用来描述一个linux文件系统中的文件属性的结构, 参考https://www.cnblogs.com/CSU-PL/archive/2013/06/06/3120757.html if (argc != 3) &#123; fprintf(stderr, \"Usage: &lt;input filename&gt; &lt;output filename&gt;\\n\"); return -1; &#125; if (stat(argv[1], &amp;st) != 0) &#123;//通过路径获取bootloader文件属性, argv[1]为文件路径 fprintf(stderr, \"Error opening file '%s': %s\\n\", argv[1], strerror(errno)); return -1; &#125; printf(\"'%s' size: %lld bytes\\n\", argv[1], (long long)st.st_size); if (st.st_size &gt; 510) &#123;//结束标志是两个字节(0x55AA) fprintf(stderr, \"%lld &gt;&gt; 510!!\\n\", (long long)st.st_size); return -1; &#125; char buf[512]; memset(buf, 0, sizeof(buf));//缓冲区清空 FILE *ifp = fopen(argv[1], \"rb\"); int size = fread(buf, 1, st.st_size, ifp); if (size != st.st_size) &#123; fprintf(stderr, \"read '%s' error, size is %d.\\n\", argv[1], size); return -1; &#125; fclose(ifp); buf[510] = 0x55;//标记 buf[511] = 0xAA; FILE *ofp = fopen(argv[2], \"wb+\"); size = fwrite(buf, 1, 512, ofp); if (size != 512) &#123; fprintf(stderr, \"write '%s' error, size is %d.\\n\", argv[2], size); return -1; &#125; fclose(ofp); printf(\"build 512 bytes boot sector: '%s' success!\\n\", argv[2]); return 0;&#125; 练习2 lab1-mon lab1_result的Makefile中: 1234lab1-mon: $(UCOREIMG) $(V)$(TERMINAL) -e \"$(QEMU) -S -s -d in_asm -D $(BINDIR)/q.log -monitor stdio -hda $&lt; -serial null\" # 将qemu执行指令的信息记录下来, 放到q.log $(V)sleep 2 $(V)$(TERMINAL) -e \"gdb -q -x tools/lab1init\" # 和gdb结合来调试正在执行的bootloader, lab1init中是一些初始化的执行指令 lab1init lab1init内容(gdb可以识别的一些命令) 123456file bin&#x2F;kerneltarget remote :1234set architecture i8086b *0x7c00continuex &#x2F;2i $pc 说明: lab1init中是gdb能识别的一些命令 第一条指令: 加载bin/kernel 第二条指令: 与qemu通过TRP连接 最后一条指令打印指令指针寄存器(pc/eip)的内容(当前正在执行的指令的地址) 计算机启动流程(从计算机上电到进入ucore) 计算机上电, 运行第一条长跳转指令(CS和EIP都会更新)到BIOS代码中执行 BIOS执行其功能, 同时加载存储设备的第一个扇区的512字节到内存的0x7c00处, 然后跳转到这里开始执行 bootloader关闭中断, 清除方向标志, 确保内存地址由小到大增加 ds, es, ss 段寄存器置零 准备开启A20, 首先等待8042键盘控制器不忙(检查0x64端口或P2端口), 写入0xd1; 再次等待不忙, 写入0xdf到0x60端口; 由此完成了打开A20的操作 初始化gdt表, gdt表在这512个字节中的24个字节, 一共3个表项 将cr0就寄存器PE位(即最低位)置1, 从而进入保护模式 通过一个长跳转(段间跳转), 更新cs的基地址, 同时进入32位保护模式的代码部分 将保护模式下的数据段选择子, 放入ds, es, fs, gs, ss 段寄存器 设置ebp和esp寄存器初值 进入bootmain函数(进入c代码部分) 读取存储设备的八个扇区(8个512字节), 到内存中, 读取elf文件的头部 检查elf头部的幻数, 验证elf文件是否合法 读取elf头部的描述表(描述了elf文件应加载到内存什么位置) 按照描述表将elf文件中数据载入内存 根据elf头部存储的入口信息, 找到内核入口, 并进入 BIOS的向后兼容 Intel的CPU具有很好的向后兼容性。在16位的8086 CPU时代，内存限制在1MB范围内，且BIOS的代码固化在EPROM中。在基于Intel的8086 CPU的PC机中的EPROM被编址在1ＭB内存地址空间的最高64KB中。PC加电后，CS寄存器初始化为0xF000，IP寄存器初始化为0xFFF0，所以CPU要执行的第一条指令的地址为CS:IP=0xF000:0XFFF0（Segment:Offset 表示）=0xFFFF0（Linear表示）。这个地址位于被固化EPROM中，指令是一个长跳转指令JMP F000:E05B。这样就开启了BIOS的执行过程。 到了32位的80386 CPU时代，内存空间扩大到了4G，多了段机制和页机制，但Intel依然很好地保证了80386向后兼容8086。地址空间的变化导致无法直接采用8086的启动约定。如果把BIOS启动固件编址在0xF000起始的64KB内存地址空间内，就会把整个物理内存地址空间隔离成不连续的两段，一段是0xF000以前的地址，一段是1MB以后的地址，这很不协调。为此，intel采用了一个折中的方案：默认将执行BIOS ROM编址在32位内存地址空间的最高端，即位于4GB地址的最后一个64KB内。在PC系统开机复位时，CPU进入实模式，并将CS寄存器设置成0xF000，将它的shadow register的Base值初始化设置为0xFFFF0000，EIP寄存器初始化设置为0x0000FFF0。所以机器执行的第一条指令的物理地址是0xFFFFFFF0。80386的BIOS代码也要和以前8086的BIOS代码兼容，故地址0xFFFFFFF0处的指令还是一条长跳转指令jmp F000:E05B。注意，这个长跳转指令会触发更新CS寄存器和它的shadow register，即执行jmp F000 : E05B后，CS将被更新成0xF000。表面上看CS其实没有变化，但CS的shadow register被更新为另外一个值了，它的Base域被更新成0x000F0000，此时形成的物理地址为Base+EIP=0x000FE05B，这就是CPU执行的第二条指令的地址。此时这条指令的地址已经是1M以内了，且此地址不再位于BIOS ROM中，而是位于RAM空间中。由于Intel设计了一种映射机制，将内存高端的BIOS ROM映射到1MB以内的RAM空间里，并且可以使这一段被映射的RAM空间具有与ROM类似的只读属性。所以PC机启动时将开启这种映射机制，让4GB地址空间的最高一个64KB的内容等同于1MB地址空间的最高一个64K的内容，从而使得执行了长跳转指令后，其实是回到了早期的8086 CPU初始化控制流，保证了向下兼容。 BIOS中A20的设置参考https://zhidao.baidu.com/question/24524472.html 如果在保护模式下不启用A20参考https://www.zhihu.com/question/29375534","categories":[{"name":"OS","slug":"OS","permalink":"https://didongdongdi.github.io/categories/OS/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://didongdongdi.github.io/tags/Notes/"}],"author":"DiDong"},{"title":"ipv6网络相关","slug":"ipv6网络相关","date":"2019-06-06T04:30:00.000Z","updated":"2019-07-28T03:10:35.608Z","comments":true,"path":"2019/06/06/ipv6网络相关/","link":"","permalink":"https://didongdongdi.github.io/2019/06/06/ipv6%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/","excerpt":"ipv6网络影响因素 操作系统配置(windows, deepin, …)","text":"ipv6网络影响因素 操作系统配置(windows, deepin, …) 接入网(DLUT, DLUT-EDA无线, DLUT-EDA有线, OurEDA需要认证, OurEDA无需认证, 移动, 联通, …) 连接方式(直连, 代理) 网站(国内, 国外)","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://didongdongdi.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[],"author":"DiDong"},{"title":"GCC内联汇编笔记","slug":"GCC内联汇编笔记","date":"2019-05-28T06:29:00.000Z","updated":"2019-07-28T03:11:04.075Z","comments":true,"path":"2019/05/28/GCC内联汇编笔记/","link":"","permalink":"https://didongdongdi.github.io/2019/05/28/GCC%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0/","excerpt":"什么是内联汇编? 内联函数我们可以要求编译器将一个函数的代码插入到调用者的代码中函数实际调用的地方","text":"什么是内联汇编? 内联函数我们可以要求编译器将一个函数的代码插入到调用者的代码中函数实际调用的地方 inline(内联)的作用减少函数调用开销, 同时如果所有实参的值为常量, 它们的已知值可以再编译期允许简化, 因此并非所有的内联函数代码都需要被包含进去, 代码大小的影响是不可预测的, 这取决于特定的情况 内联汇编写为内联函数的汇编程序可以操作并且使其输出通过通过C变量显示出来, 因此asm可作为汇编指令和包含它的C程序之间的接口 源操作数和目的操作数顺序Op-code src dst (Intel语法相反) 寄存器命名%eax 立即数$0xFFFF 操作数大小取决于操作码名字的最后一个字符 AT&amp;T b w l 字节 字 长型 8 16 32 Intel byte word dword ptr ptr ptr AT&amp;T movb foo, %al Intel mov al, byte ptr foo 存储器操作数 AT&amp;T section:disp(base, index, scale) Intel section:[base + index*scale + disp] 注意: 当一个常量用于disp或scale, 不能添加$前缀 base: 基址寄存器 ebxindex: 索引(寄存器)scale: 比例(数值)disp: 位移(数值) 基本内联 asm(“汇编代码”); 或者 asm(“汇编代码”);采用后者的原因: asm和标识符冲突时, 或是为了与ANSI C兼容 指令多于一条 每个一行 用双引号圈起 每条指令添加后缀\\n\\t gcc将每一条当做字符串发送给as(GAS, GNU汇编器), 并且通过使用\\n\\t发送正确格式化后的行给汇编器 e.g. 1234__asm__(\"movl %eax, %ebx\\n\\t\" \"movl $56, %esi\\n\\t\" \"movl %ecx, $label(%edx, %ebx, $4)\\n\\t\" \"movb %ah, (%ebx)\"); 扩展汇编为什么需要扩展汇编? 如果在代码中, 我们涉及到一些寄存器(即改变其内容), 但在没有恢复这些变化的情况下从汇编中返回, 将会导致一些意想不到的事情.这是因为GCC并不知道寄存器内容的变化, 这会导致问题, 特别是当编译器做了某些优化.在没有告知GCC的情况下, 他将会假设一些寄存器存储了一些值, 而我们可能已经改变却没有告知GCC, 它会像什么事都没发生一样(GCC不会假设寄存器装入的值是有效的, 当退出改变了寄存器值的内联汇编后, 寄存器的值不会保存到相应的变量或内存空间)继续运行.我们可以做的是, 使用那些没有副作用的指令, 或者当我们退出时恢复这些寄存器, 要不就等着程序崩溃.这就是为什么我们需要一些扩展功能, 扩展汇编给我们提供了那些功能. 扩展汇编的使用 扩展汇编中, 我们可以同时指定操作数.它允许我们指定输入寄存器, 输出寄存器以及修饰寄存器列表.GCC不强制用户必须指定使用的寄存器.我们可以把头疼的事留给GCC, 这可能可以更好地适应GCC的优化. 结构: 1234asm(汇编语句:输出操作数/*可选的*/:输入操作数/*可选的*/:修饰寄存器列表/*可选的*/); 每一个操作数由一个操作数字符串所描述, 其后紧接一个括弧括起的C表达式.逗号用于分离每一个组内的操作数.总操作数的数目限制在10个, 或者机器描述中的任何指令格式中的最大操作数数目, 以较大者为准.如果没有输出操作数但存在输入操作数, 你必须将两个连续的冒号放置于输出操作数原本会放置的地方周围. e.g. 1234567//使用汇编指令使b变量的值等于a变量的值int a=10, b;asm(\"movl %1, %%eax; movl %%eax, %0;\" :\"=r\"(b) /*输出*/ :\"r\"(a) /*输入*/ :\"%eax\"); /*修饰寄存器*/ 注意: b为输出操作数, 用%0引用; a为输入操作数, 用%1引用 r为操作数约束, r告诉GCC可以使用任意寄存器存储操作数; 输出操作数应该有一个约束修饰符=, 表明它是一个只写的输出操作数. 寄存器名字以%%为前缀, 这有利于GCC区分操作数和寄存器, 操作数以%为前缀; 第三个冒号之后的修饰寄存器%eax用于告诉GCC%eax的值将会在asm内部被修改, 所以GCC将不会使用此寄存器存储任何其他值. 当asm执行完毕, b变量会映射到更新的值, 因为它被指定为输出操作数; 换句话说asm内b变量的修改应该会被映射到asm外部. 注意事项 约束字符串主要用于决定操作数的寻址方式, 同时也用于指定使用的寄存器. 输出操作数表达式必须为左值.输入操作数的要求不像这样严格.他们可以为表达式.扩展汇编特性常常用于编译器所不知道的机器指令.如果输出表达式无法直接寻址(即, 它是一个位域), 我们的约束字符串必须给定一个寄存器.在这种情况下, GCC将会使用该寄存器作为汇编的输出, 然后存储该寄存器的内容到输出. 普通的输出操作数必须为只写的.GCC将会假设指令前的操作数值是死的, 并且不需要被(提前)生成.扩展汇编也支持输入-输出或者读-写操作数. 如果我们的指令可以修改条件码寄存器(cc), 我们必须将cc添加进修饰寄存器列表.如果我们的指令, 以不可预测的方式修改了内存, 那么需要将memory添加进修饰寄存器列表.这可以使GCC不会在汇编指令间保持缓存于寄存器的内存值.如果被影响的内存不在汇编的输入或输出列表中, 我们也必须添加volatile关键字. volatile 如果我们的汇编语句必须在我们放置它的地方执行(如不能为了优化而被移出循环语句), 将关键词volatile放置在asm后面, ()前面.以防止它被移动, 删除或者其他操作, 我们将其声明为asm volatile(... :... :... :...);如果担心发生冲突, 请使用__volatile__. 如果我们的汇编只是用于一些计算并且没有任何副作用, 不使用volatile关键词会更好.不使用volatile可以帮助gcc优化代码并使代码更漂亮. 常用约束寄存器操作数约束GPR(General Purpose Register, 通用寄存器) 要指定寄存器, 你必须使用特定寄存器约束直接地指定寄存器的名字, 它们为: r Register(s) a %eax, %ax, %al b %ebx, %bx, %bl c %ecx, %cx, %cl d %edx, %dx, %dl S %esi, %si D %edi, %di 内存操作数约束 当操作数位于内存时, 任何对它们的操作将直接发生在内存位置, 这与寄存器约束相反, 后者首先将值存储在要修改的寄存器中, 然后将它写回内存位置.但寄存器约束通常用于一个指令必须使用它们或者它们可以大大提高处理速度的地方.当需要在asm内更新一个C变量, 而又不是使用寄存器去保存它的值, 使用内存最为有效. e.g. 12//IDTR寄存器的值存储于内存位置loc处asm(\"sidt %0\\n\"::\"m\"(loc)); 注意: 每条指令应以分界符结尾, 有效的分界符有换行符\\n和分号;, \\n可以紧随一个制表符\\t. 匹配(数字)约束 在某些情况下, 一个变量可能既充当输入操作数, 也充当输出操作数.可以通过使用匹配约束在asm中指定这种情况. e.g. 1asm(\"incl %0\" :\"=a\"(var) :\"0\"(var)); 说明:寄存器%eax既用作输入变量, 也用作输出变量.var输入被读进%eax, 并且等递增后更新的%eax再次被存储进var.这里的0用于指定与第0个输出变量相同的约束.它指定var输出示例应只被存储在%eax中.该约束可用于: 在输入从变量读取或变量修改后且修改被写回同一变量的情况 在不需要将输入操作数实例和输出操作数实例分开的情况 使用匹配约束最重要的意义在于它们可以有效地使用可用寄存器. 其他一些约束 约束 说明 m 允许一个内存操作数, 可以使用机器普遍支持的任一种地址 o 允许一个内存操作数, 但只有当地址是可偏移的; 即, 该地址加上一个小的偏移量可以得到一个有效地址 V 一个不允许偏移的内存操作数; 换言之, 任何适合m约束而不适合o约束的操作数 i 允许一个(带有常量)的立即整型操作数; 这包括其值仅在汇编时期知道的符号常量 n 允许一个带有已知数字的立即整型操作数; 许多系统不支持汇编时期的常量, 因为操作数少于一个字宽; 对于此种操作数, 约束应该使用n而不是i g 允许任一寄存器, 内存或者立即整型操作数, 不包括通用寄存器之外的寄存器 x86特有约束 约束 说明 r 寄存器操作数约束, 查看上面的给定的表格 q 寄存器a, b, c, 或者d l 范围从0到31的常量(对于32位移位) J 范围从0到63的常量(对于64位移位) K 0xff L 0xffff M 0, 1, 2 或 3(lea指令的移位) N 范围从0到255的常量(对于out指令) f 浮点寄存器 t 第一个(栈顶)浮点寄存器 u 第二个浮点寄存器 A 指定a或d寄存器; 这主要用于想要返回64位整型数, 使用d寄存器保存最高有效位和a寄存器保存最低有效位 约束修饰符当使用约束时, 对于更精确的控制超过了对约束作用的需求, GCC给我们提供了约束修饰符. 约束修饰符 I/O 说明 = O 对于这条指令, 操作数为只写的; 旧值会被忽略并被输出数据所替换; 只能写在第一个字符的位置 &amp; O 用符号&amp;进行修饰时,等于向GCC声明, “GCC不得为任何Input操作表达式分配与此Output操作表达式相同的寄存器”; 其原因是修饰符&amp;意味着被其修饰的Output操作表达式要在所有的Input操作表达式被输入之前输出; 即, GCC会先使用输出值对被修饰符&amp;修饰的Output操作表达式进行填充,然后,才对Input操作表达式进行输入; 这样的话,如果不使用修饰符&amp;对Output操作表达式进行修饰,一旦后面的Input操作表达式使用了与Output操作表达式相同的寄存器,就会产生输入输出数据混乱的情况; 相反,如果用修饰符&amp;修饰输出操作表达式, 那么, 就意味着GCC会先把Input操作表达式的值输入到选定的寄存器中,然后经过处理,最后才用输出值填充对应的Output操作表达式; 只能写在第二个字符的位置; 参考自https://blog.csdn.net/koozxcv/article/details/49612791 + O 对于这条指令, 操作数为可读可写的; 只能写在第一个字符的位置 % I 表示此Input操作表达式中的C/C++表达式可以与下一个Input操作表达式中的C/C++表达式互换","categories":[{"name":"Notes","slug":"Notes","permalink":"https://didongdongdi.github.io/categories/Notes/"}],"tags":[],"author":"DiDong"},{"title":"teamviewer安装问题","slug":"teamviewer安装问题","date":"2019-05-24T08:53:00.000Z","updated":"2019-05-26T05:15:09.000Z","comments":true,"path":"2019/05/24/teamviewer安装问题/","link":"","permalink":"https://didongdongdi.github.io/2019/05/24/teamviewer%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98/","excerpt":"树莓派安装teamviewer","text":"树莓派安装teamviewer ID不是邮件中发送的, 而是命令teamviewer info中的ID","categories":[{"name":"Problem","slug":"Problem","permalink":"https://didongdongdi.github.io/categories/Problem/"}],"tags":[],"author":"DiDong"},{"title":"MYSQL必知必会笔记","slug":"MYSQL必知必会笔记","date":"2019-05-19T08:12:00.000Z","updated":"2019-05-26T05:15:09.000Z","comments":true,"path":"2019/05/19/MYSQL必知必会笔记/","link":"","permalink":"https://didongdongdi.github.io/2019/05/19/MYSQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E7%AC%94%E8%AE%B0/","excerpt":"了解SQL 数据库保存有组织的数据的容器(通常是一个文件或一组文件)","text":"了解SQL 数据库保存有组织的数据的容器(通常是一个文件或一组文件) 表某种特定类型数据的结构化清单 模式关于数据库和表的布局及特性的信息 列表中的每个字段. 所有表都是由一个或多个列组成的. 数据类型所容许的数据的类型. 每个表列都有相应的数据类型, 它限制(或容许)该列中存储的数据. 行表中的一个记录 主键一列(或一组列), 其值能能够唯一区分表中每个行 关键字作为MySQL语言组成部分的一个保留字. 绝不要用关键字命名一个表或列. 注: 括号中为替换内容 打开数据库USE {database}; 显示可用数据库SHOW DATABASES; 显示一个数据库内的表SHOW TABLES; 显示表列SHOW COLUMNS FROM {table};或DESCRIBE {table}; 自动增量(auto_increment)某些表列需要唯一值; mysql可以自动地为每个行分配下一个可用编号, 不用在添加一行时手动分配唯一值 显示广泛的服务器状态信息SHOW STATUS; 显示创建特定数据库或表的mysql语句SHOW CREATE DATABASE或SHOW CREATE TABLE 显示授予用户SHOW GRANTS 显示服务器错误或警告信息SHOW ERRORS或SHOW WARNINGS 获得和过滤模式信息INFORMATION_SCHEMA 注: 样例表为一个想象的随身物品推销商使用的订单录入系统, 往后的脚本中, 大写为关键字, 小写为内容. 使用全文搜索的表, 必须指定ENGINE=MyISAM 注: 取消笔记, 直接参照书 注意事项 mysql必知必会 这本书的触发器部分有错误, 估计是版本原因, 故后面的内容采用 深入浅出mysql 这本书 子查询中的每个表都要有别名","categories":[{"name":"Notes","slug":"Notes","permalink":"https://didongdongdi.github.io/categories/Notes/"}],"tags":[],"author":"DiDong"},{"title":"ctags中文注释错误","slug":"ctags中文注释错误","date":"2019-05-16T08:18:00.000Z","updated":"2019-05-26T05:15:09.000Z","comments":true,"path":"2019/05/16/ctags中文注释错误/","link":"","permalink":"https://didongdongdi.github.io/2019/05/16/ctags%E4%B8%AD%E6%96%87%E6%B3%A8%E9%87%8A%E9%94%99%E8%AF%AF/","excerpt":"ctags 代码与中文注释同行","text":"ctags 代码与中文注释同行 会出现, 即使tag文件中有这个模式的匹配, 在vim中也无法找到对应的匹配的情况 建议, 中文注释与代码不要同行 ctags 匹配到多个结果使用:tn显示下一个, :tp显示上一个 也可用映射, ;tl显示下一个, ;th显示上一个","categories":[{"name":"Problem","slug":"Problem","permalink":"https://didongdongdi.github.io/categories/Problem/"}],"tags":[],"author":"DiDong"},{"title":"vim按下回车后大括号自动换行缩进","slug":"vim按下回车后大括号自动换行缩进","date":"2019-05-12T09:40:00.000Z","updated":"2019-05-26T05:15:09.000Z","comments":true,"path":"2019/05/12/vim按下回车后大括号自动换行缩进/","link":"","permalink":"https://didongdongdi.github.io/2019/05/12/vim%E6%8C%89%E4%B8%8B%E5%9B%9E%E8%BD%A6%E5%90%8E%E5%A4%A7%E6%8B%AC%E5%8F%B7%E8%87%AA%E5%8A%A8%E6%8D%A2%E8%A1%8C%E7%BC%A9%E8%BF%9B/","excerpt":"问题描述: 在一对大括号之间回车，自动分为3行并调整缩进","text":"问题描述: 在一对大括号之间回车，自动分为3行并调整缩进 代码: 1234567891011\" 大括号自动分行, C/C++下的自动命令autocmd BufWritePre,BufRead *.c :inoremap &lt;Enter&gt; &lt;c-r&gt;=BracketsEnter('&#125;')&lt;CR&gt;autocmd BufWritePre,BufRead *.cpp :inoremap &lt;Enter&gt; &lt;c-r&gt;=BracketsEnter('&#125;')&lt;CR&gt;function BracketsEnter(char) if getline('.')[col('.')-1] == a:char return \"\\&lt;Enter&gt;\\&lt;Tab&gt;\\&lt;Esc&gt;mpa\\&lt;Enter&gt;\\&lt;Esc&gt;`pa\" else return \"\\&lt;Enter&gt;\" endifendf","categories":[{"name":"Problem","slug":"Problem","permalink":"https://didongdongdi.github.io/categories/Problem/"}],"tags":[],"author":"DiDong"},{"title":"Deepin搜狗拼音输入法故障","slug":"Deepin搜狗拼音輸入法故障","date":"2019-05-10T06:25:00.000Z","updated":"2019-05-26T05:15:09.000Z","comments":true,"path":"2019/05/10/Deepin搜狗拼音輸入法故障/","link":"","permalink":"https://didongdongdi.github.io/2019/05/10/Deepin%E6%90%9C%E7%8B%97%E6%8B%BC%E9%9F%B3%E8%BC%B8%E5%85%A5%E6%B3%95%E6%95%85%E9%9A%9C/","excerpt":"Deepin搜狗拼音输入法故障","text":"Deepin搜狗拼音输入法故障 搜狗拼音输入法出错解决方法: rm -rf ~/.config/SogouPY, 重启电脑","categories":[{"name":"Problem","slug":"Problem","permalink":"https://didongdongdi.github.io/categories/Problem/"}],"tags":[],"author":"DiDong"},{"title":"SQL注意事项","slug":"SQL注意事项","date":"2019-05-09T11:15:00.000Z","updated":"2019-05-26T05:15:09.000Z","comments":true,"path":"2019/05/09/SQL注意事项/","link":"","permalink":"https://didongdongdi.github.io/2019/05/09/SQL%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/","excerpt":"","text":"mysql错误1215：无法添加外键可参考https://blog.csdn.net/wangpeng047/article/details/19624351我的原因：添加外键时，references后面的被参照关系同样要指定主键","categories":[{"name":"Problem","slug":"Problem","permalink":"https://didongdongdi.github.io/categories/Problem/"}],"tags":[],"author":"DiDong"},{"title":"Deepin下安装MySQL（APT Repository）","slug":"Deepin下安装MySQL","date":"2019-05-08T08:42:00.000Z","updated":"2019-12-20T03:29:10.646Z","comments":true,"path":"2019/05/08/Deepin下安装MySQL/","link":"","permalink":"https://didongdongdi.github.io/2019/05/08/Deepin%E4%B8%8B%E5%AE%89%E8%A3%85MySQL/","excerpt":"本文参考自官方文档 添加APT库 下载APT库","text":"本文参考自官方文档 添加APT库 下载APT库 在https://dev.mysql.com/downloads/repo/apt/处下载deb包 执行sudo dpkg -i &lt;PATH&gt;，&lt;PATH&gt; 为刚下载的包的地址 由于这个库是为Debian和Ubuntu准备的，在检测到系统不符时，会让你选择系统，选择Debian Jessie就可以（Deepin15基于Debian Jessie） 然后其他默认即可，也可以修改安装的版本 执行sudo apt-get update，这一步是必须的 使用APT安装MySQLsudo apt-get install mysql-server，server和client以及数据库公共文件都会被安装 启用和终止MySQL Server查看server状态（安装后会自动启动），sudo service mysql status 终止server，sudo service mysql stop 重启server，sudo service mysql start 使用APT卸载mysql sudo apt-get remove mysql-server sudo apt-get autoremove 卸载其他组件, sudo apt-get remove &lt;package-name&gt; 列出从mysql apt库安装的包, dpkg -l | grep mysql | grep ii 错误 错误1 ERROR 2003 (HY000): Can’t connect to MySQL server on ‘127.0.0.1’ (111) ERROR 2002 (HY000): Can’t connect to local MySQL server through socket ‘/var/run/mysqld/mysqld.sock’ (2) 在正常的mysql下, 当server正常启动时, 才会创建mysqld/mysqld.sock 参考https://blog.csdn.net/weixin_39543992/article/details/78105383, 安装MariaDB 出现root用户连接被拒(密码正确) 尝试卸载重装mysql 出现错误, ERROR 1524 (HY000): Plugin ‘unix_socket’ is not loaded 参考https://unix.stackexchange.com/questions/420530/error-1524-hy000-plugin-unix-socket-is-not-loaded-mysql, 彻底错误, 卸载mysql和mariadb-server 放弃apt安装的方法, 采用其他方法 错误2 Failed to start mysql.service: Unit mysql.service is masked. 解决方法, sudo systemctl unmask mysql.service ERROR 1045 (28000): Access denied for user ‘didong’@’localhost’ (using password: NO) 解决方法, 添加 sudo ERROR 1524 (HY000): Plugin ‘unix_socket’ is not loaded 参考[ERROR 1524 (HY000): Plugin ‘unix_socket’ is not loaded](ERROR 1524 (HY000): Plugin ‘unix_socket’ is not loaded), 解决 期间遇到mysql.USER找不到的问题, 其原因是应使用user(小写) 成功安装解决 总结 通过这一次的安装mysql(其实第一次很顺利地安装成功了, 通过apt库的形式, 但是后来貌似由于没关mysql服务器关机重启, 导致了错误1的出现), 重装软件或者换另外一种方式重装或许是一种解决方法, 但是另一方面, 在原有的安装的基础上, 通过解决一个个错误来完成, 或许是一种更好的方法, 当重装无用, 或不方便的时候, 况且还能积累经验, 增强以后解决类似问题的能力. 还要注意一些细节问题, 这往往可以让你少花许多时间, 解决问题的时候一定不要情绪烦躁, 而要冷静.","categories":[{"name":"数据库","slug":"数据库","permalink":"https://didongdongdi.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://didongdongdi.github.io/tags/%E6%95%99%E7%A8%8B/"}],"author":"DiDong"},{"title":"vimscript笔记——1——脚本语言","slug":"vimscript笔记——1——脚本语言","date":"2019-05-06T12:28:00.000Z","updated":"2019-05-19T08:15:48.563Z","comments":true,"path":"2019/05/06/vimscript笔记——1——脚本语言/","link":"","permalink":"https://didongdongdi.github.io/2019/05/06/vimscript%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%941%E2%80%94%E2%80%94%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/","excerpt":"","text":"负责任的编码代码折叠，e.g. 123456\" Vimscript file settings &#123;&#123;&#123;augroup filetype_vim autocmd! autocmd FileType vim setlocal foldmethod=markeraugroup END\" &#125;&#125;&#125; 变量e.g. 123456789101112131415161718192021&quot; 变量赋值:let foo &#x3D; &quot;bar&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; 选项赋值，不可更改:set textwidth&#x3D;80&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; 布尔选项:set wrap&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; 作为变量的选项:let &amp;textwidth &#x3D; 100:let &amp;textwidth &#x3D; &amp;textwidth + 10&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; 本地选项:setlocal number&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; 本地选项作为变量:let &amp;l:number &#x3D; 1&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; 作为变量的寄存器，&quot;为未命名寄存器，&#x2F;为搜索模式寄存器:let @a &#x3D; &quot;hello!&quot; 注：在set可以搞定的时候，永远都不要用let，这是因为let更难于阅读。 变量作用域123&quot; b:表示本地作用域变量:let b:hello &#x3D; &quot;world&quot;:echo b:hello 条件语句对于多行语句可以采用管道|来执行 对于vimscript有如下结论： 如有必要，Vim将强制转换变量(和字面量)的类型。在解析10 + “20foo”时，Vim将把”20foo”转换成一个整数(20)然后加到10上去。 以一个数字开头的字符串会被强制转换成数字，否则会转换成0。 在所有的强制转换完成后，当if的判断条件等于非零整数时，Vim会执行if语句体。 1234567:if 0: echom &quot;if&quot;:elseif &quot;nope!&quot;: echom &quot;elseif&quot;:else: echom &quot;finally!&quot;:endif 比较123456:set ignorecase:if &quot;foo&quot; &#x3D;&#x3D; &quot;FOO&quot;: echom &quot;no, it couldn&#39;t be&quot;:elseif &quot;foo&quot; &#x3D;&#x3D; &quot;foo&quot; : echom &quot;this must be the one&quot;:endif ==的行为取决于用户的设置，这意味着在为别人开发插件时，你不能信任== ==?是无论你怎么设都大小写不敏感 ==#是无论你怎么设都大小写敏感 函数:function meow()，出错，没有作用域限制的vimscript函数必须以一个大写字母开头 函数定义，e.g. 123:function Meow(): echom &quot;Meow!&quot;:endfunction 函数运行，返回值丢弃，e.g. :call Meow() 在表达式里调用函数，e.g. :echom GetMeow() 函数没有return值时，会隐式返回0 函数参数在写需要参数的Vimscript函数的时候，你总需要给参数加上前缀a:，来告诉Vim去参数作用域查找。 可变参数，e.g. 12345678:function Varg2(foo, ...): echom a:foo: echom a:0: echom a:1: echo a:000:endfunction:call Varg2(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) a:0为额外参数的数量 a:1为第一个额外参数，a:2同理 a:000为一个包括所有传递过来的额外参数的列表 注意： 不能对参数变量重新赋值 全局变量的访问需要通过g: 数字 两种数值类型： Number Float echo 5e10，错误，小数点和小数点后的数字是必须要有的 注意，浮点数仅当编译时加入+float特性时才可以使用 字符串.用来连接字符串，e.g. ：echom &quot;Hello, &quot; . &quot;world&quot; :echom 10 + &quot;10.10&quot;，显示20，强制转换&quot;10.10&quot;时，小数点后的内容被丢弃 echom 10 . &quot;foo&quot;，显示10foo echom 10.1 . &quot;foo&quot;，错误在连接字符串时不能把Float当作String 注意，有时echom的输出跟echo会有所不同，e.g. 1234:echo &quot;foo\\nbar&quot;&quot; 显示 foo 和 bar 两行:echom &quot;foo\\nbar&quot;&quot; 显示 ^@ , 这在vim里表示换行符 字符串字面量（无视转义字符串），采用单引号而不是双引号，而两个连续的单引号在字符串字面量里面会显示为一个单引号，不连续会出错 字符串函数长度，strlen() 或 len() 切割，split()，把字符串切割成列表，以空格为分割界限，也可以指定分隔符，e.g. :echo split(&quot;one,two,three&quot;,&quot;,&quot;)，显示[&#39;one&#39;,&#39;two&#39;,&#39;three&#39;] 连接，join()，e.g. :echo join([&quot;foo&quot;, &quot;bar&quot;], &quot;...&quot;)，显示foo...bar 大小写转换，tolower()，变小写；toupper()，变大写 Execute命令e.g. :execute &quot;rightbelow vsplit &quot; . bufname(&#39;#&#39;) Normal命令把我们的脚本跟日常的文本编辑命令结合起来 normal命令将顾及当前的所有映射 normal!命令将不会顾及当前所有映射 注意，在写vim脚本时，应该总是使用normal!，永不使用normal；不要信任用户在~/.vimrc中的映射 有时阅读一个vim命令的文档可以激发关于别的内容的奇思妙想","categories":[{"name":"Notes","slug":"Notes","permalink":"https://didongdongdi.github.io/categories/Notes/"}],"tags":[],"author":"DiDong"},{"title":"vimscript笔记——0——单行命令","slug":"vimscript笔记——0——单行命令","date":"2019-05-06T05:34:00.000Z","updated":"2019-05-27T05:39:44.876Z","comments":true,"path":"2019/05/06/vimscript笔记——0——单行命令/","link":"","permalink":"https://didongdongdi.github.io/2019/05/06/vimscript%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%940%E2%80%94%E2%80%94%E5%8D%95%E8%A1%8C%E5%91%BD%E4%BB%A4/","excerpt":"预备知识:echo $MYVIMRC得知.vimrc文件的位置","text":"预备知识:echo $MYVIMRC得知.vimrc文件的位置 打印信息:echo &quot;Hello, world!，信息不会保存 :echom &quot;Hello, world!，信息会保存 :messages，查看信息 设置选项:set &lt;name&gt;，打开选项 :set no&lt;name&gt;，关闭选项 :set &lt;name&gt;!，切换选项 :set &lt;name&gt;?，查看选项当前值 :set &lt;name&gt;=&lt;value&gt;，改变非布尔选项的选项值 :set &lt;name&gt; no&lt;name&gt; &lt;name&gt;=&lt;value&gt; ...，设置多个选项的值 基本映射:map 映射命令 原命令 &lt;keyname&gt;可用于特殊字符（按键） 模式映射nmap，normal模式下有效 vmap，visual模式下有效 imap，insert模式下有效 精确映射非递归映射，任何时候使用 noremap，任何模式下有效 nnoremap，normal模式下有效 vnoremap，visual模式下有效 inoremap，insert模式下有效 Leaderslet mapleader = &quot;;&quot;，Leader :let maplocalleader = &quot;,&quot;，Local Leader Abreviations用于insert、replace和command模式下 iabbrev 输入字符 输出字符 Keyword Characters，输入非字母、数字、下划线的字符就会引发abbreviations替换 本地缓冲区的选项设置和映射映射，e.g. :nnoremap &lt;buffer&gt; &lt;localleader&gt;x dd 设置，:setlocal &lt;name&gt; :setlocal no&lt;name&gt; 遮盖，本地缓冲区的映射会遮盖全局的映射 自动命令autocmd &lt;event0&gt;,&lt;event1&gt;,... &lt;pattern&gt; :&lt;command&gt; FileType事件，e.g. autocmd FileType python nnoremap &lt;buffer&gt; &lt;localleader&gt;c I#&lt;esc&gt; 本地缓冲区缩写iabbrev &lt;buffer&gt; 输入字符 输出字符 自动命令组为防止.vimrc中的autocmd ...自动命令被重复加载，需要将其放置在自动命令组中，并在自动命令组开头加上清除命令： e.g. 1234:augroup testgroup: autocmd!: autocmd BufWrite * :echom \"Cats\":augroup END Operator-Pending映射一个Operator（操作）就是一个命令，你可以在这个命令的后面输入一个Movement（移动）命令，然后Vim开始对文本执行前面的操作命令，这个操作命令会从你当前所在的位置开始执行，一直到这个移动命令会把你带到的位置结束。 常用Operator有d、y和c，e.g. 按键 操作 移动 dw 删除 到下一个单词 ci( 修改 在括号内 yt, 复制 到到逗号 Movement映射，:onoremap 映射命令 原命令 下面两条规则可以让你可以很直观的以多种方式创建operator-pending映射： 如果你的operator-pending映射以在可视模式下选中文本结束，Vim会操作这些文本。 否则，Vim会操作从光标的原始位置到一个新位置之间的文本。 e.g. :onoremap ah :&lt;c-u&gt;execute &quot;normal! ?^==\\\\+\\r:nohlsearch\\rg_vk0&quot;&lt;cr&gt; execute用于替换字符串中的所有特殊字符串 normal!用于执行后面的字符 状态条状态条中代码的通用格式：%-0{minwid}.{maxwid}{item}，除了%和item外其他都是可选的 分割，可以使用+=来一条一条地定义要显示的代码","categories":[{"name":"Notes","slug":"Notes","permalink":"https://didongdongdi.github.io/categories/Notes/"}],"tags":[],"author":"DiDong"},{"title":"vim方向键等功能按键和鼠标乱码解决","slug":"vim方向键等功能按键乱码解决","date":"2019-05-04T13:14:00.000Z","updated":"2019-05-26T05:15:09.000Z","comments":true,"path":"2019/05/04/vim方向键等功能按键乱码解决/","link":"","permalink":"https://didongdongdi.github.io/2019/05/04/vim%E6%96%B9%E5%90%91%E9%94%AE%E7%AD%89%E5%8A%9F%E8%83%BD%E6%8C%89%E9%94%AE%E4%B9%B1%E7%A0%81%E8%A7%A3%E5%86%B3/","excerpt":"问题描述突然之间vim的方向键等功能按键和鼠标在insert模式下出现乱码，在搜索一段时间后，大部分采用set compatible的方案，而我的.vimrc文件中已经有这句话了，只好采用了不是特别完美的解决方案","text":"问题描述突然之间vim的方向键等功能按键和鼠标在insert模式下出现乱码，在搜索一段时间后，大部分采用set compatible的方案，而我的.vimrc文件中已经有这句话了，只好采用了不是特别完美的解决方案 解决方案在.vimrc文件中添加如下代码： 12345678910111213141516\" 方向键乱码解决inoremap OA &lt;UP&gt;inoremap OB &lt;DOWN&gt;inoremap OC &lt;RIGHT&gt;inoremap OD &lt;LEFT&gt;\" 功能键乱码问题解决inoremap [6~ &lt;pagedown&gt;inoremap [5~ &lt;pageup&gt;inoremap OH &lt;home&gt;inoremap OF &lt;end&gt;inoremap [3~ &lt;del&gt;inoremap [2~ &lt;ins&gt;\" 鼠标设置set mouse=nvc 存在的问题 由于是采用映射的方法，所以会存在，在insert模式下按下被映射的字符时，如果速度过快，对应的字符不会输出而会转换为对应的命令，但是由于这些字符其中有些输入的可能性很小，所以问题不是很大 鼠标将insert模式下的功能禁用了","categories":[{"name":"Problem","slug":"Problem","permalink":"https://didongdongdi.github.io/categories/Problem/"}],"tags":[],"author":"DiDong"},{"title":"操作系统笔记——1——操作系统概述_操作系统实验环境准备_启动_中断_异常和系统调用","slug":"操作系统笔记——1——操作系统概述_操作系统实验环境准备_启动_中断_异常和系统调用","date":"2019-04-30T14:51:00.000Z","updated":"2019-08-01T03:17:03.040Z","comments":true,"path":"2019/04/30/操作系统笔记——1——操作系统概述_操作系统实验环境准备_启动_中断_异常和系统调用/","link":"","permalink":"https://didongdongdi.github.io/2019/04/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%941%E2%80%94%E2%80%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87_%E5%90%AF%E5%8A%A8_%E4%B8%AD%E6%96%AD_%E5%BC%82%E5%B8%B8%E5%92%8C%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/","excerpt":"操作系统的结构 一共分为四层 内核由系统调用接口、系统调用接口下的各个功能模块和硬件抽象层组成","text":"操作系统的结构 一共分为四层 内核由系统调用接口、系统调用接口下的各个功能模块和硬件抽象层组成 操作系统内核内核特征 并发 共享 宏观上, 同时访问 微观上, 互斥访问 虚拟, 多道程序设计 异步 程序的执行不是一贯到底的, 而是走走停停, 向前推进的速度不可知 只要运行环境相同, OS需要保证程序运行的结果相同 内核结构分类 单内核 单内核（Monolithic kernel），是个很大的进程。它的内部又能够被分为若干模块（或是层次或其他）。但是在运行的时候，它是个单独的二进制大映象。其模块间的通讯是通过直接调用其他模块中的函数实现的，而不是消息传递。 单内核结构在硬件之上定义了一个高阶的抽象界面，应用一组原语(或者叫系统调用)来实现操作系统的功能，例如进程管理，文件系统，和存储管理等等，这些功能由多个运行在核心态的模块来完成。 尽管每一个模块都是单独地服务这些操作，内核代码是高度集成的，而且难以编写正确。因为所有的模块都在同一个内核空间上运行，一个很小的bug都会使整个系统崩溃。然而，如果开发顺利，单内核结构就可以从运行效率上得到好处。 很多现代的单内核结构内核，如Linux和FreeBSD内核，能够在运行时将模块调入执行，这就可以使扩充内核的功能变得更简单，也可以使内核的核心部分变得更简洁。 单内核结构是非常有吸引力的一种设计，由于在同一个地址空间上实现所有低级操作的系统控制代码的复杂性的效率会比在不同地址空间上实现更高些。 单核结构正趋向于容易被正确设计，所以它的发展会比微内核结构更迅速些。 单内核结构的例子：传统的UNIX内核—-例如伯克利大学发行的版本，Linux内核。 微内核 微内核（Microkernelkernel）结构由一个非常简单的硬件抽象层和一组比较关键的原语或系统调用组成，这些原语仅仅包括了建立一个系统必需的几个部分，如线程管理，地址空间和进程间通信等。 用户模块间通信使用消息传递。 微核的目标是将系统服务的实现和系统的基本操作规则分离开来。例如，进程的输入/输出锁定服务可以由运行在微核之外的一个服务组件来提供。这些非常模块化的用户态服务器用于完成操作系统中比较高级的操作，这样的设计使内核中最核心的部分的设计更简单。一个服务组件的失效并不会导致整个系统的崩溃，内核需要做的，仅仅是重新启动这个组件，而不必影响其它的部分。 微内核将许多OS服务放入分离的进程，如文件系统,设备驱动程序,而进程通过消息传递调用OS服务。微内核结构必然是多线程的,第一代微内核,在核心提供了较多的服务,因此被称为’胖微内核’,它的典型代表是MACH。它既是GNU HURD也是APPLE SERVER OS的核心，第二代为微内核只提供最基本的OS服务,典型的OS是QNX,QNX在理论界很有名,被认为是一种先进的OS。 微内核只提供了很小一部分的硬件抽象，大部分功能由一种特殊的用户态程序：服务器来完成。微核经常被用于机器人和医疗器械的嵌入式设计中，因为它的系统的关键部分都处在相互分开的，被保护的存储空间中。这对于单核设计来说是不可能的，就算它采用了运行时加载模块的方式。 微内核的例子：AIX，BeOS，L4微内核系列，Mach中用于GNU Hurd和Mac OS X，Minix，MorphOS，QNX，RadiOS，VSTa。 混合内核 混合内核它很像微内核结构，只不过它的的组件更多的在核心态中运行以获得更快的执行速度。 混合内核实质上是微内核，只不过它让一些微核结构运行在用户空间的代码运行在内核空间，这样让内核的运行效率更高些。这是一种妥协做法，设计者参考了微内核结构的系统运行速度不佳的理论。然而后来的实验证明，纯微内核的系统实际上也可以是高效率的。大多数现代操作系统遵循这种设计范畴，微软公司开发的Windows操作系统就是一个很好的例子。另外还有XNU，运行在苹果Mac OS X上的内核，也是一个混合内核。 混合内核的例子： BeOS 内核 ，DragonFly BSD，ReactOS 内核 Windows NT、Windows 2000、Windows XP、Windows Server 2003以及Windows Vista等基于NT技术的操作系统。 外内核 外内核系统，也被称为纵向结构操作系统，是一种比较极端的设计方法。 外内核这种内核不提供任何硬件抽象操作，但是允许为内核增加额外的运行库，通过这些运行库应用程序可以直接地或者接近直接地对硬件进行操作。 它的设计理念是让用户程序的设计者来决定硬件接口的设计。外内核本身非常的小，它通常只负责系统保护和系统资源复用相关的服务。 传统的内核设计(包括单核和微核)都对硬件作了抽象，把硬件资源或设备驱动程序都隐藏在硬件抽象层下。比方说，在这些系统中，如果分配一段物理存储，应用程序并不知道它的实际位置。 而外核的目标就是让应用程序直接请求一块特定的物理空间，一块特定的磁盘块等等。系统本身只保证被请求的资源当前是空闲的，应用程序就允许直接存取它。既然外核系统只提供了比较低级的硬件操作，而没有像其他系统一样提供高级的硬件抽象，那么就需要增加额外的运行库支持。这些运行库运行在外核之上，给用户程序提供了完整的功能。 理论上，这种设计可以让各种操作系统运行在一个外核之上，如Windows和Unix。并且设计人员可以根据运行效率调整系统的各部分功能。 虚拟机管理器（VMM）建立和维护一个管理虚拟机的框架，同时为其他vxd程序（virtual X driver，虚拟设备驱动程序）提供许多重要的服务 VMW负责资源的隔离, 操作系统负责资源的管理 建议工具 shell命令: ls, cd, rm, pwd, … 系统维护工具: apt, git 源码阅读与编辑工具: eclipse-CDT, understand, gedit, vim 源码比较工具: diff, meld 开发编译调试工具: gcc, gdb, make 硬件模拟器: qemu 用户态与内核态结构 实验内容 注意: 扩展实验的内容尽可能去做, 扩展ucore, 不局限于上面的内容 80836相关知识四种运行模式实模式, 保护模式, SMM模式和虚拟8086模式 实模式 加电启动后处于实模式 软件可访问的物理内存空间不超过1MB, 无法发挥Intel 80386以上级别的32位CPU的4GB内存管理能力 保护模式 支持内存分页 提供了对虚拟内存的良好支持 支持多任务 支持优先级, 不同的程序可以运行在不同的优先级上; 优先级一共分0~34个级别,操作系统运行在最高的优先级0上, 应用程序则运行在比较低的级别上 配合良好的检查机制后, 既可以在任务间实现数据的安全共享也可以很好地隔离各个任务 逻辑地址, 线性地址, 物理地址 之间的区别 物理内存地址空间 处理器提交到总线上用于访问计算机系统中的内存和设备的最终地址, 此地址唯一 线性地址空间 在操作系统的虚存管理之下每个运行的应用程序能访问的地址空间 每个运行的应用程序认为自己独享整个计算机系统的地址空间, 这样可让多个运行的应用程序之间相互隔离 逻辑地址空间 应用程序直接使用的地址空间 地址转换 段机制启动, 页机制未启动: 逻辑地址 -&gt; 段机制处理 -&gt; 线性地址 = 物理地址 段机制和页机制都启动: 逻辑地址 -&gt; 段机制处理 -&gt; 线性地址 -&gt; 页机制处理 -&gt; 物理地址 寄存器寄存器种类 8组寄存器 通用寄存器 段寄存器 指令指针寄存器 标志寄存器 控制寄存器 系统地址寄存器, 调试寄存器, 测试寄存器 通用寄存器 EAX: 累加器 EBX: 基址寄存器 ECX: 计数器 EDX: 数据寄存器 ESI: 源地址指针寄存器 EDI: 目的地址指针寄存器 EBP: 基址指针寄存器 段寄存器 CS: 代码段(Code Segment) DS: 数据段(Data Segment) ES: 附加数据段(Extra Segment) SS: 堆栈段(Stack Segment) FS: 附加段 GS: 附加段 指令寄存器和标志寄存器 EIP(指令寄存器) EIP的低16位就是8086的IP, 存储下一条要执行指令的内存地址 在分段地址转换中, 表示指令的段内偏移地址 EFLAGS(标志寄存器) IF(Interrupt Flag): 中断允许标志位, 由CLI和STI两条指令来控制; 设置IF使CPU可识别外部(可屏蔽)中断请求; 复位IF禁止中断; IF对不可屏蔽外部中断和故障中断的识别没有任何作用 CF, PF, ZF, … ucore中用到的一些(通用)数据结构传统的双向循环链表及其缺点12345typedef struct foo&#123; ElemType data; struct foo *prev; struct foo *next;&#125;foo_t; 缺点: 需要为每种特定数据结构类型定义针对这个数据结构的特定链表插入, 删除等各种操作, 会导致代码冗余 ucore中使用的双向循环链表 1234567891011121314151617// 链表操作函数list_init(list_entry_t *elm)list_add_afterlist_add_beforelist_del(list_entry_t *listelm)// 访问链表节点所在的宿主数据结构#define le2page(le, member) to_struct((le), struct Page, member)#define to_struct(ptr, type, member)\\ ((type *)((char *)(ptr) - offsetof(type, member)))#define offsetof(type, member)\\ ((size_t)(&amp;((type *)0)-&gt;member))free_area_t free_area;list_entry_t *le = &amp;free_area.free_list;while((le=list_next(le))!=&amp;free_area.free_list)&#123; struct Page *p = le2page(le, page_link); ......&#125; 计算机启动流程 注意:内存可写与不可写内存逻辑上统一, 物理上分割 BIOS(Base Input Output System) 以中断方式提供了基本的I/O功能 INT 10h: 字符显示 INT 13h: 磁盘扇区读写 INT 15h: 检测内存大小 INT 16h: 键盘输入 只能在x86的实模式下访问 CPU初始化 CPU加电稳定后从0XFFFF0读第一条指令 CS:IP = 0xf000:fff0 第一条指令是跳转指令 CPU初始状态为16位实模式 CS:IP是16位寄存器 指令指针PC=16*CS+IP 最大地址空间是1MB(2^20B) BIOS初始化 硬件自检POST 检测系统中内存和显卡等关键部件的存在和工作状态 查找并执行显卡等接口卡BIOS, 进行设备初始化 执行系统BIOS, 进行系统检测 检测和配置系统中安装的即插即用设备 更新CMOS中的扩展系统配置数据ESCD 按指定启动顺序从软盘, 硬盘或光驱启动 BIOS启动固件 BIOS启动固件的内容 基本输入输出的程序(磁盘, 键盘, …) 系统设置信息(启动位置, …) 开机后自检程序 系统自启动程序等 Q: 为什么不直接从BIOS里头把操作系统的内核映像读进来?A: 磁盘上有文件系统(多种多样), 不能在机器刚出厂的时候就限制死磁盘文件系统的格式, 同时也不能在BIOS中加上认识所有文件系统代码. 有一个基本约定, 不需要认识格式, 也能从磁盘中读第一块(加载程序). 系统启动规范BIOS 固化到计算机主板上的程序 包括系统设置, 自检程序和系统自启动程序 BIOS-MBR(多分区需求, 主引导记录总共512字节, 只能描述最多4个分区, 每个占16字节), BIOS-GPT(全局唯一标识分区表, 可以描述更多的分区结构), PXE(网络启动, 加网络协议栈) UEFI 统一可扩展固件借口 接口标准 在所有平台上一致的操作系统启动服务 增加可信启动流程BIOS起来后, 读磁盘时, 对引导记录的可信性进行一个检查, 引导记录里有签名. 主引导记录MBR格式 分区引导扇区格式 加载程序 中断, 异常和系统调用 为什么需要系统调用 在计算机运行中, 内核是被信任的第三方 只有内核可以执行特权指令 方便应用程序 为什么需要中断和异常 当外设连接计算机时, 会出现什么现象? 当应用程序处理意想不到的行为时, 会出现什么现象? 系统调用希望解决的问题 用户应用程序是如何得到系统服务的? 系统调用和功能调用的不同之处是什么? 内核的进入与退出 三者的区别 系统调用(system call) 应用程序主动向操作系统发出的服务请求 异常(exception) 非法指令或者其他原因导致当前指令执行失败(如内存出错)后的处理请求 中断(hardware interrupt) 来自硬件设备的处理请求 中断和异常处理机制 硬件处理在CPU初始化时设置中断使能标志 依据内部或外部事件设置中断标志 依据中断向量调用相应中断服务例程 软件处理 现场保存(编译器) 中断服务处理(服务例程) 清除中断标记(服务例程) 现场恢复(编译器) 中断嵌套 硬件中断服务例程可被打断 不同硬件中断源可能在硬件中断处理时出现 硬件中断服务例程中需要临时禁止中断请求 中断请求会保持到CPU做出响应 异常服务例程可被打断 异常服务例程执行时可能出现硬件中断 异常服务例程可嵌套 异常服务例程可能出现缺页 系统调用 概念 操作系统服务的编程接口 通常由高级语言编写(C或者C++) 程序访问通常是通过高层次的API接口而不是直接进行系统调用 三种最常用的应用程序编程接口(API) Win32 API用于Windows POSIX API用于POSIX-based system(包括UNIX, LINUX, Mac OS X的所有版本) Java API用于JAVA虚拟机(JVM) 实现 每个系统调用对应一个系统调用号 系统调用接口根据系统调用号来维护表的索引 系统调用接口调用内核态中的系统调用功能实现, 并返回系统调用的状态和结果 用户不需要知道系统调用的实现 需要设置调用参数和获取返回结果 操作系统接口的细节大部分都隐藏在应用编程接口后(通过运行程序支持的库来管理) 示例文件复制过程中的系统调用序列 源文件———————————————&gt;目标文件 获取输入文件名 在屏幕显示提示 等待并接收键盘输入 获取输出文件名 在屏幕显示提示 等待并接收键盘输入 打开输入文件 如果文件不存在, 出错退出 创建输出文件 如果文件存在, 出错退出 循环 读取输入文件 写入输出文件 直到读取结束 关闭输出文件 在屏幕显示完成信息 正常退出 123456789101112131415161718192021#define SYS_fork 1#define SYS_exit 2#define SYS_wait 3#define SYS_pipe 4#define SYS_write 5#define SYS_read 6#define SYS_close 7#define SYS_kill 8#define SYS_exec 9#define SYS_open 10#define SYS_mknod 11#define SYS_unlink 12#define SYS_fstat 13#define SYS_link 14#define SYS_mkdir 15#define SYS_chdir 16#define SYS_dup 17#define SYS_getpid 18#define SYS_sbrk 19#define SYS_sleep 20#define SYS_procmem 21 read() 在ucore中库函数read()的功能是读文件 user/libs/file.h: int read(int fd, void *buf, int length) 库函数read()的参数和返回值 int fd –&gt; 文件句柄void *buf –&gt; 数据缓冲区指针int length –&gt; 数据缓冲区长度int return_value: 返回读出数据长度 库函数read()使用示例 int sfs_filetest1.c: ret = read(fd, data, len); 系统调用库接口示例 ucore系统调用read(fd, buffer, length)的实现 kern/trap/trapentry.S: alltraps() 用户态一个int进到内核, 这是一个软中断, 所有这些到这段汇编程序, 获取到中断所需的相关信息组成的数据结构(tf) kern/trap/trap.c: trap() tf-&gt;trapno == T_SYSCALL T_SYSCALL: 系统调用对应的中断向量 kern/syscall/syscall.c: syscall() tf-&gt;tf_regs.reg_eax == SYS_read reg_eax: 系统调用编号 kern/syscall/syscall.c: sys_read() 从tf-&gt;sp 获取fd, buf, length 参数(从用户态转到内核态) kern/fs/sysfile.c: sysfile_read() 读取文件 实现直接操作底下的驱动程序 kern/trap/trapentry.S: trapret() ireturn: 将读到的内容的长度返回给用户态 函数调用与系统调用的不同 系统调用INT和IRET指令用于系统调用有堆栈切换和特权级的转换 函数调用CALL和RET用于常规调用没有堆栈切换 注意 由于系统调用的量很大, 系统调用中断向量表之后总共占用一个中断编号不同的系统调用功能, 用系统调用表来实现, 从而根据系统调用功能的不同, 选择不同的系统调用实现 所有的系统调用都是通过一个宏展开形成相应的函数 异常 OS发生异常时 有可能帮你解决问题, 如内存访问错误, 通过虚拟内存的方式, 从而执行下一跳指令 或是终止应用程序, 操作系统收回资源, 如除零发生时 中断, 异常和系统调用的开销超过函数调用 开销 引导机制 切换用户态和内核态 建立内核堆栈 验证参数 内核态映射到用户态的地址空间, 更新页面映射权限 切换到内核态时, 访问代码有切换, 内核需要访问用户态的一些信息, 这些映射会导致缓存有变化 内核态独立地址空间, TLB Translation Lookaside Buffer 转换检测缓冲区是一个内存管理单元, 用于改进虚拟地址到物理地址转换速度的缓存 会有失效 x86启动顺序寄存器初始值 第一条指令 CS = F00H, EIP = 0000FFF0H 实际地址是: Base + EIP = FFFF0000H + 0000FFF0H = FFFFFFF0H 这是BIOS的EPROM(Erasable Programmable Read Only Memory)所在地 当CS被新值加载, 则地址转换规则将开始起作用 通常第一条指令是一条长跳转指令(这样CS和EIP都会更新)到BIOS代码中执行 处于实模式的段 从BIOS到Bootloader BIOS加载存储设备(比如软盘, 硬盘, 光盘, USB盘)上的第一个扇区(主引导扇区, Master Boot Record, or MBR)的512字节到内存的0x7c00 … 然后跳转到@ 0x7c00的第一条指令开始执行 从bootloader到OS bootloader做的事使能保护模式(protection mode) &amp; 段机制(segment-level protection) 使能保护模式, bootloader/OS要设置CR0的bit 0 (PE)段机制在保护模式下是自动使能的从硬盘上读取kernel in ELF格式的ucore kernel(跟在MBR后面的扇区)并放到内存中固定位置跳转到ucore OS的入口点(entry point)执行, 这时控制权到了ucore OS中 段机制 说明GDT: 全局描述符表(段表), 由bootloader建立gdtdesc: 段描述符index: GDT中的索引RPL: 段的优先级(0, 1, 2, 3)GDTR: 段表寄存器 加载ELF格式的ucore OS kernel12345678910111213141516171819202122232425262728struct elfhdrd&#123; uint magic; //must equal ELF_MAGIC uchar elf[12]; ushort type; ushort machine; uint version; uint entry; //program entry point(in va) uint phoff; //offset of the program headerr tables uint shoff; uint flags; ushort ehsize; ushort phentsize; ushort phnum; //number of program header tables ushort shentsize; ushort shnum; ushort shstrndx;&#125;struct proghdr&#123; uint type; //segment type uint offset; //beginning of the segment in the file uint va; //where this segment should be placed at uint pa; uint filesz; uint memsz; //size of the segment in byte uint flags; uint align;&#125; C函数调用的实现 理解C函数调用在汇编级是如何实现的 理解如何在汇编级代码中调用C函数 理解基于EBP寄存器的函数调用栈 其他需要注意事项参数(parameters) &amp; 函数返回值(return values)可通过寄存器或位于内存中的栈来传递不需要保存/回复(save/restore)所有寄存器 GCC内联汇编 什么是内联汇编? 这时GCC对C语言的扩张 可直接在C语句中插入汇编指令有何用处? 调用C语言不支持的指令 用汇编在C语言中手动优化如何工作? 用给定的模板和约束来生成汇编指令 在C函数内形成汇编源码 GCC内联汇编笔记 x86中的中断处理中断源 中断 Interrupts外部中断 External(hardware generated) interrupts串口, 硬盘, 网卡, 时钟, …软件产生的中断 Software generated interruptsThe INT n 指令, 通常用于系统调用 异常 Exceptions程序错误软件产生的异常 Software generated exceptionsINTO, INT 3 and BOUND机器检查出的异常S 确定中断服务例程(ISR) 切换到中断服务例程(ISR)不同特权级的中断切换对堆栈的影响 从中断服务例程(ISR)返回 系统调用 用户程序通过系统调用访问OS内核服务 如何实现 需要指定中断号使用Trap, 也称Software generated interrupt或使用特殊指令(SYSENTER/SYSEXIT) 关键习题 批处理的主要缺点是() 效率低 失去了交互性 失去了并行性 以上都不是 多道批处理系统主要考虑的是() 交互性 及时性 系统效率 吞吐量说明: 在单道批处理系统中, 内存中仅有一道作业. 无法充分利用系统中的所有资源, 致使系统性能较差. 为了进一步提高资源的利用率和系统吞吐量, 由此形成了多道批处理系统. 下列选项中, 不可能在用户态发生的事件是() 系统调用 外部中断 进程切换 缺页说明:系统调用是提供给应用程序使用的, 由用户态发出, 进入内核态执行; 外部中断随时可能发生; 应用程序执行时可能发生缺页; 进程切换完全由内核来控制. 中断处理和子程序调用都需要压榨你以保护现场. 中断处理一定会保存而子程序调用不需要保存其内容的是() 程序计数器 程序状态字寄存器 通用数据寄存器 通用地址寄存器 CPU执行操作系统代码的时候称为处理机处于() 自由态 目态 管态 就绪态说明: 内核态又称为管态","categories":[{"name":"OS","slug":"OS","permalink":"https://didongdongdi.github.io/categories/OS/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://didongdongdi.github.io/tags/Notes/"}],"author":"DiDong"},{"title":"操作系统笔记——0","slug":"操作系统笔记——0","date":"2019-04-22T01:46:00.000Z","updated":"2019-06-08T03:12:21.746Z","comments":true,"path":"2019/04/22/操作系统笔记——0/","link":"","permalink":"https://didongdongdi.github.io/2019/04/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%940/","excerpt":"参考资料","text":"参考资料 课程网站 清华操作系统课程讨论区——piazza 汇编语言（https://www.jianshu.com/p/4a7b716a2d1b，http://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html，https://www.w3cschool.cn/assembly/，https://www.linuxprobe.com/gcc-how-to.html，https://www.cnblogs.com/lsgxeva/p/8948153.html） uCore OS实验指导书 操作系统课程问答 OS 2019 大实验部分内容 aos_course_info OS Tutorial Labs MOOC OS习题集 rcore_plus Make命令教程 Linux gdb调试器用法 学堂在线课程主要内容 实验楼 ucore_os_lab os_course_exercises ucore_os_docs ucore_os_info ucore_os_plus 《操作系统概念 第七版》 《操作系统精髓与设计原理 第八版》 Operating Systems - Three Easy Pieces gcc教程 shell脚本教程","categories":[{"name":"OS","slug":"OS","permalink":"https://didongdongdi.github.io/categories/OS/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://didongdongdi.github.io/tags/Notes/"}],"author":"DiDong"},{"title":"输入时自动删除后面的字","slug":"输入时自动删除后面的字","date":"2019-04-21T12:41:00.000Z","updated":"2019-05-26T05:15:09.000Z","comments":true,"path":"2019/04/21/输入时自动删除后面的字/","link":"","permalink":"https://didongdongdi.github.io/2019/04/21/%E8%BE%93%E5%85%A5%E6%97%B6%E8%87%AA%E5%8A%A8%E5%88%A0%E9%99%A4%E5%90%8E%E9%9D%A2%E7%9A%84%E5%AD%97/","excerpt":"按下键盘上的insert键，将输入模式改为插入","text":"按下键盘上的insert键，将输入模式改为插入","categories":[{"name":"Problem","slug":"Problem","permalink":"https://didongdongdi.github.io/categories/Problem/"}],"tags":[],"author":"DiDong"},{"title":"计算机网络专业术语目录（附解释）","slug":"计算机网络专业术语目录","date":"2019-04-21T03:22:00.000Z","updated":"2019-05-26T05:15:09.000Z","comments":true,"path":"2019/04/21/计算机网络专业术语目录/","link":"","permalink":"https://didongdongdi.github.io/2019/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD%E7%9B%AE%E5%BD%95/","excerpt":"整个目录参考自百度文库；增加了某些名词；增加了解释；目录并不完整，解释也有可能并不全面甚至空白，或者存在错误，还请指正。 计算机网络专业术语目录","text":"整个目录参考自百度文库；增加了某些名词；增加了解释；目录并不完整，解释也有可能并不全面甚至空白，或者存在错误，还请指正。 计算机网络专业术语目录 英文名词 中文翻译 名词解释 Persistent HTTP 持久性HTTP或坚持的HTTP 建立TCP连接后，可以持续传输对象，而不需要重复建立连接 Nonpersistent HTTP 非持久HTTP或非坚持HTTP 建立TCP连接后，每发送完一个对象后，再次发送下一个对象需要重新建立连接 stop-and-wait 停等 一个一个地发送报文段，只有在收到上一个的肯定确认，才能发送下一个，即非流水线 NAT（Network Address Translation） 网络地址转换 在公有IP地址和私有IP地址之间进行转换，每个外网端口号对应内网主机当中的一个进程 Flooding 洪泛 每次收到邻居节点消息之后都无条件转发给其他邻居，导致消息被重复转发，占用资源 PDU（Protocol Data Unit） 协议数据单元 同一层所有协议处理的数据单元（消息，报文段，数据报，帧，bit） Average Throughput 平均吞吐量 一段时间内的平均传输成功的数据的量 Congestion Control 拥塞控制 调节发送端发包速率，避免路由器缓存溢出 Flow Control 流量控制 调节发送端发包速率，防止接收端缓存溢出 Carrier Sense 载波侦听 一个节点在传输前先听信道 End system 端系统 除了传统的PC、Linux工作站等还包括手机、TV等一众可以连接到互联网的设备 Modem 调制解调器 进行数字信号和模拟信号之间的转换 Base station 基站 将有线信号转换为无线信号 Communication link 通信链路 传输信号的物理线路 Physical media 物理介质 信号传输的载体 Coaxial cable 同轴电缆 一种物理通信链路 Fiber optics 光纤 一种速度接近光速的物理通信链路 Radio spectrum 射频频谱 无线传输链路 Transmission rate 传输速率 不同的链路传输数据的速率 Packets （数据）包或分组 信息打包的结果 Routers 路由器 分组交换机的一种，3层网络设备，可隔离冲突域 Link-layer switches 链路层交换机 分组交换机的一种，二层网络设备，可隔离冲突域 Path 路径 一个分组从发送端传输到接收端所经过的通信链路和分组交换机的顺序 ISP (Internet Service Provider) 网络服务提供商 每个ISP是一个由多个分组交换机和多段通信链路组成的网络 TCP (Transmission Control Protocol) 传输控制协议 一种运输层协议；特点：点对点、传输可靠有序的字节流、流水线、发送端和接收端缓存、全双工、面向连接、拥塞控制、流量控制 IP ( Internet Protocol) 网际协议 一种网络层协议 Intranets 内网 相对于外网来说，即局域网 API (Application Programming Interface) 应用程序编程接口 应用层提供的用于一个端系统上的应用程序通过网络基础设施向另一个端系统上的应用程序发送数据的接口 Network edge 网络边缘 主要由端系统组成，人们日常接触的部分 Access Networks 接入网 连接一个端系统到第一个路由器（在该端系统到遥远的端系统的路径上）（边缘路由器） Ethernet 以太网 一种链路层协议 Network core 网络核心 由分组交换机和通信链路组成 Circuit Switching 电路交换 在端系统间通信会话期间，预留了端系统间通信的沿路径所需要的资源（缓存，链路传输速率） Packet Switching 分组交换 源将长报文分成较小的数据包（分组），每个分组通过通信链路和分组交换机传送，分组以等于该链路的最大传输速率的速度传输通过通信链路 FDM (frequency-division multiplexing) 频分多路复用 链路的频谱由跨越链路创建的所有连接所共享，在连接期间链路为每条连接专用一个频段 TDM (time-division multiplexing) 时分多路复用 网络在每个帧中为该连接指定一个时隙，这些时隙专门由该连接单独使用 Statistical Multiplexing 统计复用 与TDM类似，但是是异步，即把公共信道的时隙实行按需分配，只对那些需要传送信息或正在工作的终端才分配给时隙 Store-and-forward 存储转发 在交换机能够开始向输出链路传输该分组的第一个比特之前，必须接收到整个分组 Queuing delays 排队延迟 到达分组交换机的分组在输出缓存中等待的时延 Transmission delay 传输延迟或发送延迟 将所有分组的比特推（传输）向链路所需要的时间 Propagation delay 传播延迟 一个比特从该链路的起点到链路端路由器传播所需要的时间 Throughput 吞吐量 接收端成功接收的数据的速度 Internet backbone 骨干网 用来连接多个区域或地区的高速网络 Delay 延迟或时延 一个报文或分组从一个网络的一端传送到另一个端所需要的时间 Loss 丢包 分组到达分组交换机时发现输出缓存已经被其他等待传输的分组完全充满，到达的分组或已经排队的分组之一将被丢弃 Packet-Switched Network 分组交换网络 采用分组交换技术组成的网络 Nodal processing delay 节点处理延迟 检查分组首部和决定将该分组导向何处所需要的时间 End-to-end delay 端到端延迟 （在网络无拥塞，即排队时延微不足道，源主机和目的主机之间有N-1台路由器的情况下）端到端时延 = N（处理时延+传输时延+传播时延） Instantaneous throughput 瞬时吞吐量 任何时间瞬间接收端成功接收数据的速率 Network interface card 网络接口卡(即网卡) 物理硬件 Message 消息或报文 应用层PDU Segment 报文段 运输层PDU Datagram 数据报 网络层PDU Frames 帧 链路层PDU Packet sniffer 数据包监听器 监听数据包 Protocol Stack 协议栈 各层的所有协议 Peer entities 对等实体 执行对等协议的实体 Server farm 服务器集群 将很多服务器集中起来一起进行同一种服务，在客户端看来就像是只有一个服务器 Infrastructure 基础设施或基础架构 网络的物理设施 Self-scalability 自扩展性 系统自身通过添加资源来处理增长的工作 Timing 实时性 时钟信号能够准确的定时，各处的时钟能够达到一致，在不同的场合需要达到ns级、us级 Bandwidth-sensitive applications 带宽敏感应用 对带宽大小、稳定性等要求严格的应用 Connection-oriented service 面向连接的服务 通信双方在通信时,要事先建立一条通信线路,其过程有建立连接、使用连接和释放连接三个过程 Directory service 目录服务 一个储存、组织和提供信息访问服务的软件系统，在软件工程中，一个目录是指一组名字和值的映射 Base HTML file 基本HTML文件 即超文本标记语言文件 Stateless protocol （HTTP）无状态协议 协议对于事务处理没有记忆能力；缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大；另一方面，在服务器不需要先前信息时它的应答就较快 RTT (round-trip time ) 往返时间 表示从发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据后便立即发送确认，不包含数据传输时间）总共经历的时间 Web proxy caches 网页代理缓存 中间代理服务器，用于保存最近请求的对象 Status line 状态行 HTTP协议状态行，格式：HTTP版本号 状态号 原因描述&lt;CRLF&gt; Out-of-band (频)带外(的) 传输某些数据时，使用与普通数据不同的通道 In-band 带内(的) 传输某些数据时，使用与普通数据相同的通道 User agents 用户代理 用户与网络应用程序之间的接口 Mail servers 邮件服务器 负责电子邮件收发管理的设备 Pull protocol 拉式协议 用于获取报文（SMTP） Push protocol 推式协议 用于发送报文（POP3，HTTP，IMAP） Host aliasing 主机别名 相对于规范主机名来说，通常比规范主机名更容易记忆的主机名 Canonical hostname 规范主机名 主机一开始的主机名 Mail server aliasing 邮件服务器别名 相对于一般邮件服务器名来说，通常比其更加容易记忆 Load distribution 负载分配 由于一个主机别名可能对应多个 规范主机名/IP地址/服务器，DNS可以将不同客户端对服务器的访问通过循环的方式，分配到不同的服务器上 Top-level domain (TLD) servers 顶级域名服务器 负责顶级域名以及所有国家的顶级域名的服务器 Authoritative DNS servers 权威域名服务器 收藏了公共可访问DNS记录的服务器 Iterative queries 迭代查询 本地DNS服务器依次访问根、TLD、权威DNS服务器，访问后，马上返回结果，继续访问下一个 Resource records (RRs) 资源记录 一个4元组：（name，value，type，TTL） Overlay network 覆盖网 一种创建在另一网络之上的计算机网络（覆盖网络中的节点可以被认为是通过虚拟或逻辑链接相连，其中每个链接对应一条路径（Path）。节点之间也可能通过下层网络中的多个物理连接实现相连。 例如对等网络或客户-服务器应用这类分布式系统都可视为覆盖网络，因为它们的节点都运行在因特网之上。 因特网自身最初也是作为一个电话网络之上的覆盖网络构建，而当今（借由VoIP的引入），电话网络正越来越变成一个创建在因特网之上的覆盖网络。） Peer-to-Peer (P2P) Network 对等网络 通信双方既可以作为服务器，又可以作为客户端 Socket programming 套接字编程 通过套接字的网络编程接口，实现不同终端的进程之间的通信 Multiplexing and demultiplexing 复用与分用 多路复用（在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息从而生成报文段，然后将报文段传递到网络层） 多路分解（将运输层报文段中的数据交付到正确的套接字） Unidirectional data transfer 单向数据传送 数据只能从一端传送到另一端，不能双向传送 Finite-state machine (FSM) 有限状态机 表示有限个状态以及在这些状态之间的转移和动作等行为的数学模型 Positive acknowledgments 肯定确认 ACK，成功接收到数据 Negative acknowledgments 否定确认 NACK，数据接收失败 Countdown timer (倒数)计时器 用于判断报文段传输是否超时，基于时间的重传机制 Cumulative acknowledgment 累积确认 发送方收到一个对序号为n的分组的确认的ACK，表明接收方已正确接收到序号为n的以前且包括n在内的所有分组 Receive buffer 接收缓冲区或接收缓存 接收方用于缓存正确接收到的报文段，和重组乱序的报文段 Resource-management cells 资源管理单元 在网络辅助（ATM ABR）拥塞控制中，数据单元从源经过一系列中间交换机传输到目的地，在数据单元中夹杂着资源管理单元，用来在主机和交换机之间传递与拥塞相关的信息，交换机和主机都可发送RM单元，RM单元可用来提供直接网络反馈和经由接收方的网络反馈 Source (port number) 源端口号 标识源主机进程 Destination (port number) 目的端口号 标识目的主机进程 Checksum 校验和 用于检验接收到的报文段是否出错 Pipelined protocols 流水线(型)协议 与停等协议相对，一次可以发送多个报文段，不需要等到上一个报文段的肯定确认 Go-back-N 回退N 一次只能发送一定数量的报文段，当一个报文段传输失败时，该报文段之前未被确认的报文段都会重传 Selective Repeat 选择重传 只重传确认传输失败的报文段 Timeout (定时器)超时 未在指定时间内接收到对某一报文段的肯定确认 Fast Retransmit 快速重传 收到3个冗余ACK，TCP执行快速重传，即在该报文段的定时器过期之前重传丢失的报文段 Three way handshake 三次握手 TCP连接建立时的三次握手（SYN，SYN+ACK，ACK） sequence number 序列号(简写为 seq) 报文段数据的第一个字节在整个字节流中的序号，用来标识报文段 acknowledgement number 确认号(简写为 ack;注意与大写的 ACK 不同) ack=seq+对应报文段数据部分的长度（字节），没有数据时+1 AIMD（additive increase, multiplicative decrease） 加性增乘性减 拥塞控制技术中，当cwnd超过法制ssthresh后，线性增长，每个RRT内+1MSS，称为加性增；在TCP Reno下，当cwnd增长到某值，出现3个冗余ACK事件时（不是计时器超时），cwnd减半，称为乘性减 Slow Start 慢启动 起始cwnd为1个MSS，然后以2的指数增长，这样TCP发送速率起始慢 congestion-avoidance 拥塞避免 前一部分同加性增；后一部分，当定时器超时（未收到三个冗余ACK），发生丢包，ssthresh设置为cwnd的一半，cwnd设置为1个MSS，然后进入慢启动阶段（TCP Tahoe） fast recovery 快速恢复 在乘性减后，对于引起TCP进入快速恢复状态的缺失报文段，对收到的每个冗余ACK，cwnd的值增加一个MSS duplicate (ACK) 冗余(ACK) 对一个报文段的重复确认，导致对下一个报文段的重传 Random Early Detection 随机早期检测 一种AQM（主动队列管理）算法，用来计算路由器平均队列长度，以此作为对拥塞程度的估计；计算丢弃分组的概率；平均队列长度小于最小阀值，到达的分组被接纳；大于最大阀值，被标记或丢弃；在这之间，被以某种概率标记或丢弃 Forwarding table 转发表 路由器检查到达分组首部字段的值，使用该值在该路由器的转发表中索引查询，存储在转发表项中的该首部的值指出了该分组将被转发的路由器的输出链路接口 Virtual-circuit networks 虚电路网络 仅在网络层提供连接服务的计算机网络 Datagram networks 数据报网络 仅在网络层提供无连接服务的计算机网络 Signaling message 信令报文 虚电路网络中，端系统向网络发送指示虚电路启动与终止的报文，以及路由器之间传递的用于建立虚电路（即修改路由器表中的连接状态）的报文 CAM（Content Addressable Memory） 内容可寻址存储器 用于查找，在基本常数时间内返回对该地址的转发表项的内容 Crossbar switch 纵横开关 纵横式开关是一组以二维阵列排列的接触器,外围有一个框架,框架内部有数支连着多重接触器的垂直选择杆 Active queue management 主动队列管理 分组丢弃与标记策略 Head-of-the-line (HOL) 队头或线路前部 输入排队交换机的线路前部，注意HOL阻塞（即队列的第一个数据包被阻塞，原因是输出端口的竞争，交换结构只能选择一个数据报先传输 Classless interdomain routing (CIDR) 无类域间路由 IP地址的网络部分不受限制，即没有ＡＢＣＤＥ类地址的划分 Plug-and-play 即插即用 DHCP（动态主机配置协议）具有能将主机连接进一个网络的网络相关方面的自动能力，故它又被称为即插即用协议 Anycast 任播 IPv6中引入了任播地址，这种地址可以使数据交付给一组主机中的任意一个（例如，这种特性可用于向一组包含给定文档的镜像站点中的最近的一个发送一个HTTP GET报文） IGP（Interior gateway protocols） 内部网关协议 又称为AS内部路由选择协议，一个自治网络内网关（主机和路由器）间交换路由信息的协议；路由信息能用于网间协议（IP）或者其它网络协议来说明路由传送是如何进行的；IGP协议包括RIP、OSPF、IS-IS、IGRP、EIGRP RIP（Routing information Protocol） 路由信息协议 一种DV（距离向量）协议，使用跳数作为其费用测度，每条链路的费用为1，一条路径的最大费用被限制为15，因此RIP的使用限制在网络直径不超过15跳的自治系统内 OSPF（Open shortest Path First） 开放最短路径优先 自治系统内部的路由选择算法，其核心是一个使用洪泛链路状态协议和一个Dijkstra最低费用路径算法 ABR（Area border routers） 区域边界路由器 位于一个或多个OSPF区域的一个路由器，其连接这个区域到骨干网络 Sequence-number-controlled flooding 序列号控制的洪泛或带序列号的受控洪泛 源节点将其地（或其他唯一标识符）以及广播序列号放入广播分组，再向它的所有邻居发送该分组；每个节点维护它已经收到的、复制的和转发的源地址和每个广播分组的序号列表 RPF(Reverse path forwarding) 逆向路径转发 当一台路由器接收到具有给定源地址的广播分组时，仅当该分组到达的链路正好是位于它自己的返回其源的最短单播路径上，它才向其所有初链路传输报文；否则，路由器只是丢弃分组而不转发 Rendezvous point 汇聚点 基于中心的方法建立一棵生成树时，要定义一个中心节点（也称为汇合点或核）；节点向中心节点单播加入树报文 Longest prefix matching 最长前缀匹配 在IP协议中，被路由器用于在路由表中进行选择的一个算法；路由表中的每个表项都指定了一个网络，所以一个目的地址可能与多个表项匹配；最明确的一个表项——即子网掩码最长的一个——就叫做最长前缀匹配；与目的地址的高位匹配得最多的表项 Scheduling 调度 Fragmentation 分片或分段 IP数据报分片，分片后的每个数据报中数据部分的大小 = MTU - 首部大小，同时数据部分大小须是8字节的整数倍 Fragment Offset 报文段偏移量 分片后，相对于原来的数据报，分片后的数据报数据部分首字节的字节序号，单位为8字节 NAT traversal NAT穿越 处于使用了NAT设备的私有TCP/IP网络中的主机之间建立连接 Multicast 组播或多播 在发送者和每一接收者之间实现点对多点网络连接；如果一台发送者同时给多个接收者传输相同的数据，也只需复制一份相同的数据包；它提高了数据传送效率，减少了骨干网络出现拥塞的可能性 Unicast 单播 发送者和每一接收者之间实现点对点网络连接；如果一台发送者同时给多个的接收者传输相同的数据，也必须相应的复制多份的相同数据包 Tunneling 隧道技术 两个IPv6节点使用IPv6数据报进行交互，但中间经IPv4路由器互联，则中间IPv4路由器的集合称为一个隧道；整个IPv6数据报放到一个IPv4数据报的数据（有效载荷）字段中 Link-State Routing Algorithm 链路状态路由算法 具有全局状态信息的算法，该算法必须知道网络中每条链路的费用 Distance Vector Routing Algorithm 距离向量路由算法 分散式路由选择算法，每个节点维护到网络中所有其他节点的费用（距离）估计的向量 Count to Infinity Problem 无穷计数问题 距离向量路由算法中，由于某一链路费用的增大，节点之间的信息不对称，所导致的数据报在几个相同的路由器之间不断路由，直到费用叠加到超过某一费用时结束 Hierarchical Routing 分层路由 IS-IS区域提供了一种在IS-IS域中伸缩路由的方法；正常的IS-IS区域和连接它们的骨干区域形成两级的路由层次；区域内的路由称作一级路由；域内独立的区域之间的路由称作二级路由 AS（autonomous systems） 自治系统 每个AS由一组通常处在相同管理控制下的路由器组成（例如，由相同的ISP运营或属于相同的公司网络） BGP (Border Gateway Protocol) 边界网关协议 一个自治系统间路由选择协议：从相邻自治系统处获得子网可达信息；向本AS内部的所有路由器传播这些可达性信息；基于可达性信息和AS策略，决定到达子网的‘好’路由 in-network duplication 网内复制 broadcast storm 广播风暴 当网络中存在环时，由于采用洪泛方法实现广播，会导致一个广播分组在环内不断被复制转发 spanning tree 生成树 为了避免广播风暴和冗余广播分组的传输，生成网络的生成树，使得广播时，每个节点只接收一个广播分组的副本 redundant packets 冗余数据包 接收到的重复的数据包 Broadcast channels 广播信道 一种链路层信道，这种信道用于连接有线局域网、卫星网和HFC（混合光纤同轴电缆）接入网中的多台主机；需要媒体访问协议来协调帧传输 Trailer fields 尾部字段 以太网帧的最后有CRC校验字段 Link access 链路接入或链路访问 链路层提供的服务之一；MAC（媒体访问控制）协议规定了帧在链路上传输的规则 NIC（Network interface card） 网络接口卡(即网卡) 链路层的主体部分在其中实现，又称为网络适配器 Parity checks 奇偶校验 一种数据校验方法，二维奇偶校验既可以检验，也可以纠错 FEC（Forward error correction) 前向纠错 接收方检测和纠正差错的能力 CRC（Cyclic Redundancy Check） 循环冗余校验 广泛应用的差错检测技术 Polynomial code 多项式码(即CRC码) CRC编码将要发送的比特串看作系数为0和1的一个多项式 Multiple access 多路接入或多路访问 多个发送和接收节点对一个共享广播信道的访问 Random access protocols 随机接入协议 一大类多访问协议：一个传输节点总是以信道的全部速率进行发送；当有碰撞时，设计碰撞的每个节点反复地重发它的帧，到该帧无碰撞地通过为止；但是碰撞后，不立即重发，而是在重发前等待一个随机时延 CSMA/CD 带冲突检测的载波侦听多路访问 在发送帧的同时对信道进行侦听，以确定是否发生冲突，若在发送数据过程中检测到了冲突，则发送阻塞信息并立即停止发送数据，然后等待随机时间再次发送 CSMA/CA 带冲突避免的载波侦听多路访问 利用ACK信号来避免冲突的发生，也就是说，只有当客户端收到网络上返回的ACK信号后才确认送出的数据已经正确到达目的地址；用于无线传输，因为无线传输时半双工，无法在发包的同时检测冲突，故一旦冲突发生，发包也不会停止，故应该尽量避免冲突 Token passing protocol 令牌传递协议 轮流协议中的一种；没有主节点，一个称为令牌的小的特殊帧在节点之间以某种固定的次序进行交换 ARP（Address Resolution Protocol） 地址解析协议 进行网路层地址（如IP地址）和链路层地址（MAC地址）的转换 Preamble 前导(字段) 以太网帧中开始的部分，8个字节；前7个字节的值都是10101010，用于“唤醒”接收适配器，并且将它们的时钟和发送方的时钟同步；最后一个字节的值是10101011，最后两个比特（第一个出现的两个连续的1）警告适配器B，“重要的内容“要来了 Exponential backoff 指数回退或指数退避 用于以太网以及DOCSIS电缆网络多路访问协议中的二进制指数后退算法；用于实现，当碰撞节点数量较少时，时间间隔较短，当碰撞节点数量较大时，时间间隔较长；时间间隔从0～2^n-1之间选择，n为发生碰撞的次数 Repeater 中继器或转发器 物理层设备，在输入端接收信号并在输出端再生该信号 Virtual-channel identifier 虚拟信道标识 Cell-loss priority 信元丢失优先权 LSR（Label-switched router） 标签交换路由器 一类路由器，位于一个多协议标签交换(MPLS)网络的中间；它为转换这个标签用于路由分组负责；当一个LSR接收到一个分组，它使用这个包含在这个分组头部的标签作为一个索引来决定在标签交换通道(LSP)中的下一跳，和一个来自查寻表分组相应的标签；旧的标签然后被从这个头部移除，和在这个分组被路由转发之前被替换为新的标签。 Framing (封装)成帧 将数据包封装在链路层帧中 error detection 误差检测或检错 检测比特差错，主要有奇偶校验、检验和、循环冗余检测 Channel Partitioning 信道分割式(MAC 协议) TMD（时分多路复用）、（FMD）频分多路复用、CDMA（码分多址） Taking turns MAC protocol 轮流式 MAC 协议 当只有一个节点活跃时，该活跃节点具有R bps的吞吐量；当有M个节点活跃时，每个活跃节点的吞吐量接近R/M bps；主要有轮询协议（有主节点）和令牌传递协议（无主节点，有令牌） Collision 冲突或碰撞 所有节点同时接收到多个帧；没有一个接受节点能够有效地获得任何传输的帧；碰撞帧的信号纠缠在一起 Time Slot 时隙 TDM（时分多路复用）将时间划分为时间帧，并进一步划分每个时间帧为N个时隙 Slotted ALOHA 时隙ALOHA 如果有碰撞，该节点在时隙结束之前检测到这次碰撞；该节点以概率p在后续的每个时隙中重传它的帧，直到该帧被无碰撞地传输出去 Unslotted ALOHA 无时隙ALOHA 与时隙ALOHA相比，不分时隙，任何时刻都可以发送，因此更加容易引发碰撞，其效率是时隙ALOHA的一半 Nonpersistent CSMA 非坚持CSMA 它并不持续侦听信道，而是在冲突时，等待随机的一段时间；它有更好的信道利用率，但导致更长延迟 1-persistent CSMA 1坚持CSMA 当信道忙或发生冲突时，要发送帧的站，不断持续侦听，一有空闲，便可发送；其中，长的传播延迟和同时发送帧，会导致多次冲突，降低系统性能 p-persistent CSMA p坚持CSMA 它应用于分槽信道，按照P概率发送帧；即信道空闲时，这个时槽，欲发送的站P概率发送，Q=1-P概率不发送；若不发送，下一时槽仍空闲，同理进行发送；若信道忙，则等待下一时槽，若冲突，则等待随机的一段时间，重新开始. Token Ring 令牌环 令牌传递协议中，由于令牌的传递所形成的节点相连的环状结构 (Wireless) LAN (无线)局域网 在某一区域内由多台计算机互联成的计算机组 Hub 集线器 物理层设备，作用于各个比特，重新生成这个比特，将其能量强度放大，并将该比特向其他所有接口传输出去；不能隔离冲突域 Collision domain 冲突域 在以太网中，如果某个CSMA/CD网络上的两台计算机在同时通信时会发生冲突，那么这个CSMA/CD网络就是一个冲突域 Bridge 网桥 早期的两端口二层网络设备，用来连接不同网段；可隔离冲突域；也叫桥接器，是连接两个局域网的一种存储/转发设备，它能将一个大的LAN分割为多个网段，或将两个以上的LAN互联为一个逻辑LAN，使LAN上的所有用户都可访问服务器 subnet mask 子网掩码 将某个IP地址划分成网络地址和主机地址两部分 MTU（Maximum Transmission Unit） 最大传输单元 种通信协议的某一层上面所能通过的最大数据报大小（以字节为单位） DHCP（Dynamic Host Configuration Protocol） 动态主机设置协议 一个局域网的网络协议，使用UDP协议工作，主要有两个用途：用于内部网或网络服务供应商自动分配IP地址；给用户用于内部网管理员作为对所有计算机作中央管理的手段 HTTP 超文本传输协议 一种网络协议，用于从WWW服务器传输超文本到本地浏览器 SR（selective repeat） 选择重传 通过让发送方仅重传那些它怀疑在接收方出错（即丢失或受损）的分组而避免了不必要的重传 推荐 推荐qjm的计网复习资料Chapter 1Chapter 2Chapter 3Chapter 4Chapter 5 推荐CHOOOU的《计算机网络：自顶向下的方法 第六版》课后习题答案第一章第二章第三章第四章第五章","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://didongdongdi.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[],"author":"DiDong"},{"title":"使用extundelete恢复linux上已删除的文件","slug":"使用extundelete恢复linux上已删除的文件","date":"2019-04-16T10:27:00.000Z","updated":"2019-05-26T05:15:09.000Z","comments":true,"path":"2019/04/16/使用extundelete恢复linux上已删除的文件/","link":"","permalink":"https://didongdongdi.github.io/2019/04/16/%E4%BD%BF%E7%94%A8extundelete%E6%81%A2%E5%A4%8Dlinux%E4%B8%8A%E5%B7%B2%E5%88%A0%E9%99%A4%E7%9A%84%E6%96%87%E4%BB%B6/","excerpt":"参考网址https://blog.51cto.com/ityunwei2017/2328570?source=dra http://extundelete.sourceforge.net/","text":"参考网址https://blog.51cto.com/ityunwei2017/2328570?source=dra http://extundelete.sourceforge.net/ https://sourceforge.net/p/extundelete/tickets/5/ 出现的问题 找不到库文件 源程序出错，需要打补丁 最后发现被删除的文件所在的文件系统不是ext3/ext4","categories":[{"name":"Problem","slug":"Problem","permalink":"https://didongdongdi.github.io/categories/Problem/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://didongdongdi.github.io/tags/%E6%95%99%E7%A8%8B/"}],"author":"DiDong"},{"title":"YouCompleteMe安装配置使用","slug":"YouCompleteMe安装","date":"2019-04-04T08:58:00.000Z","updated":"2019-05-26T05:15:09.000Z","comments":true,"path":"2019/04/04/YouCompleteMe安装/","link":"","permalink":"https://didongdongdi.github.io/2019/04/04/YouCompleteMe%E5%AE%89%E8%A3%85/","excerpt":"vim相关vim的version必须为7.4+，同时要支持Python/Python3，查看命令vim --version，支持的话，前面会有+，否则为- 如果不支持Python或者vim版本太低，需要重新编译安装vim","text":"vim相关vim的version必须为7.4+，同时要支持Python/Python3，查看命令vim --version，支持的话，前面会有+，否则为- 如果不支持Python或者vim版本太低，需要重新编译安装vim 参考： https://www.jianshu.com/p/aac78ff576c5中的./configure参数选项 https://blog.csdn.net/a464057216/article/details/52821171中的流程 安装vim的vundle插件管理器参考： https://blog.csdn.net/zhangpower1993/article/details/52184581，注意，将要复制到.vimrc中的配置信息的示例插件安装的内容注释掉，即将没有必须要求的部分注释掉，避免安装上示例插件导致速度很慢 安装YouCompleteMe参考： https://www.jianshu.com/p/4cbdadab3ad0中的主要流程 完成最后一步时，会出错，提醒你先执行命令，git submodule update --init --recursive，执行即可，确保网络通畅 然后再执行./install.py --all或者./install.py --all，执行到最后可能会提示，没有msbuild和xbuild，这两个家伙貌似是用来支持C#的，如果不需要C#的话，可以不管，需要的话，再看吧 参考： https://blog.csdn.net/lyh__521/article/details/46295775 主要是将YouCompleteMe通过vundle安装，即修改.vimrc，再在vim中执行PluginInstall 最重要的是，在.vimrc中添加let g:ycm_global_ycm_extra_conf = &#39;~/.vim/bundle/YouCompleteMe/cpp/ycm/.ycm_extra_conf.py&#39;，注意将后面的地址改成你的.ycm_extra_conf.py文件的地址，注意list -a，这个文件找找吧，找找就有了","categories":[{"name":"Problem","slug":"Problem","permalink":"https://didongdongdi.github.io/categories/Problem/"}],"tags":[],"author":"DiDong"},{"title":"chrome视频画面卡顿，声音无影响","slug":"chrome视频画面卡顿，声音无影响","date":"2019-04-02T09:04:00.000Z","updated":"2019-05-26T05:15:09.000Z","comments":true,"path":"2019/04/02/chrome视频画面卡顿，声音无影响/","link":"","permalink":"https://didongdongdi.github.io/2019/04/02/chrome%E8%A7%86%E9%A2%91%E7%94%BB%E9%9D%A2%E5%8D%A1%E9%A1%BF%EF%BC%8C%E5%A3%B0%E9%9F%B3%E6%97%A0%E5%BD%B1%E5%93%8D/","excerpt":"Chrome的话，使用WebRTC，本身不支持H.264（国内视频网站多用这个来编码），但是支持VP8（目前主流，Youtube使用VP8（性能和H264差不多）,现在逐步走向VP9（性能和H265差不多），所以H264采用的是外部的解码，因此可能性能上会略差。 另外实际测试的时候，相同掉包率情况下，VP8的画面丢失和花屏的情况要远好过H264（WebRTC下）。转自知乎Lennith的回答","text":"Chrome的话，使用WebRTC，本身不支持H.264（国内视频网站多用这个来编码），但是支持VP8（目前主流，Youtube使用VP8（性能和H264差不多）,现在逐步走向VP9（性能和H265差不多），所以H264采用的是外部的解码，因此可能性能上会略差。 另外实际测试的时候，相同掉包率情况下，VP8的画面丢失和花屏的情况要远好过H264（WebRTC下）。转自知乎Lennith的回答 在chrome中输入chrome://flags, Ctrl+F全局搜索hardware， 找到如下内容， 并禁用即可","categories":[{"name":"Problem","slug":"Problem","permalink":"https://didongdongdi.github.io/categories/Problem/"}],"tags":[],"author":"DiDong"},{"title":"Deepin扩展显示屏失败","slug":"Deepin扩展显示屏失败","date":"2019-03-21T03:21:00.000Z","updated":"2019-05-26T05:15:09.000Z","comments":true,"path":"2019/03/21/Deepin扩展显示屏失败/","link":"","permalink":"https://didongdongdi.github.io/2019/03/21/Deepin%E6%89%A9%E5%B1%95%E6%98%BE%E7%A4%BA%E5%B1%8F%E5%A4%B1%E8%B4%A5/","excerpt":"问题描述：在Deepin下，扩展的显示屏不显示，但是发光，在win10下不存在问题","text":"问题描述：在Deepin下，扩展的显示屏不显示，但是发光，在win10下不存在问题 解决方法：Deepin在屏幕亮度为0时，屏幕全黑，所以到设置里把扩展的显示屏的亮度调高就行了","categories":[{"name":"Problem","slug":"Problem","permalink":"https://didongdongdi.github.io/categories/Problem/"}],"tags":[{"name":"Deepin","slug":"Deepin","permalink":"https://didongdongdi.github.io/tags/Deepin/"}],"author":"DiDong"},{"title":"FTP命令问题解决","slug":"FTP命令问题解决","date":"2019-03-15T11:36:00.000Z","updated":"2019-05-26T05:15:09.000Z","comments":true,"path":"2019/03/15/FTP命令问题解决/","link":"","permalink":"https://didongdongdi.github.io/2019/03/15/FTP%E5%91%BD%E4%BB%A4%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/","excerpt":"发现系统中没有ftp命令，安装ftp ftp连接到树莓派失败，显示ftp:connect:Connection refused，尝试127.0.0.1一样 猜测可能是21端口未开放，执行netstat -tln查看端口号情况，发现确实如此 尝试vsftpd，没有该命令，安装vsftpd 执行vsftpd，显示500 OOPS: could not bind listening IPv6 socket，问题不大，因为不需要用到ipv6","text":"发现系统中没有ftp命令，安装ftp ftp连接到树莓派失败，显示ftp:connect:Connection refused，尝试127.0.0.1一样 猜测可能是21端口未开放，执行netstat -tln查看端口号情况，发现确实如此 尝试vsftpd，没有该命令，安装vsftpd 执行vsftpd，显示500 OOPS: could not bind listening IPv6 socket，问题不大，因为不需要用到ipv6 这时再查看端口情况，会发现21号端口已经在监听 尝试连接本地，ftp 127.0.0.1成功 尝试连接树莓派，失败，按前面的方法打开树莓派的21号端口 在树莓派安装vsftpd，执行vsftpd，显示500 OOPS: config file not owned by correct user, or not a file，问题不大 成功连接 成功get文件，但put文件失败 在修改/etc/vsftpd.conf，将write_enable=YES前面的#取消。 重启vsftp服务器sudo service vsftpd restart，启动ftp服务sudo service vsfptd start 注意vsftpd.conf文件中listen=YES和listen_ipv6=YES只能选一个, 前者开启tcp的21端口监听, 后者开启tcp6的21端口监听 两个都注释, 默认开启tcp6的21端口监听 注意: 对于阿里云的服务器, 需要添加安全组规则, 即添加21端口开放, 其中0.0.0.0/0表示任何ipv4地址都可以访问 ftp用户名和密码的确认, 参考https://blog.csdn.net/JoeBlackzqq/article/details/6954334 关于ftp的主动模式和被动模式, 参考https://www.cnblogs.com/xiaohh/p/4789813.html 注意: 作为匿名用户时, 需要开启创建文件夹和上传文件的权限 不建议作为匿名用户访问, 将会出现很多权限问题, 直接访问根目录 本地用户无法登录, 密码错误: 将vsftpd.conf中的pam_service_name=vsftpd改为pam_service_name=ftp, 参考自https://www.cnblogs.com/yjunzhang/p/3541094.html 被动模式连接超时, 参考http://bbs.qcloud.com/thread-1343-1-1.html 关于selinux, 参考https://zh.wikipedia.org/wiki/%E5%AE%89%E5%85%A8%E5%A2%9E%E5%BC%BA%E5%BC%8FLinux 关于umask, 参考https://baike.baidu.com/item/umask 修改linux用户密码, 参考https://blog.csdn.net/u011630575/article/details/49821281 关于linux用户(组)管理与权限设定, 参考https://blog.csdn.net/zyqblog/article/details/79226826#12-%E7%BB%84%E5%92%8C%E7%94%A8%E6%88%B7%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%88%A0%E9%99%A4-groupuser 关于无法put文件, 需要首先lcd到本地目录, 再直接上传该目录下的文件, 不能使用绝对路径或者相对路径, 参考https://blog.csdn.net/anzhen0429/article/details/75151173","categories":[{"name":"Linux","slug":"Linux","permalink":"https://didongdongdi.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://didongdongdi.github.io/tags/Linux/"},{"name":"Command","slug":"Command","permalink":"https://didongdongdi.github.io/tags/Command/"}],"author":"DiDong"},{"title":"Linux内核源码分析","slug":"Linux源码","date":"2019-03-10T13:17:00.000Z","updated":"2019-05-26T05:15:09.000Z","comments":true,"path":"2019/03/10/Linux源码/","link":"","permalink":"https://didongdongdi.github.io/2019/03/10/Linux%E6%BA%90%E7%A0%81/","excerpt":"如何获取linux内核源码？一般来讲，在安装的linux系统下，/usr/src/linux目录下的东西就是内核源代码。还可以从互联网上下载,解压缩后文件一般也都位于linux目录下。 Linux内核源码查看网址推荐：https://elixir.bootlin.com/linux/latest/source","text":"如何获取linux内核源码？一般来讲，在安装的linux系统下，/usr/src/linux目录下的东西就是内核源代码。还可以从互联网上下载,解压缩后文件一般也都位于linux目录下。 Linux内核源码查看网址推荐：https://elixir.bootlin.com/linux/latest/source Linux内核源码的组成（假设相对于linux目录）： arch：包含了此核心源代码所支持的硬件体系结构相关的核心代码，如对于X86平台就是i386 include： 包含了核心的大多数include文件，另外对于每种支持的体系结构分别有一个子目录 init：包含了核心启动代码 mm：包含了所有的内存管理代码 net：核心的网络部分代码，里面的每个子目录对应于网络的一个方面 lib：包含了核心的库代码 scripts：用于配置核心的脚本文件 Documentation：一些文档，起参考作用 block：块I/O层 crypto：加密API drivers：设备驱动 firmware：使用某个驱动需要的设备固件 fs：VFS和独立文件系统 ipc：进程间通信 samples：示例代码 security：Linux安全模块 sound：声音子系统 usr：早期的用户空间代码（叫做initramfs） tools：辅助Linux开发的工具 virt：虚拟化基础设施 COPYING：内核许可描述文件 CREDITS：参与Linux内核的开发人员名单 MAINTAINERS：维护各个子系统和驱动的个人 Makefile：内核Makefile的基础 Kbuild：kernel build的意思，即内核编译的意思，linux内核特有的内核编译体系需要用到的文件 modules：存放了已建好的、可动态加载的模块文件目录，是个空目录，用于存放编译时产生的模块目标文件 README：核心及其编译配置方法简单介绍 Kconfig：配置内核时脚本，里面包含了可选项和菜单功能 阅读内核源码方式推荐：开始最好按顺序阅读启动代码，然后进行专题阅读，如进程部分、内存管理部分等使用Source Insight阅读源代码","categories":[{"name":"Linux","slug":"Linux","permalink":"https://didongdongdi.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://didongdongdi.github.io/tags/Linux/"}],"author":"DiDong"},{"title":"Linux命令集合","slug":"Linux命令集合","date":"2019-03-08T09:49:00.000Z","updated":"2019-05-26T05:15:09.000Z","comments":true,"path":"2019/03/08/Linux命令集合/","link":"","permalink":"https://didongdongdi.github.io/2019/03/08/Linux%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/","excerpt":"以下为一些日常积累的Linux的命令：","text":"以下为一些日常积累的Linux的命令： 命令 说明 alias 显示所有命令的别名，可在/etc/bash.bashrc中永久设置别名，source /etc/bash.bashrc 生效 ps 得到进程列表，-el 获得所有当前活动进程的完整信息 traceroute 知道信息从你的计算机到互联网另一端的主机走的什么路径，在Windows中为tracert telnet 用来远程登录，采用明文传送报文 ftp 文件传输协议命令 netstat 查看系统端口号情况，还有lsof命令也可以 nslookup 查询DNS的记录，查看域名解析是否正常，在网络故障的时候用来诊断网络问题 logout 或 Ctrl+D 断开ssh连接 xrandr 查看屏幕连接状况 grep 文本搜索（通过正则表达式） pwd 输出当前所在目录 find 查找文件 more 类似于cat的，查看文件内容，可以分页 命令 &gt; 输出文件 将命令的结果输出的对应文件，重定向，&gt;&gt; 用于在后面追加 echo 用于在shell中打印shell变量的值，或者直接输出指定的字符串 free 查看内存使用情况 touch 两个功能：一是用于把已存在文件的时间标签更新为系统当前的时间（默认方式），它们的数据将原封不动地保留下来；二是用来创建新的空文件 top 查看进程","categories":[{"name":"Linux","slug":"Linux","permalink":"https://didongdongdi.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://didongdongdi.github.io/tags/Linux/"},{"name":"命令行","slug":"命令行","permalink":"https://didongdongdi.github.io/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"}],"author":"DiDong"},{"title":"Python中的一些坑","slug":"Python中的一些坑","date":"2019-02-16T08:20:00.000Z","updated":"2019-05-26T05:30:28.046Z","comments":true,"path":"2019/02/16/Python中的一些坑/","link":"","permalink":"https://didongdongdi.github.io/2019/02/16/Python%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/","excerpt":"Python中没有自增或自减运算符，即没有++或--","text":"Python中没有自增或自减运算符，即没有++或-- python对文件内容进行write操作时, 会以写入内容覆盖当前内容, 但是后面未覆盖的不会清除, 所以需要使用truncate方法先清空后面的内容","categories":[{"name":"Python","slug":"Python","permalink":"https://didongdongdi.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://didongdongdi.github.io/tags/Python/"}],"author":"DiDong"},{"title":"the Summary of Intercultural Communication (extra notes)","slug":"Intercultural-Communication-extra-notes","date":"2018-12-31T05:56:00.000Z","updated":"2019-05-26T05:15:09.000Z","comments":true,"path":"2018/12/31/Intercultural-Communication-extra-notes/","link":"","permalink":"https://didongdongdi.github.io/2018/12/31/Intercultural-Communication-extra-notes/","excerpt":"Notes interlink","text":"Notes interlink Q: What is genocide?A: Subtle nonverbal behavior: a dirty look Obscene hand gestures Arms-length prejudice Verbal insults Exclusion from job or other opportunites Physical violence Systematic elimination of the group Q: Functions of Nonverbal Communication:A: We use nonverbal communication to duplicate verbal communication. replace complement accent regulate contradict 能联系ICC，就联系ICC Use key words to remember. Use sentences to answer. Q: What is culture shock?A: anxiety resulting from the disorientation encountered upon entering a new culture. estrangement hostility frustration fear anger even physical illness Knowledge Declarative knowledge (‘know that‘)a. Knowledge about other countries and the identities of interlocutor.b. Knowledge about one’s own culture. Procedural knowledge (‘know how‘)a. How to act in specific circumstances.b. How to respond to specific features of interaction with a particular individual Skills Interpreting: the ability to explain a document from one country for someone from another. Relating: the ability to identify or establish relationships between documents from different countries. Discovery: the ability to recognize significant phenomena in a foriegn environment to dicit their meanings and connotations and their relationship to other phenomena. Interaction: the ability to manage these constraints in particular circumstances with specific interlocutors. Critical cultural awareness An ability to evaluate critically and on the basis of explicit criteria perspective, practices and products in one’s own and other countries and cultures. To identify evaluate and mediate in intercultural communication.","categories":[{"name":"English","slug":"English","permalink":"https://didongdongdi.github.io/categories/English/"}],"tags":[{"name":"Competence","slug":"Competence","permalink":"https://didongdongdi.github.io/tags/Competence/"}],"author":"DiDong"},{"title":"the Summary of Intercultural Communication (11)","slug":"Intercultural-Communication-11","date":"2018-12-30T16:44:00.000Z","updated":"2019-05-26T05:15:09.000Z","comments":true,"path":"2018/12/31/Intercultural-Communication-11/","link":"","permalink":"https://didongdongdi.github.io/2018/12/31/Intercultural-Communication-11/","excerpt":"Principles and strategies of intercultural communicationCooperative principle","text":"Principles and strategies of intercultural communicationCooperative principle Q: What is cooperative principle?A: How effective communication in conversation is achieved in common social situations, that is, how listeners and speakers must act cooperatively and mutually accept one another to be understood in a particular way. Make your contribution such as is required, at the stage at which it occurs, by the accepted purpose or direction of the talk exchange in which you are engaged. Speakers (generally) observe the cooperative principle. Listeners (generally) assume that speakers are observing it. Q: What are the conversational maxims?A: Maxim of quantity (quantity of information)Give the most helpful amount of information. Maxim of quality (quality of information)Do not say what you believe to be false. Maxim of relationBe relevant. Maxim of mannerPut what you say in the clearest, briefest, and most orderly manner. &amp;&amp;&amp;&amp;&amp; Different criterion and violations for different maxims: Criterion Violations Informativeness Redundancy, repetition, excessive brevity Truth Exaggeration, fantastic, description Relevance Digression Clarity Vagueness, obliqueness, metaphor Breaking the maxims violate flout Next Lecture","categories":[{"name":"English","slug":"English","permalink":"https://didongdongdi.github.io/categories/English/"}],"tags":[{"name":"Competence","slug":"Competence","permalink":"https://didongdongdi.github.io/tags/Competence/"}],"author":"DiDong"},{"title":"the Summary of Intercultural Communication (10)","slug":"Intercultural-Communication-10","date":"2018-12-30T09:52:00.000Z","updated":"2019-05-26T05:15:09.000Z","comments":true,"path":"2018/12/30/Intercultural-Communication-10/","link":"","permalink":"https://didongdongdi.github.io/2018/12/30/Intercultural-Communication-10/","excerpt":"Barriers to Intercultural CommunicationEthnocentrism Q: What is Ethnocentrism?A: The act of judging another culture based on preconceptions that are found in values and standards of one’s own culture.","text":"Barriers to Intercultural CommunicationEthnocentrism Q: What is Ethnocentrism?A: The act of judging another culture based on preconceptions that are found in values and standards of one’s own culture. Ethnocentrism often leads to pride, vanity, belief in one’s own group’s superiority, and contempt for outsiders. Stereotyping Q: What is stereotyping?A: It is a form of generalization, a way of categorizing and processing infomation we receive about others in our daily life. Nazi Germany Imperialism Terrorism and Hate Crimes In social psychology, a stereotype is an over-generalized belief about a particular category of people. Stereotypes create a barrier that leads to prejudice, leading one to an assumption based on a stereotype. Common Stereotypes Racial Profiling Gender Profiling Culture Group of Individuals A negative attitude toward a cultural group based on little or no experience. The behavior that result from stereotyping or prejudice: Overt action to exclude Avoid or distance oneself from certain groups based on stereotypes. Prejudice Irrational, preconceived opinion that leads to preferential treatment to some people and unfavorable bias or hostility against others, due to ignorance (or in direct contradiction) of facts. Discrimination In human social affairs, dicrimination is treatment or consideration of, or making a distinction in favor of or against, a person based on the group, class, or category to which the person is perceived to belong. How to Overcome Culture Shock in a Foreign Country Keep an open mind Make an effort to learn the local language Get acquainted with the social conduct of your new environment Do not take cultural familiarity or knowledge at face-value Make sure you get to know people in your new environment Try to achieve a sense of stability in your life Most importantly, maintain a sense of humor Course Notes Avoid using slang and idioms specific denotative meaning Ask for confirmation Accenting and intonation Local communication formalities and styles, watch for any changes in body language. Investigate perception Humor is risky Attitudes Curiosity and openness Readiness to suspend disbelief and judgement with respect to others’ meanings, beliefs and behaviors Empathy Relativizing self and valuing others Next Lecture","categories":[{"name":"English","slug":"English","permalink":"https://didongdongdi.github.io/categories/English/"}],"tags":[{"name":"Competence","slug":"Competence","permalink":"https://didongdongdi.github.io/tags/Competence/"}],"author":"DiDong"},{"title":"the Summary of Intercultural Communication (9)","slug":"Intercultural-Communicaiton-9","date":"2018-11-21T12:27:00.000Z","updated":"2019-05-26T05:15:09.000Z","comments":true,"path":"2018/11/21/Intercultural-Communicaiton-9/","link":"","permalink":"https://didongdongdi.github.io/2018/11/21/Intercultural-Communicaiton-9/","excerpt":"Culture ShockWhat Is the Meaning of Acculturation &amp;&amp;&amp;&amp;&amp;Acculturation is the process of modificating one’s attitudes, knowledge and behavior. &amp;&amp;&amp;&amp;&amp;Q: What is Acculturation ?A: It is a process through which a person or group from one culture comes to adopt practices and values of another culture, while still retaining their own distinct culture.","text":"Culture ShockWhat Is the Meaning of Acculturation &amp;&amp;&amp;&amp;&amp;Acculturation is the process of modificating one’s attitudes, knowledge and behavior. &amp;&amp;&amp;&amp;&amp;Q: What is Acculturation ?A: It is a process through which a person or group from one culture comes to adopt practices and values of another culture, while still retaining their own distinct culture. Acculturation is a two-way process. Q: What outcomes dose the acculturation process can have ?A: Assimilation, rejection, integration, marginalization, and transmutation. Intercultural Adaptation-Learning Opportunity to Everyone Adaptation and Learning Intercultural adaptation is everywhere Q: What is the important factor predicting adaptation to a new culture ?A: The amount of participation in a new culture milieu. Q: What is the heart of intercultural adaptation process ?A: Communication. Learn together - Learn from each other Q: How a process does intercultural learning is ?A: A dynamic, developmental, and on-going process. Q: What does the culture shock model show about intercultural adaptation ?A: A process starting with very positive feelings in the beginning, followed by a drop in satisfaction and ending with recovery. In sharp contrast to culture shock models are the models that emphasise the learning and growth-facilitating nature of the adaptation process.For example, the dialectical model explains intercultural adaptation as a cyclical and recursive process. the mutual learning model are based on cooperation and respect. By this model, people follow the principles of curiosity, commitment and transparency. The mutual learning process has consequences for both behavior and learning. People start to behave without fear, interpersonal relationships become more facilitative, and people feel free to explore and search for new information and new alternatives. Q: When does intercultural learning takes place most effectively ?A: When people act in the real world. Experiences != Learning Levels of cross-cultural awareness (4) Q: What is the leading factor in intercultural adaptation and understanding emphasized by this model ?A: Intercultural contact. Q: What are the four levels ?A: First: A person is aware of superficial and very obvious cultural traits. Second: People become aware of significant and subtle cultural traits. Third: People are aware of significant and subtle cultural traits. Fourth: People become aware of how another culture feels from the standpoint of an insider. The 4 Stages of Culture ShockThe Honeymoon Stage During which travelers become infatuated with the language, people and food in their new surroundings. The Frustration Stage It is familiar to anyone who has lived abroad or who travels frequently. Q: What are the features during the frustration stage ?A: Bouts of depression or homesick and feelings of longing to go home. The Adjustment StageThe Acceptance Stage Acceptance doesn&#39;t mean that new cultures or environments are completely understood, rather it signifies realization that complete understanding isn&#39;t necessary to function and thrive in the new surroundings. Course Notes &amp;&amp;&amp;&amp;&amp;Q: What is culture conflict ?A: It is a type of conflict that occurs when different culture values and beliefs clash. &amp;&amp;&amp;&amp;&amp;Q: What are the features of culture ?A: multi-layered constantly in flux clastic largely below the surface &amp;&amp;&amp;&amp;&amp;Q: The definition of acculturation.A: It refers to the social and psychological integration of the learner with the target language group. &amp;&amp;&amp;&amp;&amp; Culture Shock Stages Stages Descriptions Honeymoon overwhelmingly positive, greatest, exciting Depression/frustration/hostility fatigue, frustration Adjustment more familiar and recognizable Acceptance travelers have the familiarity and are able to draw together the resources they need to feel at ease Next Lecture","categories":[{"name":"English","slug":"English","permalink":"https://didongdongdi.github.io/categories/English/"}],"tags":[{"name":"Competence","slug":"Competence","permalink":"https://didongdongdi.github.io/tags/Competence/"}],"author":"DiDong"},{"title":"FPGA 之 锁存器 (Latch)","slug":"FPGA-之-锁存器-Latch","date":"2018-11-07T16:14:00.000Z","updated":"2019-05-26T05:15:09.000Z","comments":true,"path":"2018/11/08/FPGA-之-锁存器-Latch/","link":"","permalink":"https://didongdongdi.github.io/2018/11/08/FPGA-%E4%B9%8B-%E9%94%81%E5%AD%98%E5%99%A8-Latch/","excerpt":"参考自http://www.eefocus.com/liuyuxue/blog/13-11/300280_d7008.html","text":"参考自http://www.eefocus.com/liuyuxue/blog/13-11/300280_d7008.html 信号赋初值以避免综合时出现锁存器。 注意警告。","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://didongdongdi.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"https://didongdongdi.github.io/tags/FPGA/"}],"author":"DiDong"},{"title":"FPGA-VHDL 门电路设计","slug":"PGA-VHDL-门电路设计","date":"2018-10-31T13:58:00.000Z","updated":"2019-05-26T05:15:09.000Z","comments":true,"path":"2018/10/31/PGA-VHDL-门电路设计/","link":"","permalink":"https://didongdongdi.github.io/2018/10/31/PGA-VHDL-%E9%97%A8%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/","excerpt":"分析功能 输入 和 输出 画出真值表 写出逻辑表达式 最小项的或","text":"分析功能 输入 和 输出 画出真值表 写出逻辑表达式 最小项的或 将逻辑表达式化为最简形式 越简单越好 从最简形式，反推（二输入）与非门的组成 从（二输入）与非门开始，逐层封装，直到实现最简形式 使用与非门的原因是：单纯用与非门可以实现任意逻辑表达式与非门的经济性，在集成电路中，与非门和或非门是仅次于非门的第二简单的门与非门比或非门性能好参考自 数字电路基础课程教学中，为什么总是要把逻辑式化简为与非-与非式，并在实际电路中用与非门实现？ - well xiong的回答 - 知乎","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://didongdongdi.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"https://didongdongdi.github.io/tags/FPGA/"},{"name":"VHDL","slug":"VHDL","permalink":"https://didongdongdi.github.io/tags/VHDL/"}],"author":"DiDong"},{"title":"the Summary of Intercultural Communication (7&8)","slug":"Intercultural-Communication-7-8","date":"2018-10-31T08:17:00.000Z","updated":"2019-05-26T05:15:09.000Z","comments":true,"path":"2018/10/31/Intercultural-Communication-7-8/","link":"","permalink":"https://didongdongdi.github.io/2018/10/31/Intercultural-Communication-7-8/","excerpt":"Nonverbal communicationComparison","text":"Nonverbal communicationComparison BASIS FOR COMPARISON VERBAL NON-VERBAL Meaning the sender uses words to transmit the message to the receiver take place between sender and receiver with the use of signs Types formal,informal Chronemics, Vocalics, Haptics, Kinesics, Proxemics, Artifacts, Oculesics, Paralanguage Time Consuming no yes Chances of transmission of wrong message rarely most of the time Documentary Evidence yes, in case of written commmunication no Advantage clearly understood and immediate feedback emotions, status, lifestyle, feelings of the sender Presence doesn’t matter must NVC (Nonverbal communication) &amp;&amp;&amp;&amp;&amp;Q: What is NVC?A: It is communication through sending and receiving wordless clues. &amp;&amp;&amp;&amp;&amp;Q: The features of NVC.A: Using signs Often transmitting wrong message Face to face Many different types &amp;&amp;&amp;&amp;&amp;Q: What does NVC includes? (PK PC OH)A: body language (kinesics) distance (proxemics) physical environments of voice (paralanguage) physical environments of touch (haptics) the use of time (chronemics) eye contact and the actions of looking while talking and listening, frequency of galances, patterns of fixation, pupil dilation, and blink rate (oculesics) Q: Nonverbal elements of paralanguage. (6)A: Voice quality, rate, pitch, volume, and speaking style, as well as prosodic features such as rhythm, intonation, stress. Q: Nonverbal elements of written texts. (3)A: Handwirting style, spatial arrangement of words, the physical layout of a page . Q: The three principal areas of interaction beween individuals in NVC.A: Environmental conditions where communication takes place Physical characteristics of the communicators Behaviors of communicators during interaction Q: What is Encoding?A: The act of generating information such as facial expressions, gestures, and postures. Q: What is Decoding?A: The interpretation of information from received sensations given by the encoder. Importance Q: Body signals comprise:A: Physical features Consious and unconsious The mediation of personal space First impression Positive and negative impressions Posture Q: Please give some examples of body positioning to portray certain postures. (6)A: Slouching, towering, legs spread, jaw thrust, shoulders forward, and arm crossing. Q: Why posture can be situation-relative？A: People will change their posture depending on the situation they are in. Q: What can posture be used to do? (3)A: Determine a participant’s degeree of attention or involvement, the difference in status between communicators, and the level of fondness a person has for the other communicator, depending on body “openness”. Q: What postures can lead to positive sentiment? (2)A: Mirror-image congruent postures, displaying a forwad lean or decreacing a backward lean. Clothing Q: The types of clothing that an individual wears convey nonverbal cues about his or her: (4)A: Personality, background and financial status, and how others will respond to them. Q: An individual’s clothing style can demonstrate their: (7)A: Culture, mood, level of confidence, interests, age, authority, and values/beliefs. Gestures Q: How gestures can be made? (6)A: Hands, arms or body; movements of the head, face and eyes. Q: Please give some categories of gestures.A: emblems or quotable gestures speech independent or speech related gestures Q; How many expressions human faces are capable of?A: 10,000(This versatility makes non-verbals of the face extremely efficient and honest, unless deliberately manipulated.) Q: Displays of emotions can generally be categorized into two groups: negative and positive. Discribe them.A: Negative emotions usually manifest as increased tension in various muscles groups: (1)tightening of jaw muscles, (2)furrowing of forehead, (3)squinting eyes, or (4)lip occlusion. Positive emotions are revealed by (1)the loosening of the furrowed lines on the forehead, (2)relaxtion of the muscles around the mouth, and (3)widening of the eye area. When individuals are truly relaxed and at ease, the (4)head will also tilt to the side, exposing our most vulnerable area, the neck. Gestures can be subdivided into three groups: AdaptersSome hands movements (are not considered to be gestures) consist of manipulations either of the person or some object(e.g. clothing, pencils, eyeglasses)–the kinds of scratching, fidgeting, rubbing, tapping, and touching that people often do with their hands. The basis dispositional inferences of the speaker’s emotion(nervous, uncomfortable, bored). SymbolicOther hands movements (are considered to be gestures) with specific, conventionalized meanings. Symbolic gestures are used intentionally and serve a clear communicative function. Symbolic gestures are usually used in the absence of speech, but can also accompany speech. Different meanings in defferent culture. ConversationalThe middle ground between adapters and symbolic gestures. Do not refer to actions or words, but do accompany speech and are related to the speech they accompany. Not seen in the absence of speech and are only made by the person who is speaking. Distance Q: What are 4 primary distance zones?A: intimate (touching to 18 inches) distance || familiar, closeness and trust personal (18 inches to 4 feet) distance || still close, the most comfortable social (4 to 12 feet) distance || business and classroom public (more than 12 feet) distance || two-way communication is not desirable or possible Eye contact Q: Eye contact is the primary nonverbal way of indicating: (4)A: Engagement, interest, attention and involvement. Q: What will happen if an individual is interested?A: The pupils will dilate. Q: How do people use their eyes to indicate interest?A: Frequently recognized actions of winking and movements of the eyebrows. Q: Disinterest is highly recognized when:A: Little or no eye contact is made in a social setting. Q: How will Eye contact influence people?A: The longer there is established eye contact between two people, the greater the intimacy levels. Q: What are the important cues in NVC about eye contact?A: The length of a gaze The frequency of glances Patterns of fixation Pupil dilation Blink rate Q: How do we know someone is being deceptive?A: Their eyes tend to blink a lot more. Q: What can be predictive of deception?A: Eye aversion. Across cultures Q: Nuances across different aspects of nonverbal communication can be found in cultures all around the world. What can these differences be besed in?A: Be based in preferences for mode of communication Be based on how cultures perceive the passage of time Q: Chronemics can be categorized in two ways:A: Polychronic (when people do many activities at once and is common in Italy and Spain) Monochronic (when people do one thingat a time which is common in America) Gestures Gestures Countries Meanings sticking your tungue out Western countries mockery …………………… Polynesia a greeting and a sign of reverence clapping North America applauding …….. Spain summon a waiter at a restaurant Meanings Countries Gestures yes Northern Europe nodding heads up and down … Greece the downward nod no Northern Europe shaking head from side to side .. Greece the upward nod goodbye America face the palm outward and move the hand side to side ……. Italy face the palm inward and move fingers facing the other person ……. France and Germany face the hand horizontal and move the fingers toward the person leaving Q: It is important to note that:A: Gestures are used in more informal settingand more often by children. Displays of emotion Emotions Countries Meanings laughter Westernized Countries amusement …….. Africa wonder or embarrassment Arab and Iranian culturesshow emotion openly Asian culturesunacceptable to show emotion openly Native Americans tend to be more reserved and less expressive with emotions.Frequent touches are common for Chinese people; however, such actions like touching, patting, hugging or kissing in America are less frequent and not often publicly displayed. Nonverbal actionsLots of Examples!!! Kinesics: movement and body position Q: What are the aspects of kinesics? (5)A: Face, eye contact, gesture, posture, body movements. Q: Kinesic messages comprise: (3)A: Posture, gaze, and facial movements. Haptics: touching in communication Q: What is meainng comveyed from touch highly dependent upon? (4)A: The culture, the context of the situation, the relationship between communicators, and the manner of touch. In Thai culture, for example, touching someone’s head may be thought rude. Americans, the English, Germans and Northern Europeans are said to belong to low-touch cultures, exhibiting very limited tactile contact in public. Hispanics, people of Eastern European descents, Italians, the French, Arabs, and Jews are all said to belong to high-touch cultures. Proxemics4 types of proxemics with different distances depending on the situation and people involved: Types Description Intimate distance close encounters like embracing, touching, or whispering Personal distance close friends and family members Social distance acquaintances; workplace or school Public distance strangers or public speaking Distance Description 0-50 cm intimate lovers and family members 50-120 cm friends (personal distance) 120-270 cm acquaintances (social distance) 270-… cm public space, not belong to oneself Behind strangers speaking from behind are allowed to stand much more nearer Interaction Q: When communicating, nonverbal messages can interact with verbal messaes in 6 ways:A: Repeating, conflicting, complementing, substituting, regulating and accenting/moderating. ConflictingConflicting verbal and nonverbal messages within the same interaction can sometimes send opposing or conflicting message. ComplementingAccurate intepretation of messages is made easier when nonverbal and verbal communication complement each other. SubstitutingNonverbal behavior is sometimes used as the sole channel for communication of a message. ChronemicsMonochronic time Things are done one at a time and time is segmented into precise, small units. Time is a precious resource not to be wasted or taken lightly. “Time is tangible“ and viewed as a commodity. Polychronic time Several things can be done at once, and wider view of time is exhibited and time is perceived in large fluid sections. Much less focused on the preciseness of accounting for each and every moment, but more focused on tradition and relationships. More focus on relationships, rather than watching the clock. Setting the stage for effective nonverbal communication Q: How to inmprove your nonverbal communication effectively?A: Learn to manage stress. Emotional awareness. Good at reading body language. Q: Are emotions contagious?A: Yes. Q: Emotional awareness enables you to:A: Accrately read other people. Create trust in relationships. Show others that you understand and care. Know if the relationship is meeting your emotional needs, giving you the option to either repair the relationship or move on. Q: Tips for reading body language:A: Pay attention to inconsistencies Look at nonverbal communication signals as a group Trust your instincts Course Notes&amp;&amp;&amp;&amp;&amp; The differences between Polychronic and Monochronic: Monochronic Polychronic Do one thing at a time Do many things at once Concentrate on the job Are easily distracted and subject to interruptions Take time commitments (deadlines, schedules) seriously Consider time commitments an objective to be achieved, if possible Are committed to the job Are committed to people and human relationships Adhere to plans Change plans often and easily Are concerned about not disturbing others; follow rules of privacy Are more concerned with people close to them (family, friends, close business associates) than with privacy Show great respect for private property; seldom borrow or lend Borrow and lend things often and easily Emphasize promptness Base promptness on the relationship Are accustomed to short-term relationships Have strong tendency to build lifetime relationship Next Lecture","categories":[{"name":"English","slug":"English","permalink":"https://didongdongdi.github.io/categories/English/"}],"tags":[{"name":"Competence","slug":"Competence","permalink":"https://didongdongdi.github.io/tags/Competence/"}],"author":"DiDong"},{"title":"KMP模式匹配算法 的 个人解读","slug":"KMP模式匹配算法的个人解读","date":"2018-10-24T15:43:00.000Z","updated":"2019-05-26T05:15:09.000Z","comments":true,"path":"2018/10/24/KMP模式匹配算法的个人解读/","link":"","permalink":"https://didongdongdi.github.io/2018/10/24/KMP%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E7%9A%84%E4%B8%AA%E4%BA%BA%E8%A7%A3%E8%AF%BB/","excerpt":"（以下，将目标字符串称为 T ，将模式字符串称为 P ，|A|为字符串A的长度） 字符串匹配问题字符串的模式匹配算法大致有以下几种： 朴素的模式匹配算法（又叫 Brute Force 算法，以下简称 BF） KMP模式匹配算法（以下简称KMP） Horspool算法 Boyer-Moore算法 Sunday算法 RK算法 字符串匹配自动机 后缀树算法（分在线和非在线两种） 对于多模式字符串匹配有：AC算法（字符串匹配自动机思想）、WM算法（BM算法在多模式的推广应用） 在这里主要说明KMP和BP，对于其他算法以后再做了解。 BF简单粗暴地对于 T 上的每一个（除了最后的|P|-1个）字符，都对 P 扫描一遍这种算法简单，但时间复杂度过高，最差的情况需要O(|T||P|)的代价","text":"（以下，将目标字符串称为 T ，将模式字符串称为 P ，|A|为字符串A的长度） 字符串匹配问题字符串的模式匹配算法大致有以下几种： 朴素的模式匹配算法（又叫 Brute Force 算法，以下简称 BF） KMP模式匹配算法（以下简称KMP） Horspool算法 Boyer-Moore算法 Sunday算法 RK算法 字符串匹配自动机 后缀树算法（分在线和非在线两种） 对于多模式字符串匹配有：AC算法（字符串匹配自动机思想）、WM算法（BM算法在多模式的推广应用） 在这里主要说明KMP和BP，对于其他算法以后再做了解。 BF简单粗暴地对于 T 上的每一个（除了最后的|P|-1个）字符，都对 P 扫描一遍这种算法简单，但时间复杂度过高，最差的情况需要O(|T||P|)的代价 KMP这种算法相对复杂，但时间复杂度低，其时间代价为O(|P|+|T|)，且当T长度远小于P长度时，基本上为O(|T|) 下面说明KMP算法。 KMP的大致思想 KMP算法由Knuth、Morris、Pratt等人创造，其本质在于将BP中没有必要的比较去掉，且P的右移与T无关，仅依赖于P本身的特征。 由图可知，当遇到匹配失败的情况时，BP直接将P右移一位，重新扫描P，但这样效率极为低下。若直接将P移至P(i+1)的位置，则极有可能会错过P’的情况；即，在T上，有字符串(i-j)~(i-k-1)和字符串(i-j+k)~(i-1)相等，那么此时极有可能找到从T(i-j+k)位置开始的P’。所以，KMP的主要目的就是找到可能存在的P’。同时，应保证k为最小，即相等的字符串应尽可能地长。而后不断进行迭代。 由图可知，字符串T(i-j)~(i-1)与字符串P(0)~(j-1)必定相等（因为前面已经扫描过了）。所以，我们只需要知道和橙色字符串P(0)~(j-k-1)相等的红色字符串P(k)~(j-1)是否存在，且其位置如何。 P的特征向量 P的特征向量为一个大小为|P|的int型数组，其元素为特征值，且对应P上的字符。由特征二字可知，特征向量是反映P的字符串特征的一种表示，其与线性代数中的特征向量没有关系，特征值同样。下面将通过举几个例子来说明特征值和特征向量的意义。 对于下面的字符串，其特征向量为： a b a 0 0 1 a b a b 0 0 1 2 a b a b a b b b b a b a b a b a b a b 0 0 1 2 3 4 0 0 0 1 2 3 4 5 6 5 6 5 6 由上面的字符串及特征向量可知： P[0]的特征值必定为0 往后的字符P[j]的特征值i： 1.若i == 0，说明该字符与P[0]不同2.若i != 0，说明该字符与P[i-1]相同或者说该字符的下一个字符与P[i]相同（这就是为什么大多数KMP求特征向量的那个数组或函数叫做next），同时字符串P(0)~(i-1)和字符串P(j-i+1)~(j)相等，即有相等子串 在清楚了字符串的特征值和特征向量的含义后，我们先把如何求特征向量先放一边，先看在已有P的特征向量的情况下，如何找到T中的子串。 已知特征向量 求子串 先上代码： 12345678910111213141516int KMPStrMatching(const string T, const string P,const int *N,const int startIndex) &#123; int TLen = T.length(), PLen = P.length();//分别获得T和P的长度 int lastIndex = TLen - PLen;//防止开始查找的位置太靠后，T最后的子串长度小于P的长度 if (startIndex &gt; lastIndex) return -1; int i = startIndex, j = 0;//从T[startIndex]位置开始查找，i为T上的位置，j为P上的位置 for (; i &lt; TLen; i++) &#123; while (P[j] != T[i] &amp;&amp; j &gt; 0)//见分析 j = N[j - 1];//记住这个是右移到相应的位置即可 if (P[j] == T[i])//字符相等，i、j都往后移（j的后移由for循环完成） j++; if (j == PLen)//找到子串，返回子串首字符位置 return i - j + 1; &#125; return -1;&#125; while循环的分析： 若j == 0，说明此时j指向P的首字符，只需要比较即可，即 if (P[j] == T[i]) 若j != 0，说明此时j指向的不是P的首字符 若P[j] == T[i]，则只需要继续往后面比较即可 若P[j] != T[i]，则此时进入while循环，寻找是否存在P’（见 KMP的大致思想 部分） 语句 j = N[j - 1]; 的分析： 由于此时 j指向的不是P的首字符 且 P[j] != T[i] ，则此时需要将P右移，即，将j左移。 可知 P[j-1] == T[i-1] ，则先将 j-1 由前面P的特征向量部分可知 若 N[j-1] == 0 ，说明此时必定不存在P’，故直接将j置零，即，将P直接移到首字符 若 N[j-1] != 0 ，说明此时有可能存在P’，则将j置为N[j-1]，即，将P移到可能存在的P’的位置，然后再比较可能不同的那个字符，即比较P[j]和T[i]；注意，再while循环的过程中i是未发生变化的 这个时候你可能会想，如果P[j]和T[i]是相等的还行，那如果要是不相等呢？那么这个时候，你会发现P已经后移了，其实就已经开始了另一轮匹配，这就是迭代。 求特征向量好了，相信这个时候你对KMP的算法实现应该有了一定的了解。 但我们还有另外一个问题没有解决：如何求特征向量。事实上求特征向量的算法和上面求相等子串的算法都是同一种算法——KMP。 这个时候，T和P相等，但我们的startIndex（开始查找的位置）设为固定的1。 这个时候你可能又会问，这样根本找不到相等的子串啊？！没错，但是我们的目的不是为了找相等的子串，而是为了探索P的特征，即在P[1]后（含P[1]）找到和从P[0]开始的子串相等的最长子串，同时将其记录到next（或N）数组中。所以，next数组实际上是对P的数字化描述。同时，在对next数组顺序填充时，空着的位置的特征值只与前面已经填好的位置的特征值有关，这个从求子串时的操作就可以看出。 下面贴代码： 1234567891011121314151617int *Next(const string P) &#123; int m = P.length();//获得P的长度 assert(m &gt; 0);//如果是空字符串则退出 int *N = new int[m];//new一个next数组 assert(N != 0);//new不出来就退出 N[0] = 0;//首字符特征值置零，即，跳过首字符 for (int i = 1; i &lt; m; i++) &#123;//i往后移 int k = N[i - 1];//k往后移 while (k &gt; 0 &amp;&amp; P[i] != P[k])//这两行与上面求子串的两行完全一样，故不再说明 k = N[k - 1]; if (P[i] == P[k])//如果相等，在原来k的基础上+1，表示从N[i]往前有相等的子串 N[i] = k + 1; else//否则，置零，表示没有相等的子串 N[i] = 0; &#125; return N;&#125; 总结综上，你会发现，KMP其实并不难，关键在于while循环的理解。而while循环本质上是不断地迭代，同时 j= N[j - 1]; 这一语句将几步操作融合在了一起。 不得不感叹算法的奇妙啊！","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://didongdongdi.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://didongdongdi.github.io/tags/%E7%AE%97%E6%B3%95/"}],"author":"DiDong"},{"title":"the Summary of Intercultural Communication (6)","slug":"Intercultural-Communication-6","date":"2018-10-18T05:03:00.000Z","updated":"2019-05-26T05:15:09.000Z","comments":true,"path":"2018/10/18/Intercultural-Communication-6/","link":"","permalink":"https://didongdongdi.github.io/2018/10/18/Intercultural-Communication-6/","excerpt":"Linguistic differences via translationCorrespondence between English and Chinese at word Level Correspondence: word-for-word one word with multiple equivalents of the same meaning one word with multiple equivalents of different meanings equivalents interwoven with one another words without equivalents","text":"Linguistic differences via translationCorrespondence between English and Chinese at word Level Correspondence: word-for-word one word with multiple equivalents of the same meaning one word with multiple equivalents of different meanings equivalents interwoven with one another words without equivalents Factors that influence meaning singular and pluraleg.time–timesfinding-findings some idiomatic usageeg.You can’t pay too much attention to your pronunciation. (can’t … too == the more, the better)You can never be too careful in your work. (never be too == try your best) Three notice: commendatory and derogatory meaningseg.Farmer–peasantThe enemy killed one of our comrades and we killed an enemy agent. professional words the flexibility of translation Dicriminating the original meaning of an English word Q: How to dicriminate the original meaning of an English word ?A: part of speech word formation context and collocation Course NotesThe differences between UK and US UK US Chips Fries Aeroplane Airplane Underground Subway Playground Middle East 6 Major differences between English and Chinese English Chinese structure meaning passive voice active voice idioms, short four characters expressions (vivid, live and compact) abstract nouns concrete nouns omitted and avoid recurrences (words) shorter and simpler (sentences) not omitted and be repeated (words) conclusion first reasons first Some expressions If you don’t want it, please don’t give it to others. 己所不欲，勿施于人。 You need to be very smart, very quick at things, but you need to be very careful with your words so that you do not hurt others. 敏于事，慎于言。 To show off before an expert. (To teach a duck to swim.) 班门弄斧 Disintegration 土崩瓦解 Total exhaustion 精疲力尽 Careful consideration 深思熟虑 Perfect harmony 水乳交融 Feed on fancies 画饼充饥 With great eagerness 如饥似渴 Lack of perseverance 三天打鱼，两天晒网 Make a little contribution 添砖加瓦 On the verge of destruction 危在旦夕 to kill two birds with one stone 一石二鸟 a drop in the bucket 九牛一毛 to teach a pig to play on a flute 做不可能的事 once in a blue moon 千载难逢 the worst wheel of a cart creaks most 才学最差，叫喊最响 it is a long lang that has no turning 事情必有转机 it is an ill bird that fouls its own nest 家丑不可外扬 DRY I want my martini dry. 不甜的 There are still some dry states in the United States. 禁酒的 She prefers dry bread. 无奶油的 … … 余光中：当中文遇到英语 当中文遇到英语会怎样？ 译音产生 本土母语接纳和转化很多外来的语言 认识西方的过去和接触到世界的未来 中文和英文有什么不同？ 中文不拘文法，省略不必要的虚字，留下具体的东西。 中文在文法上很少用介词和连接词。 四次成语可以分成哪两组？ 一组表示 一种价值，一种观念，一种主张，比如“天下为公”，“众志成城”。 一组表示 一种情况，并不主张什么，如“张三李四”。 四字成语的基本美学是什么？ 对仗、简洁、铿锵。 四字成语往往表示一种状态。 Next Lecture","categories":[{"name":"English","slug":"English","permalink":"https://didongdongdi.github.io/categories/English/"}],"tags":[{"name":"Competence","slug":"Competence","permalink":"https://didongdongdi.github.io/tags/Competence/"}],"author":"DiDong"},{"title":"迷宫求解  (所有路径)","slug":"迷宫求解所有路径","date":"2018-10-16T05:25:00.000Z","updated":"2019-05-26T05:15:09.000Z","comments":true,"path":"2018/10/16/迷宫求解所有路径/","link":"","permalink":"https://didongdongdi.github.io/2018/10/16/%E8%BF%B7%E5%AE%AB%E6%B1%82%E8%A7%A3%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84/","excerpt":"迷宫问题对于如下所示的迷宫，如何找到所有路径？（ # 为墙，* 为出口，0 为入口）（注意：要找到所有的路径必须保证一条路径不能在同一个位置走两次及两次以上，反之，一方面，这样没有意义；另一方面，这样可能会造成在一个地方一直转圈）","text":"迷宫问题对于如下所示的迷宫，如何找到所有路径？（ # 为墙，* 为出口，0 为入口）（注意：要找到所有的路径必须保证一条路径不能在同一个位置走两次及两次以上，反之，一方面，这样没有意义；另一方面，这样可能会造成在一个地方一直转圈） 大致思路（试错法） 先将迷宫用二维数组表示，0代表围墙，1代表通路，2代表出口，而入口通过坐标指定 定义位置类LocDir，成员X（列坐标）和Y（行坐标）代表在迷宫某个位置的坐标,成员dir代表在这个位置后下一步要走的方向（1代表向上，2代表向右，3代表向下，4代表向左） 先定义一个入口的位置对象；而后创建一个栈（存放位置对象），用于记录走过的路径，并将入口进栈。 从入口开始，根据位置对象中的方向，在向该方向移动前先判断：若为0，说明前方是墙，此时将方向+1，即调整方向；若为1，说明前方是通路，则将现在位置在二维数组中的值置0，表示走过的路已经变成了墙，不能走回头路（避免出现文章开头提出的现象），向前方移动，并将到达的位置X和Y记录下来，dir置1，表示先试着向上走，将该位置对象入栈；若为2，说明找到了出口，这个时候将路径以坐标的形式输出即可。 若4中调整方向后，直到方向变成4，即向左走也不行，则此时应该将方向+1，变为5，但这样就找不到方向了，说明在该位置四周都是墙，此时将栈顶元素退栈，同时将其变为现在的位置，即沿原路径返回了一步；再将现在位置在二维数组中的值置1，即将这个位置变为通路；最后将方向+1。 还可以将每次找到的正确路径的长度记录下来，通过比较，输出最长路径（之一）和最短路径（之一） 总结总的来说，迷宫求解试错法的关键在于，在迷宫的每个位置，我们都有四个方向可以选择，那么，只需要在每个位置将这四个方向依次试过，就可以确保走过迷宫的每一个位置，且单条路径不会重复走过同一个位置。 实现代码注：由于代码中使用的栈是我自定义的，故栈中的一个函数Exchangge(top)（用来替换栈顶元素），在标准栈中可能并没有，但其本质是将原栈顶元素出栈后再将新的元素进栈，即可分成两步写。 main.cpp 1234567891011121314151617181920212223242526272829#include&lt;Windows.h&gt;#include\"MazeSolve.h\"#include\"LocDir.h\"int main() &#123; //0代表围墙，1代表通路，2代表出口 int map[10][10] = &#123; &#123;0,0,0,0,0,0,0,0,0,0&#125;, &#123;0,1,1,0,1,1,1,0,1,0&#125;, &#123;0,1,1,0,1,1,1,0,1,0&#125;, &#123;0,1,1,1,1,0,0,1,1,0&#125;, &#123;0,1,0,0,0,1,1,1,1,0&#125;, &#123;0,1,1,1,0,1,1,1,1,0&#125;, &#123;0,1,0,1,1,1,0,1,1,0&#125;, &#123;0,1,0,0,0,1,0,0,1,0&#125;, &#123;0,0,1,1,1,1,1,1,2,0&#125;, &#123;0,0,0,0,0,0,0,0,0,0&#125; &#125;; //入口初始化 LocDir in; in.X = 1; in.Y = 1; in.dir = 1; MazeSolve(map, in); system(\"pause\"); return 0;&#125; MazeSolve.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#ifndef _MAZESOLVE_H#define _MAZESOLVE_H#include\"LinkStack.h\"#include\"LocDir.h\"#include&lt;iostream&gt;using namespace std;void MazeSolve(int map[][10], const LocDir &amp; in) &#123; int roadNum = 0; int roadLen[200] = &#123; 0 &#125;; LinkStack&lt;LocDir&gt; LocDirStack; LocDirStack.Push(in); LocDir top, temp; LocDirStack.Top(top); while (!(top.X==1&amp;&amp;top.Y==1&amp;&amp;top.dir==5)) &#123; //Move switch (top.dir) &#123; case 1://turn up if (map[top.Y-1][top.X]) &#123; if (map[top.Y - 1][top.X] == 2) &#123; cout &lt;&lt; \"Road\" &lt;&lt; roadNum &lt;&lt; ':'; cout &lt;&lt; '(' &lt;&lt; top.X &lt;&lt; ',' &lt;&lt; top.Y-1 &lt;&lt; ')' &lt;&lt; '\\t'; roadLen[roadNum] = 1 + LocDirStack.GetSize(); roadNum++; LocDirStack.Show(); cout &lt;&lt; endl; top.dir++; LocDirStack.Exchange(top); break; &#125; map[top.Y][top.X] = 0; temp = &#123; top.X,top.Y - 1,1 &#125;; LocDirStack.Push(temp); &#125; else &#123; top.dir++; LocDirStack.Exchange(top); &#125; break; case 2://turn right if (map[top.Y][top.X + 1]) &#123; if (map[top.Y][top.X + 1] == 2) &#123; cout &lt;&lt; \"Road\" &lt;&lt; roadNum &lt;&lt; ':'; cout &lt;&lt; '(' &lt;&lt; top.X+1 &lt;&lt; ',' &lt;&lt; top.Y &lt;&lt; ')' &lt;&lt; '\\t'; roadLen[roadNum] = 1 + LocDirStack.GetSize(); roadNum++; LocDirStack.Show(); cout &lt;&lt; endl; top.dir++; LocDirStack.Exchange(top); break; &#125; map[top.Y][top.X] = 0; temp = &#123; top.X+1,top.Y,1 &#125;; LocDirStack.Push(temp); &#125; else &#123; top.dir++; LocDirStack.Exchange(top); &#125; break; case 3://turn down if (map[top.Y+1][top.X]) &#123; if (map[top.Y + 1][top.X] == 2) &#123; cout &lt;&lt; \"Road\" &lt;&lt; roadNum &lt;&lt; ':'; cout &lt;&lt; '(' &lt;&lt; top.X &lt;&lt; ',' &lt;&lt; top.Y + 1 &lt;&lt; ')' &lt;&lt; '\\t'; roadLen[roadNum] = 1 + LocDirStack.GetSize(); roadNum++; LocDirStack.Show(); cout &lt;&lt; endl; top.dir++; LocDirStack.Exchange(top); break; &#125; map[top.Y][top.X] = 0; temp = &#123; top.X,top.Y + 1,1 &#125;; LocDirStack.Push(temp); &#125; else &#123; top.dir++; LocDirStack.Exchange(top); &#125; break; case 4://turn left if (map[top.Y][top.X - 1]) &#123; if (map[top.Y][top.X - 1] == 2) &#123; cout &lt;&lt; \"Road\" &lt;&lt; roadNum &lt;&lt; ':'; cout &lt;&lt; '(' &lt;&lt; top.X -1&lt;&lt; ',' &lt;&lt; top.Y&lt;&lt; ')' &lt;&lt; '\\t'; roadLen[roadNum] = 1 + LocDirStack.GetSize(); roadNum++; LocDirStack.Show(); cout &lt;&lt; endl; top.dir++; LocDirStack.Exchange(top); break; &#125; map[top.Y][top.X] = 0; temp = &#123; top.X - 1,top.Y,1 &#125;; LocDirStack.Push(temp); &#125; else &#123; top.dir++; LocDirStack.Exchange(top); &#125; break; default://no choice LocDirStack.Pop(temp); LocDirStack.Top(top); top.dir++; LocDirStack.Exchange(top); map[top.Y][top.X] = 1; break; &#125; LocDirStack.Top(top); &#125; roadNum = 0; int minRoad = roadLen[roadNum],maxRoad = roadLen[roadNum]; int minRoadPos =0, maxRoadPos = 0; while (roadLen[roadNum]) &#123; if (minRoad &gt; roadLen[roadNum]) &#123; minRoad = roadLen[roadNum]; minRoadPos = roadNum; &#125; if (maxRoad &lt; roadLen[roadNum]) &#123; maxRoad = roadLen[roadNum]; maxRoadPos = roadNum; &#125; ++roadNum; &#125; cout &lt;&lt; \"Min RoadNum:\" &lt;&lt; minRoadPos &lt;&lt; '\\t' &lt;&lt; \"Min RoadLength:\" &lt;&lt; minRoad &lt;&lt; endl; cout &lt;&lt; \"Max RoadNum:\" &lt;&lt; maxRoadPos &lt;&lt; '\\t' &lt;&lt; \"Max RoadLength:\" &lt;&lt; maxRoad &lt;&lt; endl;&#125;#endif // !_MAZESOLVE_H LocDir.h 123456789101112131415161718192021222324252627282930313233343536#ifndef _LOCDIR_H#define _LOCDIR_H#include&lt;iostream&gt;using namespace std;class LocDir&#123;public: LocDir(int X=0, int Y=0, int dir=0); friend ostream&amp; operator&lt;&lt;(ostream&amp; out,const LocDir&amp; loc_dir); ~LocDir(); int X; int Y; int dir;private:&#125;;LocDir::LocDir(int X,int Y,int dir):X(X),Y(Y),dir(dir)&#123;&#125;LocDir::~LocDir()&#123;&#125;ostream&amp; operator&lt;&lt;(ostream&amp; out, const LocDir&amp; loc_dir)&#123; out &lt;&lt; '(' &lt;&lt; loc_dir.X &lt;&lt; ',' &lt;&lt; loc_dir.Y &lt;&lt; ')' &lt;&lt; '\\t'; return out;&#125;#endif // !_LOCDIR_H","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://didongdongdi.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://didongdongdi.github.io/tags/C/"}],"author":"DiDong"},{"title":"the Summary of Intercultural Communication (5)","slug":"Intercultural-Communication-5","date":"2018-10-12T15:00:00.000Z","updated":"2019-05-26T05:15:09.000Z","comments":true,"path":"2018/10/12/Intercultural-Communication-5/","link":"","permalink":"https://didongdongdi.github.io/2018/10/12/Intercultural-Communication-5/","excerpt":"High-context and low-context cultures &amp;&amp;&amp;&amp;&amp;Q: What are High-context and low-context culture ?","text":"High-context and low-context cultures &amp;&amp;&amp;&amp;&amp;Q: What are High-context and low-context culture ? A: Terms used to describe cultures based on how explicit the messages exchanged are and how much the context means in certain situations. (Introduced by the anthropologist Edward T.Hall in his 1976 book Beyond Culture.) Context as a relativistic metric of culture Higher-context culture ——————— Lower-context culture African ———————————– Australian Arabic ———————————— Dutch Brazilian ——————————— English Canadian Chinese ———————————- English French Canadian ———————– German French ———————————— New Zealand Greek ————————————- United States Hawaiian Indian Italian Irish Japanese Korean Latin Americans Russian Southern United States Spanish How higher context relates to other cultural metricsDiversity &amp;&amp;&amp;&amp;&amp;High-context: common in the Asian cultures than in European. common in countries with low racial diversity. group/community is valued over the individual. the in-groups and group reliance/support favor higher-context cultures. coexisting subcultures conducive to higher-context situations, where the small group relies on their common background to explain the situation, rather than words. &amp;&amp;&amp;&amp;&amp;Low-context:the need to accommodate individuals with a wide variety of backgrounds. 高语境文化 低语境文化 内隐，含蓄 外显，明了 暗码信息 明码信息 较多的非语言编码 较多的言语编码 反应很少外露 反应外露 圈内外有别 圈内外灵活 人际关系紧密 人际关系不密切 高承诺 低承诺 时间处理高度灵活 时间高度组织化 Language Low-context: Explicit Verbose Elaborated and Restricted Codes Q: Where does the concept of elaborated and restricted codes come from ?A: Sociologist Basil Bernstein in his book Class, Codes and Control. Q: What is elaborated code ?A: It indicates that the speaker is expressing his/her idea by phrasing from an abundant selection of alternatives without assuming the listener shares lots of common knowledge, which allows the speaker to explain their idea explicitly. Q: What is restricted codes ?A: They are phrased from more limited alternatives, usually with collapsed and shortened sentences, therefore it requires the listeners to share a great deal of common perspectives to understand the implicit meaning of the conversation. Collectivism and Individualism Collectivism — High-context cultures Individualism — Low-context cultures Stability and Durability of Tradition High-context culture Facial Expression Q: What are the 6 basic emotions or universal language of emotion ?A: Happy, surprise, fear, disgust, anger and sad. Marketing perspective Q: What is the difference between Japan and the US about the Mcdonalds advertising ?A: Japanese version uses more colors, movements and sounds, while the American version is more straight forward. Conclusion High-context Collectivism Stable and durable tradition Strong sense of tradition and history Little change over time Native Americans over new comers Higher barrier for development Subtler facial expression Shared and taken-for-granted background knowledge Low-context Individualism Fast change Generation gap Overload of information Exaggerated facial expression Couse Notes Higher context Lower context Implicit Explicit How is said is more important than what is said Clear Relational Verbose Collectivist Intuitive Contemplative Next Culture","categories":[{"name":"English","slug":"English","permalink":"https://didongdongdi.github.io/categories/English/"}],"tags":[{"name":"Competence","slug":"Competence","permalink":"https://didongdongdi.github.io/tags/Competence/"}],"author":"DiDong"},{"title":"the Summary of Intercultural Communication (2)","slug":"Intercultural-Communication-2","date":"2018-10-12T10:49:00.000Z","updated":"2019-05-26T05:15:09.000Z","comments":true,"path":"2018/10/12/Intercultural-Communication-2/","link":"","permalink":"https://didongdongdi.github.io/2018/10/12/Intercultural-Communication-2/","excerpt":"Intercultural competence &amp;&amp;&amp;&amp;&amp;Q: What is intercultural competence ?A: A complex of abilities needed to perform effectively and appropriately when interacting with others who are linguistically and culturally different from oneself.","text":"Intercultural competence &amp;&amp;&amp;&amp;&amp;Q: What is intercultural competence ?A: A complex of abilities needed to perform effectively and appropriately when interacting with others who are linguistically and culturally different from oneself. &amp;&amp;&amp;&amp;&amp;Q: How to discuss and describe intercultural competence by terms ?A: intercultural communicative competence (ICC) transcultural communication crosscultural adaptation intercultural sensitivity … … Q: What are all of these terms attempt to account for ?A: The ability to step beyond one’s own culture and function with other individuals from linguisitically and culturally diverse backgrounds. Cultural Symbols &amp;&amp;&amp;&amp;&amp;Q: What is cultural symbols ?A: A physical manifestation that signifies the ideology of a particular culture or that merely has meaning within culture. &amp;&amp;&amp;&amp;&amp;Q: What is culture ?A: An accumulation of the beliefs, traditions, language and values of a particular group of people. THE V SIGN USA : A harmless backwards sign for peace. Australia, UK, Ireland, NZ : Seen as rude and frequently used to signify contempt of defiance towards authority. Examples of Cultural Symbols Q: What can cultural symbols represent ?A: nationalism belief systems traditions language values Symbols Conveying Nationalism to a CountryThe Bald Eagle![the bald eagle](http://teenkidsnews.com/wp-content/uploads/2017/05/BaldEagle_AmericanFlag.jpg) Q: What dose the bald eagle symbolizes in the US (America) ?A: Freedom, strength and power. Swastika![Swastika](http://blogs.longwood.edu/callief/files/2012/01/Macys-Swastika-.jpg) Q: What does the swastika symbolized ?A: The Nazi party in Germany in the 1930s and 40s. The Holocaust was a murderously industrialized genocide. Q: If the symbol rotate 45 degrees, what does it means in some Asian, non-Aryan religions, including Buddhism, Hinduism and Jainism ?A: In Hinduism, it has Sanskrit roots that ultimately mean, making of goodness, and is sort of seen as a sign of good fortune and prosperity. Symbols Conveying Religious Beliefs of a CultureThe Hamsa![the Hamsa](https://img0.etsystatic.com/103/0/12348992/il_fullxfull.990259684_btr9.jpg) Q: What does the Hamsa mean in the Jewish culture ?A: The hand of god is protecting you. Culture is dynamic, shared patterns of socially transmitted, norms, values, beliefs, and symbols. Course Notes![Intercultural Competence](intercultural competence.jpg) Oral presentationBe … brave confident organized cooperative a team-player aware of time Some Chinese Cultural Symbols elephant trunk peak Chariot Temple of Heaven the lunar year of horse Spring Festival Gala … … A physical manifestation Buildings Flowers Arts Customs and traditions Clothes Music Language Religion Food Sports National flag Currency Animals Literature … … Ideology Nationalism Religious beliefs Values and beliefs Norms Culture not fixed dynamic – not static shared patterns Next Lecture","categories":[{"name":"English","slug":"English","permalink":"https://didongdongdi.github.io/categories/English/"}],"tags":[{"name":"Competence","slug":"Competence","permalink":"https://didongdongdi.github.io/tags/Competence/"}],"author":"DiDong"},{"title":"电路原理图设计原则","slug":"电路原理图设计原则","date":"2018-10-05T15:54:00.000Z","updated":"2019-05-26T05:15:09.000Z","comments":true,"path":"2018/10/05/电路原理图设计原则/","link":"","permalink":"https://didongdongdi.github.io/2018/10/05/%E7%94%B5%E8%B7%AF%E5%8E%9F%E7%90%86%E5%9B%BE%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/","excerpt":"先规划放置好元件，尽可能使后面连线简单，且能看出逻辑。 数量大且简单的连线尽可能短且集中，先连。 数量小且复杂的连线可能较为长且分散，后连。 连线完成后进行调整优化，使得连线整齐，利用好每一块地方，使得总体占用的面积最小。（如果空间实在不足，可调整图纸大小）","text":"先规划放置好元件，尽可能使后面连线简单，且能看出逻辑。 数量大且简单的连线尽可能短且集中，先连。 数量小且复杂的连线可能较为长且分散，后连。 连线完成后进行调整优化，使得连线整齐，利用好每一块地方，使得总体占用的面积最小。（如果空间实在不足，可调整图纸大小）","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://didongdongdi.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://didongdongdi.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"author":"DiDong"},{"title":"the Summary of Intercultural Communication (1)","slug":"Intercultural-Communication-1","date":"2018-09-28T06:55:00.000Z","updated":"2019-05-26T05:15:09.000Z","comments":true,"path":"2018/09/28/Intercultural-Communication-1/","link":"","permalink":"https://didongdongdi.github.io/2018/09/28/Intercultural-Communication-1/","excerpt":"How to make a power-point presentationTop Tips for Effectivve presentations (10)Passion and Connect","text":"How to make a power-point presentationTop Tips for Effectivve presentations (10)Passion and Connect Be honest with the audience about what is important to you and why it matters. Be enthusiastic and honest, and the audience will respond. Note: Tell your audience what you really want to tell them. Needs Be built around what your audience is going to get out of the presentation. Bear in mind what the audience needs and wants to know, not what you can tell them (when preparing). Focuse on your audience’s response, and react to that. Make it easy for your audience to understand and respond. Simple Core Message A 30-second ‘elevator summary’ No more than 15 words Smile and Eye Contact Make sure that you don’t turn down all the lights so that only the slide screen is visible. Your audience needs to see you as well as your slides. Start Strongly Explain who you are. Entertain them. A story or an attention-grabbing (but useful) image. 10-20-30 Rule Slideshows should: Contain no more than 10 slides Last no more than 20 minutes Use a font size of no less than 30 point Note: A good set of slides should be no use without the presenter. If you need to provide more information, create a bespoke handout and give it out after your presentation. StoriesYou need your presentation to act like a story. Storytelling mechanics: Focusing On Characters A Changing Dynamic Voice Varying the speed Emphasizing changes in pitch and tone Body AVOID: crossed arms, hands behind your back or in your pockets, and pacing the stage MAKE: gestures open and confident, and move naturally Relax, Breathe and Enjoy Slow your breathing down, Relax and Enjoy in your presentation. Four dimensions for a distinctive, effective and polished PowerPoint presentationContent Q: How a well-designed presentation should be?A: It makes ideas flow in a logical manner and can be either persuasive or informative. Q: What is the structure of a good presentation?A: Start broad, get specific and end broad. Q: How to write the opening within the first 30 seconds?A: A story (or a compelling question): personal, unexpected, challenging or funny. A quote Repetition: key message. Language(S&amp;S)Simple No jargon, no abbreviation. SignpostsHow to … welcome introduce yourself introduce your presentation outline your presentation explain that there will be time for questions at the end start the presentation close a section begin a new section conclude and summarizing finish and thank invite questions refer to a previous point deal with (difficult) questions Design Q: How long shall we talk on one slide?A: No more than 1.5 mins. Q: How many words and lines on each slide?A: No more than 6 lines per slide, 6 words per line.(The less the better.) Q: How big shall be the text?A: 30-40 for the text, 60 font size for the title. Q: Which font is the best font?A: Use a Sans Serif font, like Arial or Comic Sans. Avoid Times New Roman or Courier, they are old-fashioned and not professional. Use the same fonts for title and body text. Don&#39;t use more than 3 fonts. Q: How to make point clear?A: Use headers (a simple sentence), followed by bullets(3) or sub-bullets. Make sure to present all the bullets at the same time rather than one at a time. Q: How to use color?A: Use contrasting colors (blue and white, white and black). Avoid complementary colors (red and green, blue and orange, purple and yellow). Q: Can I use sound effects?A: You’d better not to. DeliveryVerbal communication (voice, pitch and pace)SSST strategy Speak loudly and slowly. Speak confidently and professionally. Silence is golden. Thank the audience twice.(begin and end) Non-verbal communication (eye contact and body language) Dress the part. Smile and make eye contact. Start and finish on time. Last thing Practice and rehearse. Next Lecture","categories":[{"name":"English","slug":"English","permalink":"https://didongdongdi.github.io/categories/English/"}],"tags":[{"name":"Competence","slug":"Competence","permalink":"https://didongdongdi.github.io/tags/Competence/"}],"author":"DiDong"},{"title":"C++ 与 哲学","slug":"C++ 与 哲学","date":"2018-09-28T02:04:00.000Z","updated":"2019-05-26T05:15:09.000Z","comments":true,"path":"2018/09/28/C++ 与 哲学/","link":"","permalink":"https://didongdongdi.github.io/2018/09/28/C++%20%E4%B8%8E%20%E5%93%B2%E5%AD%A6/","excerpt":"以下只是我个人对C++语言的一些理解，只是为了更好地学习和使用C++，如有描述不当处，还请指出。 前言很多的科幻大片中都有虚拟世界的存在，好比是现实世界的映射或是更近一步的提升，如黑客帝国中的matrix,又如神盾局特工中的framework，等等。 而这些虚拟世界无一不是建立在一行一行代码的基础上的。","text":"以下只是我个人对C++语言的一些理解，只是为了更好地学习和使用C++，如有描述不当处，还请指出。 前言很多的科幻大片中都有虚拟世界的存在，好比是现实世界的映射或是更近一步的提升，如黑客帝国中的matrix,又如神盾局特工中的framework，等等。 而这些虚拟世界无一不是建立在一行一行代码的基础上的。 C++作为一门面向对象的语言，是为了更好地描述这个世界，从而能够打造出与现实世界几乎相同的世界，甚至是超越现实的世界。 而要描述一个世界则离不开哲学。 世界的基本组成在这里，我们认为现实世界由三种最基本的事物构成的，即：物质、能量和信息。 而在虚拟世界中，一切的物质和能量都是由现实世界所提供的。真正存在于虚拟世界中的是信息。 世界到C++的映射物质 == 数据类型基本的夸克、电子、场…… == int、short、char、char、long、unsigned、double、float、bool…… 扩展的各种各样的元素 == struct 其它的 变量 == 载体 常量 == 限定的变量（const） #define（字符替换） 信息 == 函数函数使得各种类型的数据有序地进行交互。 能量能量从外界摄取，就像是点下了运行的按钮。 对象实例与抽象类现实世界中的信息和物质影射到C++语言中变为函数和变量。 而在C++语言中： 具体事物 == 对象实例 一类事物 == 抽象类 其他每个人对同一事物的类的定义可能有所不同，因为一方面每个人的收敛思维和抽象能力不同，从而导致抽象的层次不同；另一方面，在不同的应用场景之下，抽象层次也不尽相同。 所以，对对象实例的抽象，即抽象类的形成应该视具体情况而定。","categories":[{"name":"Programming Language","slug":"Programming-Language","permalink":"https://didongdongdi.github.io/categories/Programming-Language/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://didongdongdi.github.io/tags/C/"}],"author":"DiDong"},{"title":"the Summary of Intercultural Communication (4)","slug":"Intercultural-Communication-4","date":"2018-09-27T04:25:00.000Z","updated":"2019-05-26T05:15:09.000Z","comments":true,"path":"2018/09/27/Intercultural-Communication-4/","link":"","permalink":"https://didongdongdi.github.io/2018/09/27/Intercultural-Communication-4/","excerpt":"Intercultural communication skills Q: What abilities do employers look for from employees about intercultural skills?A: Understand people from different cultural backgrounds, build trust, demonstrate respect, and speak other languages.","text":"Intercultural communication skills Q: What abilities do employers look for from employees about intercultural skills?A: Understand people from different cultural backgrounds, build trust, demonstrate respect, and speak other languages. What do employers understand by intercultural skills ?Descriptor contexts and viewpoints respect settings differences languages ideas and ways of thinking Why do employers think that intercultural skills are important ? Benefits: earnings new clients diverse teams brand and reputation Risks: loss of clients damage to reputation team conflict How do employers evaluate job candidates for intercultural skills ? Strong communication (interview and selection) Foreign language Cultural sensitivity (interview) Studying overseas Working overseas The Ritual of Conversation across CulturesKey Terms Preview &amp;&amp;&amp;&amp;&amp; absent presence conversational initiation phatic communion conversational preview conversational talking points conversational feedback conversational closing Introduction Q: What is absent presence ?A: A behavior that someone can be here, but also be there, in another world, separate from his or her surroundings, including people. Q: What should a skilled intercultural communicator know ?A: When to speak, when to remain silent, and to always stop speaking before the listener stops listening. Q: What is an important first step when engaging in a conversation ?A: Being open to others and their differences. Q: Why discuss the ritual of conversation ?A: Because it is one of the main ways we interact across cultures and it is ripe for misunderstandings. Q: What dose the ritual of conversation will allow you to do when examining it ?A: Consider its components, predict the next turn, anticipate an opening or closing, and beconme a better conversationalist. Initiation (1st stage) Q: What does conversational initiation require ?A: It requires you to be open to interaction. Q: What does ‘small talk phatic communion’ reinforced ?A: A idea that there is a degree of ritual across cultures on how we initiate, engage, and conclude conversations. Preview (2nd stage) Q: What is conversational preview ?A: An indication, verbal or nonverbal, of what the conversation is about, both in terms of content and in terms of the relationship. Talking Points (3rd stage) Q: What is talking points ?A: It represents the essential meanings shared in the interaction. Feedback (4th stage) Q: What is conversational feedback ?A: It allows the conversational partners to clarify, restate, or discuss the points of the conversation to arrive a sense of mutual understanding. Closing (5th stage) Q: What is conversational closing ?A: It is a verbal and/or nonverbal exchange where the conversational partners agree to end the interaction. Q: What are the factors that influence what you say and hou you close a conversation ?A: Include your relationship and level of familiarity with the person or group. But it is often best to signal your attention to close the conversation clearly to avoid misunderstanding. Course Notes Q: Four elements of intercultural communication.(C-VPN)A: Perception Verbal Process Nonverbal Process Contextual Elements Q: Why do we need to learn intercultural communication ?A: self-awareness demographic changes ethnocentrism creative problem solving workplace economic globalization global and interpersonal peace respect Q: What is ethnocentrism ?A: Tendency to think that our culture is more superior to other. Q: What is perception ?A: beliefs values attitudes world views social organization Q: What is verbal process ?A: The ways in which cultures employ symbols to portray things and experiences. Q: What is nonverbal process ?A: Shared thoughts and feelings of bodily behavior, time and space. Q: What is contextual elements ?A: business education and health care tourism personal relationships Next Lecture","categories":[{"name":"English","slug":"English","permalink":"https://didongdongdi.github.io/categories/English/"}],"tags":[{"name":"Competence","slug":"Competence","permalink":"https://didongdongdi.github.io/tags/Competence/"}],"author":"DiDong"},{"title":"the Summary of Intercultural Communication (3)","slug":"Intercultural-Communication-3","date":"2018-09-24T15:32:00.000Z","updated":"2019-05-26T05:15:09.000Z","comments":true,"path":"2018/09/24/Intercultural-Communication-3/","link":"","permalink":"https://didongdongdi.github.io/2018/09/24/Intercultural-Communication-3/","excerpt":"Interpersonal &amp; intercultural communication skillsINTERPERSONAL SKILLS (6) Communication Skills Emotional Intelligence Conflict Resolution and Mediation Skills Team-Working, Groups and Meetings Decision-Making and Problem-Solving Negotiation and Persuasion Skills","text":"Interpersonal &amp; intercultural communication skillsINTERPERSONAL SKILLS (6) Communication Skills Emotional Intelligence Conflict Resolution and Mediation Skills Team-Working, Groups and Meetings Decision-Making and Problem-Solving Negotiation and Persuasion Skills What is Interpersonal Communication &amp;&amp;&amp;&amp;&amp;Definition: the process by which people exchange information, feelings, and meaning through verbal and non-verbal messages: it is face-to-face communication. &amp;&amp;&amp;&amp;&amp;1.how it is said: non-verbal messages sent through tone of voice, facial expressions, gestures and body language.2.what is actually said : the language used. Q: How an observer receive messages from a person without speech? (6 points)A: posture, facial expression, and dress to form an impression of the other’s role,emotional state, personality and/or intentions. Elements of Interpersonal Communication (3C+MNF) &amp;&amp;&amp;&amp;&amp;Context where roles responsibilities relative status emotional climate expectations Communicators one-way process two-way processes (feedback) Message verbal non-verbal (such as facial expressions, tone of voice, gestures and body language) (can reveal more about emotional attitudes which may underlie the content of speech) Channel Definition: the phycical means by which the message is transferred from one person to another Feedback Consists: messages the receiver returns receiver’s reaction Type: direct verbal statements subtle facial expressions changes in posture Note: The receiver may also respond to the unintentional message as well as the intentional message. Noise Definition: anything that distorts the message Examples: sound complicated jargon inappropriate body language inattention disinterest cultural differences Uses of Interpersonal Communication information ( –&gt; and &lt;– ) attitudes and behavior contacts and relationships world and experiences needs emotional support ( –&gt; and &lt;– ) decisions and problems behavior power Next Lecture","categories":[{"name":"English","slug":"English","permalink":"https://didongdongdi.github.io/categories/English/"}],"tags":[{"name":"Competence","slug":"Competence","permalink":"https://didongdongdi.github.io/tags/Competence/"}],"author":"DiDong"},{"title":"GitCommand","slug":"GitConmand","date":"2018-08-29T07:48:00.000Z","updated":"2019-05-26T05:15:09.000Z","comments":true,"path":"2018/08/29/GitConmand/","link":"","permalink":"https://didongdongdi.github.io/2018/08/29/GitConmand/","excerpt":"","text":"GitHub地址","categories":[{"name":"Git","slug":"Git","permalink":"https://didongdongdi.github.io/categories/Git/"}],"tags":[{"name":"Command","slug":"Command","permalink":"https://didongdongdi.github.io/tags/Command/"}],"author":"DiDong"},{"title":"hexo博客 百度统计 配置","slug":"BaiduTongji","date":"2018-05-26T05:17:00.000Z","updated":"2019-05-26T05:26:10.058Z","comments":true,"path":"2018/05/26/BaiduTongji/","link":"","permalink":"https://didongdongdi.github.io/2018/05/26/BaiduTongji/","excerpt":"","text":"在 baidu_analytics: 后添加百度统计提供的代码中的网址的 htm? 后的部分。","categories":[{"name":"Blog","slug":"Blog","permalink":"https://didongdongdi.github.io/categories/Blog/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://didongdongdi.github.io/tags/Hexo/"}]},{"title":"github pages 出现 “the CNAME is already taken” 的解决办法","slug":"CNAME","date":"2018-05-26T05:17:00.000Z","updated":"2019-05-26T05:25:55.440Z","comments":true,"path":"2018/05/26/CNAME/","link":"","permalink":"https://didongdongdi.github.io/2018/05/26/CNAME/","excerpt":"之前因为每次deploy博客后，都会出现绑定的域名指向 github 404 的情况，原因是 setting 下github pages 的 custom domain 清空了，需要重新设置来生成CNAME文件。为了避免每次都去设置，于是按照网上的方法，在博客的source目录下安放了CNAME文件。然后重新deploy，结果访问绑定的域名仍旧是404。再回到 setting 的 github pages ，提示 “the CNAME is already taken” 。","text":"之前因为每次deploy博客后，都会出现绑定的域名指向 github 404 的情况，原因是 setting 下github pages 的 custom domain 清空了，需要重新设置来生成CNAME文件。为了避免每次都去设置，于是按照网上的方法，在博客的source目录下安放了CNAME文件。然后重新deploy，结果访问绑定的域名仍旧是404。再回到 setting 的 github pages ，提示 “the CNAME is already taken” 。 然后在网上到处搜索包括看官方的文档也没找到靠谱的解决方案。最后不得已请求 github support ，然后收到了github support 的回复（泪牛满面 〒▽〒）：大致上的意思是需要新增一个TXT的DNS解析记录，让github support 进行验证再释放绑定的域名。 然后回复邮件告诉对方已经完成操作。 最后就收到了已经释放域名的邮件。 重新解析域名到github pages。 稍等一会后，就会发现又可以访问了（再次泪牛满面 〒▽〒）。但是这个时候还不能设定为https传输，需要稍等一会就可以了。 PS: 邮件的回复需要等一段时间，我大概等两个邮件的回复用了一天吧。","categories":[{"name":"Blog","slug":"Blog","permalink":"https://didongdongdi.github.io/categories/Blog/"}],"tags":[{"name":"Github","slug":"Github","permalink":"https://didongdongdi.github.io/tags/Github/"},{"name":"Domain","slug":"Domain","permalink":"https://didongdongdi.github.io/tags/Domain/"}]},{"title":"CentOS7登录 之 \"Sorry,that doesn't work.Please try again.\"","slug":"Capital","date":"2018-05-26T05:17:00.000Z","updated":"2019-05-26T05:26:02.162Z","comments":true,"path":"2018/05/26/Capital/","link":"","permalink":"https://didongdongdi.github.io/2018/05/26/Capital/","excerpt":"","text":"大写使用shift+字母,而不是CapsLock。","categories":[{"name":"Problem","slug":"Problem","permalink":"https://didongdongdi.github.io/categories/Problem/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://didongdongdi.github.io/tags/Linux/"},{"name":"虚拟机","slug":"虚拟机","permalink":"https://didongdongdi.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"}]},{"title":"Flipped (Week 1)","slug":"Flipped_Week1","date":"2018-05-26T05:17:00.000Z","updated":"2019-05-26T05:25:47.057Z","comments":true,"path":"2018/05/26/Flipped_Week1/","link":"","permalink":"https://didongdongdi.github.io/2018/05/26/Flipped_Week1/","excerpt":"2018-06-01-p2flip over //翻页 gutsy girl //勇敢的女孩 delightful //可爱的；讨人喜欢的；令人愉快的","text":"2018-06-01-p2flip over //翻页 gutsy girl //勇敢的女孩 delightful //可爱的；讨人喜欢的；令人愉快的 With a charismatic leading lady kids will flip over, a compelling dynamic between the two narrators and a resonant ending, this novel is a great deal larger than the sum of its parts. //有了魅力四射的女主角，孩子们就会翻过去，这是两个叙述者之间的一个引人注目的动态，一个共鸣的结尾，这部小说比它的各个部分的总和要大得多。 charismatic //超凡魅力的；神赐能力的 a compelling dynamic //一个激发兴趣的动力 narrator //叙述者；解说员 resonant //洪亮的；共鸣的 light-hearted //轻松的；无忧无虑的 wry //adj.歪斜的；歪曲的；用反语表达幽默的；揶揄的 v.扭曲；扭歪 substance //物质；实质；资产；主旨 subtlety //微妙；敏锐；精明 dedicate //vt.致力；献身；题献 infinite //n.无限；无穷大；无限的东西（如空间，时间）adj.无限的；无数的；极大的 insight //洞察力；洞悉 a reduced-filler diet //减少摄入的饮食 eternal gratitude //刻苦铭心 eternal //永恒的；不朽的 gratitude //n.感谢（的心情）；感激 on the ball //adv.机灵；留心；有见识；勤奋 Diving Under //潜水下 buddy //n.伙伴；密友；小男孩 vi.做好朋友，做朋友 Sycamore //美国梧桐；西克莫无花果树；假挪威槭 Brawk //？ looming //n.幽影 v.逼近；隐约可见(looming) adj.隐隐约约的；正在逼近的 smelly //有臭味的 willies //n.焦虑不安；心惊肉跳 2018-06-17-p3back off //后退；软化；减轻；卸下 moving van //家具搬运车 strategic avoidance //战略回避 social discomfort //社会不安 barge into //闯入；与…相撞 shove //n.推；挤 vt.挤；强使；撞；猛推 wedged her way into //挤进 catapult //n.弹弓；石弩；飞机弹射器；（飞机上的）座椅弹射器 vt.用弹弓射；用弹射器发射；猛投 vi.用弹射器弹射；快速移动 caked with the stuff //由…东西结成块状 hop out //快速离开 rear end //臀部；后部 implication //含义；暗示；牵连；可能的结果 toss //n.投掷；摇荡；投掷的距离；掷币赌胜负 vt.投掷；使…不安；突然抬起；使…上下摇动；与…掷币打赌 vi. 辗转；被乱扔；颠簸；掷钱币决定某事 scoot over to //快走到 pull her up //把她拉上来 run along home //离开家 soon-to-become-acute //很快变得严重 take a hint //领会别人的暗示；接受暗示 zip on home //回家 mutter //n.喃喃低语 v.咕哝 wink //n.眨眼；使眼色；闪烁；瞬间 vt.眨眼 vi.眨眼；使眼色；闪烁 right off //立刻 a ditch play //小花招 run with //鼓励；与…一起跑；与…交往 parental law //父母的法律 muddy //adj.泥泞的；模糊的；混乱的 vt.使污浊；使沾上泥；把…弄糊涂 vi.变得泥泞；沾满烂泥 in motion //在运转中 liftgate //提升式门 get up the nerve to look //鼓起勇气去看 blast right past me //猛地一下从我身边过去 yank me along //猛拉我一起 plant myself //使自己安顿下来 weirdest //不可思议的 windmill motion //风车运动 break away from //vt.放弃，脱离… somehow on the downswing my hand wound up tangling into hers //不知怎么的，我的手缠上了她的手。 clamp on //夹合 sappiest //最愚笨的 2018-06-18-p4pull free // 挣脱 a death grip // 死死地控住 grin //v.露齿而笑 n.露齿笑 fiery red face //通红的脸 dive behind // 躲到…后面 flash her help signal // 向她发出求救信号 tramp right in // 走进 a crusty heap on our porch // 一堆壳子一样的东西在我们的走廊上 peek out // 向外偷看 sneak out //偷偷溜走 a very sophisticated ditch // 一个非常富有经验的陷阱 be far from over // 远未结束 couch //vt.使躺下；表达；弯下 vi.蹲伏，埋伏；躺着 n.睡椅，长沙发；床；卧榻 cut across the yard // 穿过院子里 spot her in the nick of time // 及时发现她 no concept of // 没有概念 on the slide //日益恶化 run block //阻挡 plain gone //普通的了 sabotage //n.破坏；破坏活动；怠工vt.妨害；对…采取破坏行动vi.从事破坏活动 She’s got ANTAGONIZE written all over her. //她在她身上引起了敌意。 cross-eyed //斜视的；对视眼的；斗鸡眼的 stick out //突出；坚持；醒目 knock-down-drag-out with //不惜一切手段的 Girls don’t fight fair. //女生不公平的战斗。 gouge //n.沟；圆凿；以圆凿刨vt.用半圆凿子挖；欺骗 pinch //n.匮乏；少量；夹痛vt.捏；勒索；使苦恼；掐掉某物，修剪vi.夹痛；节省 gasp //n.喘气vi.喘气；喘息；渴望vt.气喘吁吁地说；喘着气说话 time-out //n.休息时间，暂停 snap at the bait //上钩 Let it dangle. //让它挺直。 Laugh it off. //一笑而过。 lure //n.诱惑；饵；诱惑物vt.诱惑；引诱 Swim around it. //四处游动。 bonus //n.奖金；红利；额外津贴 pain-in-the-rear //十分令人讨厌的人或事 jerk //n.肌肉抽搐；性情古怪的人；蠢人；急拉vi.痉挛；急拉；颠簸地行进vt.猛拉 get all pumped up over //把所有的东西都抽上来 dive down //潜入 get clobbered by some parental tidal wave //被某些父母的影响所击倒 clueless //无线索的；愚蠢的 thrash //n.打谷；逆风浪行进；踢水动作vt.打；使逆行vi.打谷；白忙；猛烈摆动 drowning //n.溺死v.淹没；（使）[外科] 淹溺；浸没（drown的ing形式）adj.溺水的 dive for calmer water //扑向平静的水 2018-06-19-p5form //n.形式，形状；形态，外形；方式；表格vt.构成，组成；排列，组织；产生，塑造vi.形成，构成；排列 bait me with Juli //用Juli引诱我 She even snuck her past Dad once and marched her all around the house, hunting me down. //她甚至有一次偷偷瞒着爸爸，带着她到处跑，把我打倒在地。 wedge //n.楔子；楔形物；导致分裂的东西vt.楔入；挤进；楔住vi.楔入；挤进 get booted //被赶出 stuff //n.材料，原料，资料；〈俚〉钱，现金；填充物；素材资料；vt.塞满；填塞；让吃饱；vi.`吃得过多； debate //n.讨论；辩论；争论；辩论；v.辩论；仔细考虑；思考；盘算； Empire settees and French Rococo tables //帝国沙发和法国洛可可桌子 be dying to //渴望 dribble it up and down their driveway //在他们的车道上下车 curb //n.抑制；路边；勒马绳vt.控制；勒住 awful //可怕的；极坏的；使人敬畏的 turn out //（以某种方式）发生；最后是，结果是；出席，参加，前去观看；关掉，熄灭（电灯、煤气等）；生产，制造 squeal //n.尖叫声vt.告密；长声尖叫vi.告密；尖声地说 charge across //冲过 this attack away //这种攻击了 a front-line //一线 be branded for life //是品牌的生命 jeer //n.嘲笑；戏弄；揶揄的言语v.嘲笑；戏弄 recess //n.休息；休会；凹处vt.使凹进；把…放在隐蔽处vi.休息；休假 lay kisses on //吻 trail //n.小径；痕迹；尾部；踪迹；一串，一系列vt.追踪；拖；蔓延；落后于vi.飘出；蔓生；垂下；拖曳 turn around //转向反方向；(生意或经济) 好转；船只留港 start out //出发；着手进行 ward off //避开；挡住 hatch //n.孵化；舱口vt.孵；策划vi.孵化 beat me why //让我思考为什么 gem //n.宝石，珍宝； 精华；受人重视者vi.点缀； 用宝石装饰； 饰以宝石adj.最佳品质的 catfight //激烈的争辩 code of honor //荣誉准则 corrupt //adj.腐败的，贪污的；堕落的vt.使腐烂；使堕落，使恶化vi.堕落，腐化；腐烂 weepy females //流泪的女人 2018-06-20-p6cross-examining //vt.盘诘；反复询问vi.盘问 cop to //接受；承认 sniff //vt.嗅；闻；用力吸；发觉vi.嗅；嗤之以鼻n.吸，闻；嗤之以鼻；气味；以鼻吸气；吸气声 blew down //吹倒 dump //n.垃圾场；仓库；无秩序地累积vt.倾倒；倾卸；丢下，卸下；摆脱，扔弃；倾销vi.倒垃圾；突然跌倒或落下；卸货；转嫁（责任等） goo-goo //n.政治改革者；装作好人的人adj.爱慕的；色情的 stick to //遵守；保留；紧跟；忠于 glue //vt.胶合；紧附于n.胶水；胶粘物；粘聚力 doctorate //博士学位；博士头衔 scrutinize //vt.仔细检查 n.仔细或彻底检查 baptize //vt.给…施洗礼；（施洗时）授…以教名；给…精神上的洗礼；使经受考验；vi.行浸礼（或洗礼） dissertations //专题论文；学位论文 come in handy //迟早有用 cursive //adj.草书的n.草书 aisle //过道；侧廊；狭长的通道 eye-shot //视野 snag //n.小困难或障碍；突出物；钩丝vt.戳坏；抓住；清除暗桩vi.妨碍；被戳坏 shift //n.移动；变化；手段；轮班vt.转移；改变；替换vi.移动；转变；转换 optimizing positional latitude and longitude //优化位置纬度和经度 maniac //n.疯子，躁狂者adj.发狂的；狂热的；癫狂的 lean forward //探身过去 edge //n.边缘；优势；刀刃；锋利vt.使锐利；将…开刃；给…加上边vi.缓缓移动；侧着移动 scalp //n.头皮；战利品v.剥头皮 elbow //n.肘部；弯头；扶手vt.推挤；用手肘推开 scoot //n.疾走；轻便摩托车vt.迅速跑开；猛冲vi.溜走；快走；骑轻便摩托车 scoot up //往前一点；稍微移动 lean over //vt.倾身（弯下身子） delicate //微妙的；精美的，雅致的；柔和的；易碎的；纤弱的；清淡可口的 be stuck with //遇到困难无法进行下去；无法摆脱 blown //v.风吹（blow的过去分词）adj.吹制的，吹出的；开花的，盛开的；喘气的 sly //狡猾的；淘气的；诡密的 bug //n.臭虫，小虫；故障；窃听器vt.烦扰，打扰；装窃听器vi.装置窃听器；打扰 bug off //走开；错误关闭 2018-06-21-p7lunatic //n.精神失常者，精神病人；疯子；极愚蠢的人；狂人adj.疯狂的；精神错乱的；愚蠢的；极端的 framed //框架建筑 blackness //黑色；黑人民族性；阴郁；邪恶 lashes //n.鞭挞；鞭子；突然猛烈的一击；急速挥动 dazzling //adj.耀眼的；灿烂的v.眼花 breathtaking //非常激动人心的；惊人的；惊险的；使人透不过气来的 anticipation //期望；预期；预支 dandy //adj.服装华丽的；最好的n.花花公子；最好的东西 vacuuming //真空处理 dribbling //n.（燃料或油从系统内）泄露v.流口水（dribble的现在分词）；（使液体）滴下或作细流；运球 from chore to chore //家务琐事 literally //逐字的；照字面的；真实的；简直 overwhelm //淹没；压倒；覆盖；压垮 chomp //vi.切齿 retrieve //vt.取回；恢复；重新得到；检索vi.找回猎物n.恢复；挽回；取回；检索 preoccupied //adj.全神贯注的；被抢先占有的心事重重的v.使专心于(过去式） tug on //拖船上 record-breaking //破纪录(的） hang back //犹豫；畏缩不前 lift-gate //升降门 matching turquoise //匹配的绿松石 #2018-06-23-p8 cricket //板球；蟋蟀 be sick of //厌恶；厌倦 collapse //v.倒塌；瓦解；暴跌vt.使倒塌；使萎陷；折叠n.倒塌；失败；衰竭 shove //vt.挤；强使；撞；猛推n.推；挤 send off //挤出；派遣；给。。。送行 beneath //prep. 在…之下adv. 在下方 midair //n.半空中 drift away //渐渐疏远 force //n. 力量；武力；军队；魄力vt. 促使，推动；强迫；强加 swirl //n. 旋涡；[流] 涡流v. 使旋转；搅；环绕 twirl //n. 转动，旋转；旋转的东西；万能钥匙vt. 使快速转动，使快速旋转；捻弄vi. 旋转，转动 hallway //n. 走廊；门厅；玄关 mature //adj. 成熟的；充分考虑的；到期的；成年人的vt. 使…成熟；使…长成；慎重作出vi. 成熟；到期 wiggle //n. 扭动vt. 使……摆动，使……扭动vi. 摆动 doorknob //n. 门把手 fierce //adj. 凶猛的；猛烈的；暴躁的 chick //n. 小鸡；小鸟；少妇adj. 胆小的；懦弱的 yank on //猛拉上 eat up //吃光；耗尽；击垮 dizzy //adj. 晕眩的；使人头晕的；昏乱的；心不在焉的；愚蠢的vt. 使头晕眼花；使混乱；使茫然 radically //根本上；彻底地；以激进的方式 beast //n. 野兽；畜生 whippet-only //？ curiosity //好奇心；珍品","categories":[{"name":"English","slug":"English","permalink":"https://didongdongdi.github.io/categories/English/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://didongdongdi.github.io/tags/Notes/"},{"name":"Vocabulary","slug":"Vocabulary","permalink":"https://didongdongdi.github.io/tags/Vocabulary/"},{"name":"Novel","slug":"Novel","permalink":"https://didongdongdi.github.io/tags/Novel/"}]},{"title":"Flipped (Week2)","slug":"Flipped_Week2","date":"2018-05-26T05:17:00.000Z","updated":"2019-05-26T05:25:38.382Z","comments":true,"path":"2018/05/26/Flipped_Week2/","link":"","permalink":"https://didongdongdi.github.io/2018/05/26/Flipped_Week2/","excerpt":"2018-06-29-p9humming // n. 哼唱 adj. 嗡嗡作响的，精力充沛的 v. 嗡嗡作响(hum的ing形式)ninny //傻子whiny //烦躁的；爱抱怨的","text":"2018-06-29-p9humming // n. 哼唱 adj. 嗡嗡作响的，精力充沛的 v. 嗡嗡作响(hum的ing形式)ninny //傻子whiny //烦躁的；爱抱怨的 gossipy //漫谈式的；喜欢饶舌的backstab //以卑鄙的手段陷害elementary //基本的；初级的；元素的undisputed //毫无疑问的diva //歌剧中的首席女主角lap // n.一圈；膝盖；下摆；山坳 vt.使重叠；拍打；包围 vi.重叠；轻拍；围住calisthenics //健美体操claim //vi. 提出要求 vt. 要求；声称；需要；认领 n. 要求；声称；索赔；断言；值得collapse // vi. 倒塌；瓦解；暴跌 vt. 使倒塌，使崩溃；使萎陷；折叠 n. 倒塌；失败；衰竭strain //n. 张力；拉紧；负担；扭伤；血缘 vi. 拉紧；尽力 vt. 拉紧；滥用；滤去；竭力 n. （植物、动物的）品种；种类stretched //adj. 拉伸的，伸展了的 v. 伸直，伸展；舒展（stretch的过去分词）；伸缩swoon //n. 昏晕；狂喜 vi. 昏晕；惊讶；着迷bug // vt. 烦扰，打扰；装窃听器 vi. 装置窃听器；打扰get out of //逃避；避免asthma //哮喘；气喘ankle //踝delicate //微妙的；精美的，雅致的；柔和的；易碎的；纤弱的；清淡可口的clip //n. （塑料或金属的）夹子；回纹针；修剪；剪报 vt. 剪；剪掉；缩短；给…剪毛（或发）用别针别在某物上，用夹子夹在某物上 vi. 剪；修剪；剪下报刊上的文章（或新闻、图片等）；迅速行动；用别针别在某物上，用夹子夹在某物上bead //n. 珠子；滴；念珠 vi. 形成珠状，起泡 vt. 用珠装饰；使成串珠状braid //n. 辫子；穗带；发辫 vt. 编织swirl //n. 漩涡；打旋；涡状形 vi. 盘绕；打旋；眩晕；大口喝酒 vt. 使成漩涡ponytail //马尾辫rival //n. 对手；竞争者 adj. 竞争的 vt. 与…竞争；比得上某人 vi. 竞争carousel //旋转木马；行李传送带；轮播shimmy //n. 西迷舞（一种爵士舞）；摇动；女式衬衣 vt. 摇动；振动cuddle //n. 搂抱 vt. 拥抱；亲热地搂住；抚爱地拥抱 vi. 拥抱；偎依；舒服地贴着身睡dandy //n. 花花公子；好打扮的人 adj. 上等的；服装华丽的pushy //有进取心的；爱出风头的；有冲劲的；固执己见的dawn on //开始被理解；渐渐明白swirly //成涡旋形的；纠结的unravel //vt. 解开；阐明；解决；拆散 vi. 解决；散开sniffle //n. 鼻塞声；不断吸鼻子（等于snuffle） vi. 抽鼻涕；抽噎（等于snuffle）gracefully //优雅地；温文地I had her off of him in two seconds flat. //我在两秒钟内把她从他身边拉了下来。herd // n. 兽群，畜群；放牧人 vi. 成群，聚在一起 vt. 放牧；使成群 2018-06-30-p10headlock //摔跤中的夹头hammerlock //（摔跤）将对方手臂扭到背后no amount of //即使再大（或再多）的…（也不）squawking //vt. 抗议；发出响而粗的叫声；大声抱怨 n. 抗议；叫声；诉苦；故障 vt. 粗声叫出；诉苦mussed-up //乱的while I told my side of things to the principal //当我把事情告诉校长的时候sturdy //adj. 坚定的；强健的；健全的swift //n. 褐雨燕 adj. 快的；敏捷的；立刻的 adv. 迅速地dilemma //困境restrain //vt. 抑制；约束；制止braid //辫子；穗带blush //vi. 脸红；感到惭愧 n. 脸红；红色；羞愧 vt. 红着脸表示；使成红色detention //n. 拘留；延迟；挽留lean //vi. 倾斜；倚靠；倾向；依赖 adj. 瘦的；贫乏的 vt. 使倾斜 n. 瘦肉；倾斜；倾斜度earlobes //耳垂fuzz //n. 绒毛；模糊；细毛；警员 vi. 作绒毛状飞散；变成绒毛状；变得模糊 vt. 使模糊；起毛blond //adj. 金发的 n. 白肤碧眼金发的人move in with //搬去和……一起住do crossword puzzles and track his stocks //做填字游戏，追踪他的股票distraction //n. 注意力分散；消遣；心烦意乱Given no one to justify it to … //没有人可以证明这一点 2018-07-03-P11wind up //结束；使紧张；卷起；（非正式）忽悠某人（wind sb up）；上紧(钟、表等的)发条coverage //覆盖；覆盖范围；新闻报道climb out of a sycamore tree //爬出一棵梧桐树maple //枫树；淡棕色birch //桦树；桦条；桦木；用桦条鞭打vacant //空虚的；空的；空缺的；空闲的；茫然的massive //大量的；巨大的；魁梧的gnarl //n. 木节；木瘤 vt. 咆哮；形成木节yak //耗牛 喋喋不休visually //形象化地；外表上；看得见地scourge //vt. 鞭打；蹂躏；严斥；痛斥 n. 鞭；灾祸；鞭子；苦难的根源weed //vt. 除草；铲除 n. 杂草 vi. 除草stick out //突出；坚持；醒目barnyard //n. 谷仓前地空场地 adj. 下流地；粗俗的a boa constrictor //一条蟒蛇beady-eyed //起泡地；饰有珠子的；晶亮如小珠的They held that rodent up by its tail and gulp, the boa swallowed it whole. //他们抓住那只啮齿动物的尾巴，把它提起来，蟒蛇把它整个吞了下去。channel //vt. 引导，开导；形成河道 n. 通道；频道；沟渠；海峡plump up //变丰满；鼓起now //conj. 由于；既然edge //n. 边缘；优势；刀刃；锋利 vt. 使锐利；将…开刃；给…加上边 vi. 缓缓移动；侧着移动overboard //adv. 自船上落下；向船外 adj. 及其热心的；全身心投入的permanently //永久地screw up //拧紧；鼓舞；弄糟；狠狠地提高clown around with //小丑在peel big chunks of bark off //把大块地树皮剥掉slide down the crook in its trunk //从树干上滑下来swing from //悬挂slump beneath //经济衰退之下squeal //vt. 告密；长声尖叫 vi. 告密；尖声地说 n. 尖叫声mutant toy-eating foliage //mutant n.突变体；突变异种 adj. 突变的 toy-eating ? foliage 植物；叶子（总称）hostage //人质；抵押品 2018-07-03-p12relieve //vt. 解除；使不单调乏味；换…地班；解围；使放心weenie //细小的；微小的trap //vt. 诱捕；使…受限制；使…陷入困境；吸收；使…上当 n. 陷阱；圈套；困境；[建] 存水湾 vi. 设陷阱goner //已死者；无望的人；落魄的人scramble up //爬上；巴结；搅混起来set off //出发；引起；动身；使爆炸；抵销；分开outdo //vt. 超过；胜过crook //n. 骗子，坏蛋；弯处，弯曲部分；钩状物 vt. 使弯曲；欺骗，诈骗 vi. 弯曲，成钩形limb //n. 肢，臂；分支；枝干 vt. 切断…的手足；从…上截下树枝bungee //n. 蹦极；橡皮筋；松紧绳shatter //vt. 粉碎；打碎；破坏；破掉；使散开 vi. 粉碎；损坏；落叶 n. 碎片；乱七八糟的状态mortify //vt. 抑制；苦修；使…感屈辱 vi. 禁欲；苦行；约束blow-by-blow //详尽的；逐一记录的come up there with her //和她一起上来magnificent //高尚的；壮丽的；华丽的；宏伟的specifically //特别地；明确地swing down from //摇摆不定的wrench //n. 扳手，扳钳；扭伤；痛苦；歪曲；猛扭 vt. 扭伤；猛扭；曲解；折磨 vi. 扭伤；猛扭；猛绞maniac //n. 疯子 adj. 发狂的；狂热的；癫狂的pull up //拔起；停下来；阻止truck //n. 卡车；交易；手推车 vi. 驾驶卡车；以物易物 vt. 交易；以卡车运输 adj. （美）运货汽车的commotion //骚动；暴乱shout stuff up at //对…喊mutant tangle of gnarly branches //突变的粗糙的分支pesky //adj. 讨厌的；麻烦的 adv.极端bossy //adj. 专横的；浮雕装饰的；爱指挥他人的 n. 母牛；牛犊bail on //放弃；失约 2017-07-05-p131, meaty [‘miːtɪ]adj. 肉的；多肉的；似肉的2, whisker [‘wɪskə]n. [晶体] 晶须；胡须；腮须3, pushy [‘pʊʃɪ]adj. 有进取心的；爱出风头的；有冲劲的；固执己见的4, a showoff 5, backbone [‘bækbəʊn]n. 支柱；主干网；决心，毅力；脊椎6, make out理解；辨认出；说明；填写；设法应付7, a fire brigade 8, crease [kriːs]n. 折痕；折缝vi. 起皱vt. 弄皱；使起折痕9, prior [‘praɪə]adj. 优先的；在先的，在前的n. 小修道院院长；大修道院的副院长; （隐修院）会长; 犯罪前科n. (Prior)人名；(法、西、葡、捷)普里奥尔；(英)普赖尔；(意)普廖尔10, woven [‘wəʊvn]v. 编织；交织（weave的过去分词）；编造adj. 织物的n. 机织织物11, amputate [‘æmpjʊteɪt]vt. 截肢；切断；删除12, another few pounds 13, come off举行，成功；表现；脱离14, beefy [‘biːfɪ]adj. 像牛肉的；结实的；健壮的15, regardless [rɪ’gɑːdlɪs]adj. 不管的；不顾的；不注意的adv. 不顾后果地；不管怎样，无论如何；不惜费用地16, recreational [rekrɪ’eɪʃənl]adj. 娱乐的，消遣的；休养的17, shave off剃掉，刮掉18, slipper [‘slɪpə]n. 拖鞋vt. 用拖鞋打19, salt-and-pepper盐和胡椒20, greased-back 21, blow offv. 放出；吹掉22, get acquainted开始熟悉变得熟络23, friendliness [‘fren(d)lɪnɪs]n. 友谊；亲切；亲密24, summon into 25, dismember [dɪs’membə]vt. 肢解，割断手足；分割，瓜分26, naked [‘neɪkɪd]adj. 裸体的；无装饰的；无证据的；直率的27, lopsided [lɒp’saɪdɪd]adj. 不平衡的，倾向一方的28, chew [tʃuː]n. 咀嚼；咀嚼物vt. 嚼碎，咀嚼vi. 细想，深思n. (Chew)人名；(英)丘29, perch [pɜːtʃ]n. 鲈鱼; 高位；栖木；杆vt. 栖息；就位；位于；使坐落于vi. 栖息；就位；位于n. (Perch)人名；(俄)佩尔奇；(丹)佩克30, board [bɔːd]n. 董事会；木板；甲板；膳食vt. 上（飞机、车、船等）；用板盖上；给提供膳宿vi. 寄宿n. (Board)人名；(英、西)博德","categories":[{"name":"English","slug":"English","permalink":"https://didongdongdi.github.io/categories/English/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://didongdongdi.github.io/tags/Notes/"},{"name":"Vocabulary","slug":"Vocabulary","permalink":"https://didongdongdi.github.io/tags/Vocabulary/"},{"name":"Novel","slug":"Novel","permalink":"https://didongdongdi.github.io/tags/Novel/"}]},{"title":"Flipped (Week3)","slug":"Flipped_Week3","date":"2018-05-26T05:17:00.000Z","updated":"2019-05-26T05:25:31.232Z","comments":true,"path":"2018/05/26/Flipped_Week3/","link":"","permalink":"https://didongdongdi.github.io/2018/05/26/Flipped_Week3/","excerpt":"2018-07-11-p141, stalk [stɔːk] n. （植物的）茎，秆；（支持叶子、果实和花的）梗，柄；追踪；高视阔步 vt. 追踪，潜近；高视阔步 vi. 高视阔步地走；潜近，偷偷接近","text":"2018-07-11-p141, stalk [stɔːk] n. （植物的）茎，秆；（支持叶子、果实和花的）梗，柄；追踪；高视阔步 vt. 追踪，潜近；高视阔步 vi. 高视阔步地走；潜近，偷偷接近 2, flinch [‘flɪn(t)ʃ] vi. 退缩；畏惧 n. 退缩；畏惧 3, look away 转移目光；扭头看别处；把脸转过去 4, pass the salt 递食盐 爱已消失，覆水难收（俗语） 5, prejudice [‘predʒʊdɪs] n. 偏见；侵害 vt. 损害；使有偏见 6, dismiss [dɪs’mɪs] vt. 解散；解雇；开除；让…离开；不予理会、不予考虑 vi. 解散 7, slam [slæm] vt. 砰地关上；猛力抨击 vi. 砰地关上；猛力抨击 n. 猛击；砰然声 n. (Slam)人名；(阿拉伯)萨拉姆；(罗)斯拉姆 8, flop down 趴倒 重重地坐下或躺下 9, fume [fjuːm] vi. 冒烟；发怒 vt. 熏；冒烟；愤怒地说 n. 烟；愤怒，烦恼 n. (Fume)人名；(日)不免(姓) 10, shove [ʃʌv] vt. 挤；强使；撞；猛推 n. 推；挤 n. (Shove)人名；(英)肖夫 11, sulky [‘sʌlkɪ] adj. 生气的；阴沉的 12, shaker [‘ʃeɪkə] n. 振动器；混和器；调酒器 n. (Shaker)人名；(阿拉伯、哈萨、乌兹、塔吉、吉尔、阿塞)沙克尔 13, raisin [‘reɪz(ə)n] n. 葡萄干 n. (Raisin)人名；(法)雷森 14, nibble [‘nɪb(ə)l] vi. 细咬；一点一点地咬；吹毛求疵 vt. 细咬；一点一点地咬；吹毛求疵 n. 轻咬；啃；细咬 15, gristle [‘grɪs(ə)l] n. 软骨；软骨结构 16, shakedown [‘ʃeɪkdaʊn] n. 调整，整顿；临时床铺；勒索；彻底搜查 adj. 试航的 17, upper [‘ʌpə] adj. 上面的，上部的；较高的 n. (Upper)人名；(英)厄珀 18, circus [‘sɜːkəs] n. 马戏；马戏团 19, jag [dʒæg] n. 缺口；狂欢 vt. 使成锯齿状；使成缺口 20, be miffed at 是有点生气 21, Nada abbr. 美国汽车经销商联合会（the National Automobile Dealers Association） n. (Nada)人名；(塞、葡、俄、阿拉伯、英)娜达(女名)，纳达 22, halfway [hɑːf’weɪ; ‘hɑːfweɪ] adv. 到一半；在中途 adj. 中途的；不彻底的 23, sneak a peek 偷看 excused myself and holed up in my room原谅我自己躲在我的房间里 I’m bent about something. take cuts in the milk line they wound up grinding it down into the dirt 他们把它碾成泥土 2018-07-12-p15take cuts in the milk line they wound up grinding it down into they dirt. 他们把它碾成泥土。 1, punch in 上班打卡 2, hung up 挂断，提高；挂起来；套牢 3, fake [feɪk] n. 假货；骗子；假动作 vt. 捏造；假装…的样子 vi. 假装；做假动作 adj. 伪造的 n. (Fake)人名；(英)费克 4, whip [wɪp] vt. 抽打；煽动；搅打（蛋，奶油）；彻底击败 n. 鞭子；抽打；车夫；[机] 搅拌器 vi. 抽打；急走；拍击 5, charge through 从人丛中冲过 6, unsolicited [ʌnsə’lɪsɪtɪd] adj. 未经请求的；主动提供的 7, edification [,edɪfɪ’keɪʃ(ə)n] n. 启迪；教诲；精神修养 8, hurry off 匆匆离去 9, sycamore [‘sɪkəmɔː] n. 美国梧桐；西克莫无花果树；假挪威槭 10, stump [stʌmp] n. 树桩；残余部分；假肢 vt. 砍伐；使为难；在…作巡回政治演说 vi. 笨重地行走；发表竞选演说 n. (Stump)人名；(英)斯顿普；(德)施通普 11, sucker [‘sʌkə] n. 吸管；乳儿；易受骗的人 vi. 成为吸根；长出根出条 vt. 从……除去吸根 n. (Sucker)人名；(德)祖克尔 12, budge [bʌdʒ] vi. 挪动；微微移动；改变态度或意见；服从 vt. 使让步；移动；使改变态度或意见 n. 羔羊皮 n. (Budge)人名；(英)巴奇 13, derailleur [dɪ’reɪl(j)ə] n. （法）变速器；装有变速器的自行车 14, rusty [‘rʌstɪ] adj. 生锈的，腐蚀的；铁锈色的，锈色的；迟钝的 15, lookout [‘lʊkaʊt] n. 监视；监视哨；警戒；守望者；担心的事；前景 16, truck [trʌk] n. 卡车；交易；手推车 vi. 驾驶卡车；以物易物 vt. 交易；以卡车运输 adj. （美）运货汽车的 n. (Truck)人名；(德)特鲁克 17, poncho [‘pɒn(t)ʃəʊ] n. 雨披；南美披风 18, let out v. 放出；泄露；出租 19, in the nick of time 及时；恰好 20, soak [səʊk] vt. 吸收，吸入；沉浸在（工作或学习中）；使……上下湿透 vi. 浸泡；渗透 n. 浸；湿透；大雨 21, misinterpret [mɪsɪn’tɜːprɪt] vt. 曲解，误解 22, landscape [ˈlændskeɪp] n. 风景；风景画；景色；山水画；乡村风景画；地形；（文件的）横向打印格式 vt. 对…做景观美化，给…做园林美化；从事庭园设计 vi. 美化（环境等），使景色宜人；从事景观美化工作，做庭园设计师 23, weary [‘wɪərɪ] adj. 疲倦的；厌烦的；令人厌烦的 vi. 疲倦；厌烦 vt. 使疲倦；使厌烦 24, studio [‘stjuːdɪəʊ] n. 工作室；[广播][电视] 演播室；画室；电影制片厂 25, garage [ˈgærɑ:ʒ, ˈgærɪdʒ;] n. 车库；汽车修理厂；飞机库 vt. 把……送入车库；把（汽车）开进车库 n. （阿拉伯）贾拉杰（人名） 26, mason [‘meɪs(ə)n] n. 泥瓦匠；共济会会员（等于freemason） vt. 用砖瓦砌成 27, snapshots n. [摄] 快照（snapshot的复数） v. 拍快照（snapshot的三单形式） 28, clip [klɪp] n. （塑料或金属的）夹子；回纹针；修剪；剪报 vt. 剪；剪掉；缩短；给…剪毛（或发）用别针别在某物上，用夹子夹在某物上 vi. 剪；修剪；剪下报刊上的文章（或新闻、图片等）；迅速行动；用别针别在某物上，用夹子夹在某物上 29, easel [‘iːz(ə)l] n. 画架；黑板架 30, canvas [‘kænvəs] n. 帆布 vt. 用帆布覆盖，用帆布装备 adj. 帆布制的 31, transcend [træn’send; trɑːn-] vt. 胜过，超越 32, callus [‘kæləs] n. [皮肤] 胼胝；愈合组织；老茧 vt. 使生老茧；使变硬；使结痂 vi. 变硬；结痂；生老茧 n. (Callus)人名；(法)卡吕；(意)卡卢斯 33, possess [pə’zes] vt. 控制；使掌握；持有；迷住；拥有，具备 34, graceful [‘greɪsfʊl; -f(ə)l] adj. 优雅的；优美的 35, spiritual [‘spɪrɪtʃʊəl; -tjʊəl] n. 圣歌（尤指美国南部黑人的） adj. 精神的，心灵的 36, porch [pɔːtʃ] n. 门廊；走廊 37, peep [piːp] n. 偷看；隐约看见，瞥见 vi. 窥视；慢慢露出，出现；吱吱叫 vt. 使出现 n. (Peep)人名；(爱沙)佩普","categories":[{"name":"English","slug":"English","permalink":"https://didongdongdi.github.io/categories/English/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://didongdongdi.github.io/tags/Notes/"},{"name":"Vocabulary","slug":"Vocabulary","permalink":"https://didongdongdi.github.io/tags/Vocabulary/"},{"name":"Novel","slug":"Novel","permalink":"https://didongdongdi.github.io/tags/Novel/"}]},{"title":"Flipped (Week4)","slug":"Flipped_Week4","date":"2018-05-26T05:17:00.000Z","updated":"2019-05-26T05:25:19.505Z","comments":true,"path":"2018/05/26/Flipped_Week4/","link":"","permalink":"https://didongdongdi.github.io/2018/05/26/Flipped_Week4/","excerpt":"2018-07-20-p161, hay [heɪ] n. 干草 vt. 把晒干 vi. 割草晒干","text":"2018-07-20-p161, hay [heɪ] n. 干草 vt. 把晒干 vi. 割草晒干 2, cheek [tʃiːk] n. 面颊，脸颊；臀部 vt. 无礼地向…讲话，对…大胆无礼 n. (Cheek)人名；(英)奇克 3, blush [blʌʃ] vi. 脸红；感到惭愧 n. 脸红；红色；羞愧 vt. 红著脸表示；使成红色 n. (Blush)人名；(英)布拉什 4, scatter [‘skætə] vi. 分散，散开；散射 vt. 使散射；使散开，使分散；使散播，使撒播 n. 分散；散播，撒播 5, record-breaking [‘rɛkəd,brekɪŋ] adj. 破纪录的 n. 破纪录 6, lighting [‘laɪtɪŋ] n. 照明设备，舞台灯光 v. 照明；点燃（light的ing形式） 7, mature [mə’tʃʊə] adj. 成熟的；充分考虑的；到期的；成年人的 vi. 成熟；到期 vt. 使…成熟；使…长成；慎重作出 8, philosophical [fɪlə’sɒfɪk(ə)l] adj. 哲学的（等于philosophic）；冷静的 9, digit [‘dɪdʒɪt] n. 数字；手指或足趾；一指宽 10, meadow [‘medəʊ] n. 草地；牧场 n. (Meadow)人名；(英)梅多 11, peek through 12, a beam of light 一束光；一束光线，一缕光线 13, vacant [‘veɪk(ə)nt] adj. 空虚的；空的；空缺的；空闲的；茫然的 n. (Vacant)人名；(法)瓦康 14, a built-in slide 一个内置幻灯片 15, trunk [trʌŋk] n. 树干；躯干；象鼻；汽车车尾的行李箱 vt. 把…放入旅行箱内 adj. 干线的；躯干的；箱子的 n. (Trunk)人名；(德、匈、西)特伦克 16, bent up 上弯的 17, a complete spiral 一个完整的循环 18, a sapling 一颗树苗 19, A testimony to endurance 耐力的见证 20, dive-bomb v. 俯冲轰炸 21, flown [fləʊn] v. 飞行（fly的过去分词） 22, ornery [‘ɔːnərɪ] adj. 坏脾气的；低劣的 23, stripes [st’raɪps] n. 条子布；条纹布（stripe复数形式） v. 给…加条纹（stripe的三单形式） 24, exhaustion [ɪg’zɔːstʃ(ə)n; eg-] n. 枯竭；耗尽；精疲力竭 25, poop out 丧失功能，丧失活力 （使）筋疲力尽，（使）疲乏 as oppose to spite 反对，尽管 Thirty feet up they just sort of smirk at you and crash for the fun of it. 30英尺高的时候，他们只是在嘲笑你，然后为它的乐趣而崩溃。 2018-07-21-p171, scout out 寻找 2, flash [flæʃ] vt. 使闪光；反射 n. 闪光，闪现；一瞬间 vi. 闪光，闪现；反射 adj. 闪光的，火速的 n. (Flash)人名；(西)弗拉什 3, shinny up 攀爬起来 4, amount of 数量的 5, intersections n. 交集，交叉点（intersection的复数形式）；[交] 十字路口 6, rooftops [‘rʊf’tɑp] n. 屋顶 adj. 屋顶上的 7, dizzy [‘dɪzɪ] adj. 晕眩的；使人头晕的；昏乱的；心不在焉的；愚蠢的 vt. 使头晕眼花；使混乱；使茫然 n. (Dizzy)人名；(英)迪齐 8, string [strɪŋ] n. 线，弦，细绳；一串，一行 9, tangle [‘tæŋg(ə)l] n. 纠纷；混乱状态 vt. 使纠缠；处于混乱状态 vi. 缠结；乱作一团 10, soar [sɔː] vi. 高飞；高耸；往上飞舞 n. 高飞；高涨 n. (Soar)人名；(英、葡)索尔 11, breeze [briːz] n. 微风；轻而易举的事；煤屑；焦炭渣；小风波 vi. 吹微风；逃走 n. (Breeze)人名；(法)布雷兹 12, pomegranate [‘pɒmɪgrænɪt] n. 石榴 13, prized stripes 珍贵的条纹 14, nudge [nʌdʒ] n. 推动；用肘轻推；没完没了抱怨的人 vt. 推进；用肘轻推；向…不停地唠叨 vi. 轻推；推进；唠叨 15, rip [rɪp] vt. 撕；锯 vi. 裂开，被撕裂 n. 裂口，裂缝 n. (Rip)人名；(塞)里普 16, beet [biːt] n. 甜菜；甜菜根 vt. 生火；修理；改过 17, inspect [ɪn’spekt] vt. 检查；视察；检阅 vi. 进行检查；进行视察","categories":[{"name":"English","slug":"English","permalink":"https://didongdongdi.github.io/categories/English/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://didongdongdi.github.io/tags/Notes/"},{"name":"Vocabulary","slug":"Vocabulary","permalink":"https://didongdongdi.github.io/tags/Vocabulary/"},{"name":"Novel","slug":"Novel","permalink":"https://didongdongdi.github.io/tags/Novel/"}]},{"title":"STM32 J-LINK与ST-LINK 引脚定义","slug":"JLINK_STLINK","date":"2018-05-26T05:17:00.000Z","updated":"2019-05-26T05:24:53.357Z","comments":true,"path":"2018/05/26/JLINK_STLINK/","link":"","permalink":"https://didongdongdi.github.io/2018/05/26/JLINK_STLINK/","excerpt":"![JTAG](JTAG.jpg)","text":"![JTAG](JTAG.jpg) ![SWG](SWG.jpg)","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://didongdongdi.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[{"name":"STM32","slug":"STM32","permalink":"https://didongdongdi.github.io/tags/STM32/"}]},{"title":"English Mixed","slug":"Mixed","date":"2018-05-26T05:17:00.000Z","updated":"2019-05-26T05:24:37.029Z","comments":true,"path":"2018/05/26/Mixed/","link":"","permalink":"https://didongdongdi.github.io/2018/05/26/Mixed/","excerpt":"#2018-06-16 Independence Dayaerial // 空中的；航空的 petty //小的；琐碎的 fate //n.命运 v.注定","text":"#2018-06-16 Independence Dayaerial // 空中的；航空的 petty //小的；琐碎的 fate //n.命运 v.注定 Not from tyranny, oppression, or persecution, but from annihilation. //不是来自暴政、压迫或是迫害，而是来自消灭。 vanish //v.消失；绝迹 East or west, home is the best. //金窝银窝不如自己的狗窝。 #2018-06-09 love your curves and all your edges ,all your perfect imperfections. //爱你的曲线和你所有的棱角，你所有的完美的不完美。","categories":[{"name":"English","slug":"English","permalink":"https://didongdongdi.github.io/categories/English/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://didongdongdi.github.io/tags/Notes/"},{"name":"Vocabulary","slug":"Vocabulary","permalink":"https://didongdongdi.github.io/tags/Vocabulary/"},{"name":"Mixed","slug":"Mixed","permalink":"https://didongdongdi.github.io/tags/Mixed/"}]},{"title":"Qt5教程","slug":"Qt5教程","date":"2018-05-26T05:17:00.000Z","updated":"2019-05-26T05:24:28.681Z","comments":true,"path":"2018/05/26/Qt5教程/","link":"","permalink":"https://didongdongdi.github.io/2018/05/26/Qt5%E6%95%99%E7%A8%8B/","excerpt":"","text":"https://www.cnblogs.com/farewell-farewell/p/7159596.html","categories":[{"name":"Qt5","slug":"Qt5","permalink":"https://didongdongdi.github.io/categories/Qt5/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://didongdongdi.github.io/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"the Classification of Programming Language","slug":"the Classification of Programming Language","date":"2018-05-26T05:17:00.000Z","updated":"2019-05-26T05:24:18.281Z","comments":true,"path":"2018/05/26/the Classification of Programming Language/","link":"","permalink":"https://didongdongdi.github.io/2018/05/26/the%20Classification%20of%20Programming%20Language/","excerpt":"计算机语言分类低级语言 高级语言 专用语言 脚本语言","text":"计算机语言分类低级语言 高级语言 专用语言 脚本语言 对数据类型的要求强类型语言—-强调数据类型 弱类型语音—-忽略数据类型 具体介绍低级语言机器语言、汇编语言和符号语言 注意：汇编语言源程序必须经过汇编，生成目标文件，然后执行 高级语言BASIC（True basic、Qbasic、Virtual Basic）、C、C++、PASCAL、FORTRAN、智能化语言（LISP、Prolog）、动态语言(Python、PHP、Ruby、Lua)等等。 注意：高级语言源程序可以用解释、编译两种方式执行。通常用后一种。 我们使用的C语言就是使用的后者。 专用语言CAD系统中的绘图语言和DBMS的数据库查询语言。 脚本语言（Script language，scripting language，scripting programming language）是为了缩短传统的编写-编译-链接-运行（edit-compile-link-run） 过程而创建的计算机编程语言。脚本语言一般都有相应的脚本引擎来解释执行。 他们一般需要解释器才能运行。一个脚本通常是解释运行而非编译。脚本语言通常都有简单、易学、易用的特性，目的就是希望能让程序员快速完成程序的编写工作。 计算机高级语言编译型语言编译是指在应用源程序执行之前，就将程序源代码“翻译”成目标代码(机器语言)，因此其目标程序可以脱离其语言环境独立执行，使用比较方便、效率较高 。但应用程序一旦需要修改，必须先修改源代码，再重新编译生成新的目标文件(＊ .OBJ)才能执行，只有目标文件而没有源代码，修改很不方便。现在大多数的编程语言都是编译型的。编译程序将源程序翻译成目标程序后保存在另一个文件中，该目标程序可脱离编译程序直接在计算机上多次运行。大多数软件产品都是以目标程序形式发行给用户的，不仅便于直接运行，同时又使他人难于盗用其中的技术。C、 C++、Fortran、Visual Foxpro、Pascal、Delphi、Ada都是编译实现的。 解释型语言解释型语言的实现中，翻译器并不产生目标机器代码，而是产生易于执行的中间代码，这种中间代码与机器代码是不同的，中间代码的解释是由软件支持的，不能直接使用硬件，软件解释器通常会导致执行效率较低。用解释型语言编写的程序是由另一个可以理解中间代码的解释程序执行的。与编译程序不同的是，解释程序的任务是逐一将源程序的语句解释成可执行的机器指令，不需要将源程序翻译成目标代码后再执行。解释程序的优点是当语句出现语法错误时，可以立即引起程序员注意，而程序员在程序开发期间就能进行校正。对于解释型Basic语言，需要一个专门的解释器解释执行 Basic程序，每条语言只有在执行才被翻译。这种解释型语言每执行一次就翻译一次，因而效率低下。一般地，动态语言都是解释型的，如Tcl、 Perl、Ruby、VBScript、 JavaScript等。 混合型Java很特殊，Java程序也需要编译，但是没有直接编译成为机器语言，而是编译成为字节码，然后在Java虚拟机上用解释方式执行字节码。Python 的也采用了类似Java的编译模式，先将Python程序编译成Python字节码，然后由一个专门的 Python字节码解释器负责解释执行字节码。 脚本语言动态程序一般有两种实现方式，一是二进制方式，一是脚本方式。 二进制方式是先将我们编写的程序进行编译，变成机器可识别的指令代码（如.exe文件），然后再执行。这种编译好的程序我们只能执行、使用，却看不到他的程序内容。 脚本程序相对一般程序开发来说比较接近自然语言，可以不经编译而是解释执行，利于快速开发或一些轻量的控制。一般的脚本语言的执行只同具体的解释执行器有关，所以只要系统上有相应语言的解释程序就可以做到跨平台。脚本script是使用一种特定的描述性语言，依据一定的格式编写的可执行文件，又称作宏或批处理文件。脚本通常可以由应用程序临时调用并执行。各类脚本目前被广泛地应用于网页设计中，因为脚本不仅可以减小网页的规模和提高网页浏览速度，而且可以丰富网页的表现，如动画、声音等。 脚本简单地说就是一条条的文字命令，这些文字命令是我们可以看到的（如可以用记事本打开查看、编辑），脚本程序在执行时，是由系统的一个解释器，将其一条条的翻译成机器可识别的指令，并按程序顺序执行。因为脚本在执行时多了一道翻译的过程，所以它比二进制程序执行效率要稍低一些。 我们上面提到的各种动态语言，如ASP、PHP、CGI、JSP等，都是脚本语言。 按目前的服务规则，虚拟主机网站只能采用脚本语言来实现。脚本英文为Script。实际上脚本就是程序，一般都是有应用程序提供的编程语言。应用程序包括浏览器(javascript、VBScript)、多媒体创作工具，应用程序的宏和创作系统的批处理语言也可以归入脚本之类。脚本同我们平时使用的VB、C语言等的区别主要是： 1、脚本语法比较简单，比较容易掌握。 2、脚本与应用程序密切相关，所以包括相对应用程序自身的功能。 3、脚本一般不具备通用性，所能处理的问题范围有限。 4、脚本语言(JavaScript,VBscript等)介于HTML和C,C++,Java,C#等编程语言之间。 HTML通常用于格式化和链结文本。而编程语言通常用于向机器发出一系列复杂的指令。 5、脚本语言与编程语言也有很多相似地方，其函数与编程语言比较相象一些,其也涉及到变量。与编程语言之间最大的区别是编程语言的语法和规则更为严格和复杂一些。 6、与程序代码的关系:脚本也是一种语言，其同样由程序代码组成。 注：脚本语言一般都有相应的脚本引擎来解释执行。 他们一般需要解释器才能运行。JAVASCRIPT,ASP,PHP,PERL,Nuva都是脚本语言。C/C++编译、链接后，可形成独立执行的exe文件。 7、脚本语言是一种解释性的语言,例如vbscript,javascript,installshield script等等,它不象c/c++等可以编译成二进制代码,以可执行文件的形式存在. 脚本语言不需要编译，可以直接用，由解释器来负责解释。 8、脚本语言一般都是以文本形式存在,类似于一种命令. 举个例子说,如果你建立了一个程序,叫aaa.exe,可以打开.aa为扩展名的文件. 你为.aa文件的编写指定了一套规则(语法),当别人编写了.aa文件后,你的程序用这种规则来理解编写人的意图,并作出回应.那么,这一套规则就是脚本语言. 脚本是批处理文件的延伸，是一种纯文本保存的程序，一般来说的计算机脚本程序是确定的一系列控制计算机进行运算操作动作的组合，在其中可以实现一定的逻辑分支等。 新兴编程语言perl擅长文字处理，python擅长数值处理。Perl设计之初就是为了方便编写复杂高效的系统脚本，它也是应该最为广泛的脚本编程语言。它在编程方面相当于瑞士军刀，对字符、文本文件处理能力很强，以前要求 shell+sed+awk+C才能完成的任务，只需perl脚本就可以完成了。而且应用领域一直在拓宽，支持面向对象程序设计。Python面向对象的动态公共语言，适于脚本编程和快速开发，它最显著的特点是作为编译语言（如C）和脚本语言（如perl）之间的桥接语言，它具有的强大功能，可扩充性及面向对象的特征使其成为大规模应用程序开发工具。 ![the Classification of Programming Language](the Classification of Programming Language.jpg)","categories":[{"name":"Programming Language","slug":"Programming-Language","permalink":"https://didongdongdi.github.io/categories/Programming-Language/"}],"tags":[{"name":"Classification","slug":"Classification","permalink":"https://didongdongdi.github.io/tags/Classification/"}]},{"title":"模拟与数字电路笔记","slug":"模拟与数字电路笔记","date":"2018-05-26T05:17:00.000Z","updated":"2019-05-26T05:24:10.546Z","comments":true,"path":"2018/05/26/模拟与数字电路笔记/","link":"","permalink":"https://didongdongdi.github.io/2018/05/26/%E6%A8%A1%E6%8B%9F%E4%B8%8E%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E7%AC%94%E8%AE%B0/","excerpt":"基础知识","text":"基础知识 模拟电路部分半导体器件 注（此为个人笔记，因个人水平限制尚有许多不完善的地方，如有不当之处，欢迎指正，未补充的地方还请自行看书）（可下载图片查看MindMap）","categories":[{"name":"模拟与数字电路","slug":"模拟与数字电路","permalink":"https://didongdongdi.github.io/categories/%E6%A8%A1%E6%8B%9F%E4%B8%8E%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://didongdongdi.github.io/tags/Notes/"},{"name":"MindMap","slug":"MindMap","permalink":"https://didongdongdi.github.io/tags/MindMap/"}]},{"title":"Hexo博客 站内搜索 配置 (swiftype)","slug":"站内搜索","date":"2018-05-26T05:17:00.000Z","updated":"2019-05-26T05:23:58.610Z","comments":true,"path":"2018/05/26/站内搜索/","link":"","permalink":"https://didongdongdi.github.io/2018/05/26/%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/","excerpt":"前言随着博客的文章增多，添加一个博客站内搜索的功能就显得很有必要。 而第三方站内搜索的插件有：","text":"前言随着博客的文章增多，添加一个博客站内搜索的功能就显得很有必要。 而第三方站内搜索的插件有： google自定义搜索（免费的标准版貌似有广告而且要科学上网） 百度站内搜索（貌似不支持https并且只显示收录的页面） swiftype站内搜索（我的选择） swiftype网站配置 首先注册swiftype账号并登录，也可直接使用google账号登录 然后选择CREATE A NEW ENGINE,再进行填入网址等一系列操作,设置默认就好 得到左边为各项设置的搜索引擎界面 ![搜索引擎界面左边](swiftype_left.png) 点击install search，进入安装代码界面,并将这段代码复制 ![安装代码](install_code.jpg) 点击change configuration，可以看到左边有设置选项 ![设置选项](configuration.png) 特别注意，search field选项 如果博客本身就有搜索框，那么修改搜索框的class为st-default-search-input就好了但是如果没有，则可以自行添加搜索框，并修改class；或者选择swiftype提供的搜索框即可由于我的博客（random主题）本身没有搜索框，所以直接选择了swiftype提供的搜索框 ![显示效果](search_box.png) 同时，可以在左侧的设置选项中查看搜索统计情况、预览搜索结果、设置搜索权重、添加域名、查看抓取的页面等 注意：swiftype的爬虫抓取页面需要一定的时间，所以可能需要等一会 到此为止，swiftype网站的配置就完成了 博客的配置 打开博客主题的配置文件_config.yml，在最后添加 123# swiftype站内搜索swift_search:enable: true 打开博客主题的layout文件夹，在其中找到footer.swig文件（或者其他以footer命名的文件），把之前复制的脚本代码粘贴到其中 注意：要放在body标签中 至此，博客站内搜索的工作就做完了，然后重新将博客deploy即可 搜索效果 ![搜索效果](search_results.png)","categories":[{"name":"Blog","slug":"Blog","permalink":"https://didongdongdi.github.io/categories/Blog/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://didongdongdi.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"Hexo","slug":"Hexo","permalink":"https://didongdongdi.github.io/tags/Hexo/"},{"name":"swiftype","slug":"swiftype","permalink":"https://didongdongdi.github.io/tags/swiftype/"}]},{"title":"线性代数与解析几何笔记","slug":"线性代数与解析几何笔记","date":"2018-05-26T05:17:00.000Z","updated":"2019-05-26T05:23:40.826Z","comments":true,"path":"2018/05/26/线性代数与解析几何笔记/","link":"","permalink":"https://didongdongdi.github.io/2018/05/26/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B8%8E%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95%E7%AC%94%E8%AE%B0/","excerpt":"前言线性代数与几何空间从来不是分离开来的，几何空间是线性代数的本质，而线性代数是几何空间的抽象表示。因此，推荐大家去学习B站 3Blue1Brown 线性代数的本质 系列视频(我从中受益匪浅)。相信你在听了他的课程后会对线性代数有着更深一层次的理解。","text":"前言线性代数与几何空间从来不是分离开来的，几何空间是线性代数的本质，而线性代数是几何空间的抽象表示。因此，推荐大家去学习B站 3Blue1Brown 线性代数的本质 系列视频(我从中受益匪浅)。相信你在听了他的课程后会对线性代数有着更深一层次的理解。 ![线性代数的本质](线性代数的本质.png) 矩阵及其初等变换 注（此为个人笔记，因个人水平限制尚有许多不完善的地方，如有不当之处，欢迎指正，未补充的地方还请自行看书）（可下载图片查看MindMap）","categories":[{"name":"线代","slug":"线代","permalink":"https://didongdongdi.github.io/categories/%E7%BA%BF%E4%BB%A3/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://didongdongdi.github.io/tags/Notes/"},{"name":"MindMap","slug":"MindMap","permalink":"https://didongdongdi.github.io/tags/MindMap/"}]},{"title":"Hexo博客 添加评论功能 （来必力 livere）& Template render error (Hexo BUG)","slug":"评论功能","date":"2018-05-26T05:17:00.000Z","updated":"2019-05-26T05:23:50.975Z","comments":true,"path":"2018/05/26/评论功能/","link":"","permalink":"https://didongdongdi.github.io/2018/05/26/%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD/","excerpt":"前言作为一个完整的博客，评论功能自然是必不可少的。 而可供选择的第三方评论系统有很多，但不是被墙（如Disqus）就是停止服务（如友言、网易云跟帖），或者需要域名备案（如畅言）。 所以只能把目光投向一款来自韩国的评论系统——来必力(livere)。","text":"前言作为一个完整的博客，评论功能自然是必不可少的。 而可供选择的第三方评论系统有很多，但不是被墙（如Disqus）就是停止服务（如友言、网易云跟帖），或者需要域名备案（如畅言）。 所以只能把目光投向一款来自韩国的评论系统——来必力(livere)。 总的来说，这个评论系统有以下好处： 1.有中文网站2.界面还算美观3.国内本土化做得很好，支持如下账号登录： ![支持账号](login.png) 来必力网站配置 进入官网 https://livere.com ,邮箱注册登录 点击安装，选择City免费版，点击现在安装 获得安装代码并复制 ![安装代码](install_code.jpg) 到此为止，网站的配置到此结束；当然，如果需要修改登录选项和评论界面，可以在设置中更改 博客的配置 打开博客主题的配置文件_config.yml，加上如下代码： 123# Support for LiveRe comments system.# You can get your uid from https://livere.com/insight/myCode (General web site)livere_uid: 在livere_uid:后加上安装代码中data-uid的内容,以便以后修改 打开博客主题的layout文件夹 在includes文件夹中新建一个livere.swig文件，在其中写入如下代码： 1234567891011121314&#123;% if not (theme.duoshuo and theme.duoshuo.shortname) and not theme.duoshuo_shortname and not theme.disqus_shortname and not theme.hypercomments_id and not theme.gentie_productKey %&#125; &#123;% if theme.livere_uid %&#125; &lt;script type=\"text/javascript\"&gt; (function(d, s) &#123; var j, e = d.getElementsByTagName(s)[0]; if (typeof LivereTower === 'function') &#123; return; &#125; j = d.createElement(s); j.src = 'https://cdn-city.livere.com/js/embed.dist.js'; j.async = true; e.parentNode.insertBefore(j, e); &#125;)(document, 'script'); &lt;/script&gt; &#123;% endif %&#125;&#123;% endif %&#125; 打开post.swig文件，在&lt;/article&gt;前加上如下代码： 1234567&#123;% if page.photos.length %&#125; &#123;% include 'includes/gallery.swig' %&#125;&#123;% endif %&#125;&#123;% autoescape false %&#125;&#123;&#123; page.content &#125;&#125;&#123;% endautoescape %&#125;&#123;% if theme.livere_uid %&#125; &lt;div id=\"lv-container\" data-id=\"city\" data-uid=\"&#123;&#123; theme.livere_uid &#125;&#125;\"&gt;&lt;/div&gt;&#123;% endif %&#125; 在&lt;/article&gt;后加上{% include 'includes/livere.swig' %} 最后，将博客重新deploy即可 ![最终效果](result.png) BUG!!!在写完这篇博客后，再hexo g发生错误，提示Template render error:(unknown path),后经google发现，hexo对特殊符号{% %}和{{ }}的解析有错误，其被当成hexo模板中的标签,所以出现错误无法找到路径includes/livere.swig 目前的解决办法为在这两个特殊字符之外添加如下代码： 123&#123;% raw %&#125;特殊字符&#123;% endrow %&#125; 使hexo不解析其中的特殊字符 同时注意，对于用三个```包围的代码块则不存在这样的问题","categories":[{"name":"Blog","slug":"Blog","permalink":"https://didongdongdi.github.io/categories/Blog/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://didongdongdi.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"Hexo","slug":"Hexo","permalink":"https://didongdongdi.github.io/tags/Hexo/"},{"name":"Livere","slug":"Livere","permalink":"https://didongdongdi.github.io/tags/Livere/"}]},{"title":"C++之名称空间","slug":"CPP之名称空间","date":"2018-05-25T17:26:00.000Z","updated":"2019-05-26T05:25:11.264Z","comments":true,"path":"2018/05/26/CPP之名称空间/","link":"","permalink":"https://didongdongdi.github.io/2018/05/26/CPP%E4%B9%8B%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4/","excerpt":"传统的C++名称空间一些术语 声明区域 潜在作用域变量的潜在作用域从声明点开始，到其声明区域的结尾。因此潜在作用域的比声明区域小，这是由于变量必须定义后才能使用。变量并非在其潜在作用域内的任何位置都是可见的。例如，它可能被另一个在嵌套声明区域中声明的同名变量隐藏。","text":"传统的C++名称空间一些术语 声明区域 潜在作用域变量的潜在作用域从声明点开始，到其声明区域的结尾。因此潜在作用域的比声明区域小，这是由于变量必须定义后才能使用。变量并非在其潜在作用域内的任何位置都是可见的。例如，它可能被另一个在嵌套声明区域中声明的同名变量隐藏。 C++关于全局变量和局部变量的规则定义了一种名称空间层次。每个声明区域都可以声明名称，这些名称独立于在其他声明区域中声明的名称。在一个函数中声明的局部变量不会与在另一个函数中声明的局部变量发生冲突。 新的名称空间的特性C++新增了这样一种功能，即通过定义一种新的声明区域来创建命名的名称空间，这样做的目的之一是提供一个声明名称的区域。 特性 一个名称空间中的名称不会与另外一个名称空间的相同名称发生冲突，同时允许程序的其他部分使用该名称空间中声明的东西。 名称空间可以是全局的，也可以位于另一个名称空间，但不能位于代码块中。因此，在默认情况下，在名称空间中声明的名称的链接性为外部的（除非它引用了常量）。 除了用户定义的名称空间外，还存在另一个名称空间——全局名称空间。它对应于文件级声明区域，因此前面所说的全局变量现在被描述为位于全局名称空间中。 名称空间是开放的，即可以把名称加入到已有的名称空间中。例如，下面这条语句将名称goose添加到Jill中已有的名称列表中： 123namespace Jill&#123; char * goose(const char *);&#125; 访问给定空间中的名称，通过作用域解析运算符::，使用名称空间来限定该名称。违背装饰的名称称为未限定的名称(unqualified name)；包含名称空间的名称称为限定的名称(qualified name)。 using声明和using编译指令using声明 使特定的标识符可用 由被限定的名称和它前面的关键字using组成：using Jill::fetch; 将特定的名称添加到它所属的声明区域中 在函数的外面使用using声明时，将把名称添加到全局名称空间中 using编译指令 使整个名称空间可用 由名称空间名和它前面的关键字using namespace组成；using namespace Jill; 在函数中使用using编译指令，将使其中的名称在该函数中可用 在全局声明区域中使用using编译指令，将使该名称空间的名称全局可用 using编译指令和using声明之比较使用using编译指令导入一个名称空间中所有的名称 进行名称解析，就像在包含using声明和名称空间本身的最小声明区域中声明了名称一样 使用多个using声明 好像声明了相应的名称 如果某个名称已经在函数中声明了，则不能用using声明导入相同的名称 在下面的示例中，名称空间为全局的。如果使用using编译指令导入一个已经在函数中声明的名称，则局部名称将隐藏名称空间名，就像隐藏同名的全局变量一样。不过人可以像下面的示例中那样使用作用域解析运算符： 12345678910111213141516171819202122namespace Jill&#123; double bucket(double n)&#123;...&#125; double fetch; struct Hill&#123;...&#125;;&#125;char fetch; //global namespaceint main()&#123; using namespace Jill; //import all namespace names Hill Thrill; //create a type Jill::Hill structure double water = bucket(2); //use Jill::bucket(); double fetch; //not an error; hides Jill::fetch cin &gt;&gt; fetch //read a value into the local fetch cin &gt;&gt; ::fetch; //read a value into global fetch cin &gt;&gt; Jill::fetch; //read a value into Jill::fetch ... &#125;int foom()&#123; Hill top; //ERROR Jill::Hill crest; //valid&#125; 注意： 虽然函数中的using编译指令将名称空间的名称视为在函数之外声明，但它不会使得该文件中的其他函数能够使用这些名称。因此，在前一个例子中，foom()函数不能使用未限定的标识符Hill。 一般来说，使用using声明比使用using编译指令更安全，这是由于它只导入指定的名称。如果该名称与局部名称发生冲突，编译器将发出指示。 如果系统不支持名称空间，可以将 12#include &lt;iostream&gt;using namespace std; 换成 1#include &lt;iostream.h&gt; 可以用嵌套式名称空间来创建一个包含常用using声明的名称空间。 名称空间的其他特性将名称空间声明进行嵌套123456789namespace elements&#123; namespace fire &#123; int flame; ... &#125; float water;&#125; 注意： flame指的是element::fire::flame 可以使用using namespace elements::fire的using编译指令使内部的名称可用 可以在名称空间中使用using编译指令和using声明，如下所示： 1234567namespace myth&#123; using Jill::fetch; using namespace elements; using std::cout; using std::cin;&#125; 将using编译指令用于myth名称空间的情况using编译指令是可以传递的。如果A op B 且 B op C，则A op C，则说明操作 op 是可传递的。在这个情况下，下面的语句将导入名称空间myth和elements： 1using namespace myth; 这条编译指令与下面两条编译指令等价： 12using namespace myth;using namespace elements; 可以给名称空间创建别名例如，假设有下面的名称空间： 1namespace my_very_favorite_things&#123;...&#125;; 则可以使用下面的语句让mvft成为my_very_favorite_things的别名： 1namespace mvft = my_very_favorite_things&#123;...&#125;; 可以使用这种技术来简化对嵌套名称空间的使用： 12namespace MEF = myth::elements::fire;using MEF::flame; 未命名的名称空间可以通过省略名称空间的名称来创建未命名的名称空间： 12345namespace // unnamed namespace&#123; int ice; int bandycoot;&#125; 这就像后面跟着using编译指令一样，也就是说，在该名称空间中声明的名称的潜在作用域为：从声明点到该声明区域末尾。从这方面看，它们与全局变量相似。然而，由于这种名称空间没有名称，因此不能显式地使用using编译指令或using声明来使它在其他位置都可用。具体地说，不能在未命名名称空间所属文件之外的其他文件中，使用该名称空间的名称。这提供了链接性为内部的静态变量的替代品。 例如： 1static int counts; 采用名称空间的方法可替换为： 123namespace&#123; int counts;&#125; 名称空间及其前途指导原则 使用在已命名的名称空间中声明的变量，而不是使用外部全局变量或静态全局变量 如果开发了一个函数库或类库，将其放在一个名称空间中。 仅将编译指令using作为一种将旧代码转换为使用名称空间的权宜之计。 不要在头文件中使用using编译指令首先，这样做掩盖了要让哪些名称可用；另外，包含头文件的顺序可能影响程序的行为应将其放在所有预处理编译指令#include之后 导入名称时，首先选用作用域解析符或using声明的方法。 对于using声明，首选将其作用域设置为局部而不是全局。 注意：使用名称空间的主旨使简化大型编程项目的管理工作。","categories":[{"name":"Programming Language","slug":"Programming-Language","permalink":"https://didongdongdi.github.io/categories/Programming-Language/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://didongdongdi.github.io/tags/C/"}]},{"title":"STM32之库开发","slug":"STM32之库开发","date":"2018-05-25T17:26:00.000Z","updated":"2019-05-26T05:26:27.707Z","comments":true,"path":"2018/05/26/STM32之库开发/","link":"","permalink":"https://didongdongdi.github.io/2018/05/26/STM32%E4%B9%8B%E5%BA%93%E5%BC%80%E5%8F%91/","excerpt":"STM32 Embedded Software到目前为止STM32的开发库有： 标准外设库（STD库） HAL库 LL库（ST最近才添加，随HAL源码包一起提供，目前支持的芯片也偏少）","text":"STM32 Embedded Software到目前为止STM32的开发库有： 标准外设库（STD库） HAL库 LL库（ST最近才添加，随HAL源码包一起提供，目前支持的芯片也偏少） STM32 Snippets代码示例的集合，直接基于STM32外设寄存器，可在文档和软件包中使用。 注意： 目前只在STM32F0和L0系列中有提供 代码在不同ST芯片间没有可移植性 标准外设库（Standard Peripheral Libraries）对STM32芯片的一个完整的封装，包括所有标准器件外设的器件驱动器 注意： 不支持从STM32 L0，L4和F7开始的之后的STM32系列芯片 针对某一系列芯片而言，没有可移植性 其涵盖3个抽象级别 包含位，位域和寄存器在内的完整的寄存器地址映射 涵盖所有外围功能（具有公共API的驱动器）的例程和数据结构的集合 一组包含所有可用外设的示例，其中包含最常用的开发工具的模板项目 STM32Cube配套桌面软件STMCubeMX（其中包含了HAL库和LL库） 注意： LL库和HAL库两者相互独立，只不过LL库更底层 部分HAL库会调用LL库（如：USB驱动） LL库也会调用HAL库 用户可以使用STMCubeMX直接生成对应芯片的整个项目，STMCubeMX负责整理各种需要的源码文件 HAL(Hardware Abstraction Layer-硬件抽象层)库抽象层嵌入式软件，确保跨STM32产品的最大可移植性；该库提供了一整套一致的中间组建，如RTOS,USB,TCP/IP和图形等。 LL库更接近硬件层，对需要复杂上层协议栈的外设不适用，直接操作寄存器 使用方法 独立使用：该库完全独立实现，可以完全抛开HAL库，只用LL库编程完成。在使用STM32CubeMX生成项目时，直接选LL库即可。如果使用了复杂的外设，例如USB，则会调用HAL库 混合使用：和HAL库结合使用 文章参考:STM32之HAL库、标准外设库、LL库（STM32 Embedded Software） 可参考：STM32之HAL库详解 及 手动移植","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://didongdongdi.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[{"name":"STM32","slug":"STM32","permalink":"https://didongdongdi.github.io/tags/STM32/"}]},{"title":"气象站","slug":"气象站","date":"2018-05-25T17:26:00.000Z","updated":"2019-05-26T05:26:17.637Z","comments":true,"path":"2018/05/26/气象站/","link":"","permalink":"https://didongdongdi.github.io/2018/05/26/%E6%B0%94%E8%B1%A1%E7%AB%99/","excerpt":"项目框架","text":"项目框架","categories":[{"name":"Projects","slug":"Projects","permalink":"https://didongdongdi.github.io/categories/Projects/"}],"tags":[{"name":"物联网","slug":"物联网","permalink":"https://didongdongdi.github.io/tags/%E7%89%A9%E8%81%94%E7%BD%91/"},{"name":"嵌入式","slug":"嵌入式","permalink":"https://didongdongdi.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]}]}